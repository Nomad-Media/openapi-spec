{
  "openapi": "3.0.4",
  "info": {
    "title": "Nomad Portal API",
    "description": "Nomad Portal API Documentation",
    "termsOfService": "https://www.nomad.media",
    "contact": {
      "url": "https://www.nomad.media"
    },
    "license": {
      "name": "Proprietary"
    },
    "version": "2026-03"
  },
  "servers": [
    {
      "url": "https://your-service-url/api",
      "description": "Set this to your Nomad Media service API base URL"
    }
  ],
  "paths": {
    "/account/check-availability": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Check whether an email address is available for registration.",
        "description": "\r\n<b>Behavior:</b> Checks if the specified email address is already in use by an existing account.\r\n            Returns true if the email is available for registration, false if it is already taken.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.CheckEmailAvailabilityRequestModel containing the Email address to check.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CheckEmailAvailabilityRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CheckEmailAvailabilityRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CheckEmailAvailabilityRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CheckEmailAvailabilityRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CheckEmailAvailabilityRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CheckEmailAvailabilityRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CheckEmailAvailabilityRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns true if the email is available, false if already registered.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "The request is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/user": {
      "put": {
        "tags": [
          "Account"
        ],
        "summary": "Update the profile of the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Updates the authenticated user's profile information including FirstName, LastName,\r\n            and custom Properties. Users can only update their own profile — the Id in the request must match\r\n            the authenticated user.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]). Users can only update their own profile.\r\n\r\n<b>Side Effects:</b> Updates the user's profile information.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null. Returns 404 if the user is not found.\r\n            Throws if the authenticated user attempts to update a different user's profile.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Security.UserModel containing the updated FirstName, LastName, and Properties. The Id field must match the authenticated user.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user profile was successfully updated. Returns the updated user.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The user entity was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "Account"
        ],
        "summary": "Get the profile of the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Retrieves the profile information for the currently authenticated user based on their access token.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the user profile cannot be found. Returns 401 if the caller is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the authenticated user's profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "404": {
            "description": "The user entity was not found for the authenticated user's ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/invite-user": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Invite one or more users as guests with access to specific content.",
        "description": "\r\n<b>Behavior:</b> Sends guest invitations to the specified email addresses, granting them access to the\r\n            specified content. For each email: if the user does not already exist, a new guest account is created with\r\n            PendingInvitation status and an expiration date based on the guest profile settings. An invitation email\r\n            is sent to each recipient with instructions to complete their registration.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Creates guest user accounts with PendingInvitation status. Grants content access permissions. Sends invitation emails to each specified email address.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null, Emails array is empty, or ContentDefinitionId is missing.",
        "requestBody": {
          "description": "A Nomad.Common.Models.UserInviteRequestModel containing the Emails to invite, ContentDefinitionId for the content to share, and optional ContentId for specific content.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "All invitations were sent successfully."
          },
          "400": {
            "description": "The request is null, Emails is empty, or ContentDefinitionId is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/remove-user": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Remove content access for a user, revoking their invitation or shared access.",
        "description": "\r\n<b>Behavior:</b> Revokes the specified user's access to the given content. Specify the user by UserId or Emails.\r\n            The user's active sessions for this content are terminated. If the user has no remaining content access,\r\n            their account may be deleted (if still pending invitation) or expired (if active).\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]). Caller must have permissions on the specified ContentId.\r\n\r\n<b>Side Effects:</b> Revokes content access permissions. Terminates related user sessions.\r\n            May delete the user account if they have no remaining content access and their invitation was still pending.\r\n            May expire the user account if they have no remaining content access.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or neither UserId nor Emails are provided. Throws if the caller lacks permissions on the ContentId.",
        "requestBody": {
          "description": "A Nomad.Common.Models.UserInviteRequestModel containing UserId or Emails to remove, and the ContentId/ContentDefinitionId specifying which content access to revoke.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserInviteRequestModel"
                  }
                ],
                "description": "Request model for inviting or removing guest users with content access."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user's content security was successfully removed."
          },
          "400": {
            "description": "The request is null or neither UserId nor Emails are provided.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/login": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Authenticate a user and obtain a JWT access token.",
        "description": "\r\n<b>Behavior:</b> Validates the user's credentials and, if successful, creates a new session and returns\r\n            a JWT access token with a refresh token. Accounts that are disabled, expired, pending invitation, or pending\r\n            approval will be rejected. Guest users must have a valid profile and permitted application access.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Creates a new user session. The login event is recorded for auditing purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns 404 if authentication fails or the user cannot be found.\r\n            Returns 403 if the user account is Disabled, Expired, PendingInvitation, or PendingApproval.\r\n            LoginStatus on the response indicates the specific failure reason (e.g., IsDisabled, IsPendingEmailConfirmation, RequiresNewPassword).",
        "requestBody": {
          "description": "A Nomad.Common.Models.Security.LoginRequestModel containing the user's email (UserName), password, and optional ApplicationId for session tracking.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Authentication succeeded. Returns the JWT token, refresh token, user profile, and session information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountLoginResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is null or missing required fields (UserName, Password).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Authentication failed — invalid credentials or user not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/logout": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Log out the currently authenticated user and end their session.",
        "description": "\r\n<b>Behavior:</b> Ends the user's active session and invalidates the authentication token.\r\n            If a UserSessionId is provided, that specific session is terminated.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Terminates the user session. The logout event is recorded for auditing purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Security.LogoutRequestModel containing the optional UserSessionId to delete and optional ApplicationId.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user was successfully logged out and the session was deleted."
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/ping": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Check if the user session is still valid and update the session activity timestamp.",
        "description": "\r\n<b>Behavior:</b> Validates that the specified session is still active and keeps it alive by updating its\r\n            last activity timestamp. If single-session enforcement is enabled, detects whether the session has been replaced\r\n            by a newer login. Also checks whether the user's account has expired.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Updates the session's last activity timestamp. May mark the session as expired if the user account is no longer valid.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns PingStatus.AccountExpired if the user or session is expired.\r\n            Returns PingStatus.SessionReplaced if single-session enforcement detected a newer session.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.PingRequestModel containing the UserSessionId and optional ApplicationId.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The session is valid. PingStatus will be Normal for active sessions, or AccountExpired/SessionReplaced if the session should be terminated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PingResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is null or UserSessionId is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/refresh-token": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Retrieve a new JWT access token using a refresh token.",
        "description": "\r\n<b>Behavior:</b> Exchanges a valid refresh token for a new JWT access token. The response includes\r\n            the new token, a new refresh token, and the expiration duration in seconds.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required. The refresh token itself serves as the credential.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns 404 if the refresh token is invalid or expired.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.RefreshTokenRequestModel containing the RefreshToken obtained from a previous login or token refresh.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Token refresh succeeded. Returns a new JWT token and refresh token.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountLoginResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is null or RefreshToken is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The refresh token is invalid or has expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/change-email": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Change the email address of the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Updates the authenticated user's email address to the new value provided.\r\n            The current password must be supplied for verification. After a successful change,\r\n            the user must re-authenticate with the new email address.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Changes the user's email address. The user must re-authenticate after the change.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or the authenticated user's email cannot be determined. Throws if the user account is disabled.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ChangeEmailRequestModel containing the current Password for verification and the NewEmail to set.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The email was successfully changed. The user must re-authenticate with the new email."
          },
          "400": {
            "description": "The request is null, the CognitoEmail claim is missing, or the user account is disabled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/change-password": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Change the password of the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Updates the authenticated user's password. The current password must be supplied\r\n            for verification along with the new password. The existing access token remains valid until expiration.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Updates the user's password. The existing token remains valid until expiration.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or the authenticated user's email cannot be determined. Throws if the user account is disabled or the current password is incorrect.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ChangePasswordRequestModel containing the current Password for verification and the NewPassword to set.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The password was successfully changed."
          },
          "400": {
            "description": "The request is null, the CognitoEmail claim is missing, the current password is incorrect, or the user is disabled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/forgot-password": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Trigger a password reset code to be sent to the user's email address.",
        "description": "\r\n<b>Behavior:</b> Initiates the password reset flow for the specified user account. If the account is active,\r\n            a 6-digit verification code is sent to the user's email address. The code should then be submitted to the\r\n            reset-password endpoint along with the new password. If the account requires email verification first,\r\n            the response LoginStatus will indicate this.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Sends a password reset email with a 6-digit verification code to the user.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. The response LoginStatus indicates\r\n            IsPendingEmailConfirmation (4) if the account needs email verification first, IsPendingNewAccountSignup (5) if the account\r\n            is not fully registered, or IsDisabled if the account is disabled.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ForgotPasswordRequestModel containing the UserName (email address) of the account.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The password reset code was sent, or the response indicates a pending account state that must be resolved first.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null or UserName is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/register": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Register a new user account with a unique email address.",
        "description": "\r\n<b>Behavior:</b> Creates a new user account with the specified email, name, and password. The email must be unique.\r\n            Depending on the tenant configuration, the account may be auto-approved (Normal status) or require admin approval\r\n            (PendingApproval status). A verification email is sent to the user to confirm their email address.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Creates a new user account. Sends a verification email to the user.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or Email is empty. Throws if a user with the same email already exists.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.UserRegistrationRequestModel containing Email, FirstName, LastName, Password, and optional custom Properties.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The account was successfully created. The user must verify their email before logging in.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, Email is empty, or a user with this email already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/register-guest": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Complete registration for a guest user who was invited via the invite-user endpoint.",
        "description": "\r\n<b>Behavior:</b> Completes the registration process for a user who received a guest invitation.\r\n            The user must have a pending invitation that has not expired. Sets the user's password, verifies their\r\n            email address, and activates their account so they can log in.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required. The invitation itself serves as authorization.\r\n\r\n<b>Side Effects:</b> Activates the guest user account and marks their email as verified.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null. Throws if the user does not exist, is not in PendingInvitation status,\r\n            the invitation has expired, no security records exist, or no guest profile is configured.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.UserRegistrationRequestModel containing Email, Password, FirstName, and LastName for the guest user.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The guest account was successfully activated. The user can now log in.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, the user is not in PendingInvitation status, the invitation has expired, or guest profile is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/resend-code": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Re-send the email verification confirmation code to the user.",
        "description": "\r\n<b>Behavior:</b> Re-sends the email verification confirmation code to the specified user's email address.\r\n            Use this when the original verification email was not received or the code has expired.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Sends a verification email to the user with a new confirmation code.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. Throws if the user does not exist.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ResendConfirmationCodeRequestModel containing the UserName (email address) to re-send the code to.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The confirmation code was re-sent to the user's email address."
          },
          "400": {
            "description": "The request is null or UserName is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/reset-password": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Reset the user's password using a verification code from the forgot-password email.",
        "description": "\r\n<b>Behavior:</b> Completes the password reset flow by validating the verification code from the forgot-password email\r\n            and setting the new password. For accounts pending approval, this also completes the email verification step.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required. The reset token serves as the credential.\r\n\r\n<b>Side Effects:</b> Updates the user's password. For pending-approval accounts, also verifies the email address.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. Throws if the user is disabled or the reset token is invalid/expired.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ResetPasswordRequestModel containing UserName (email), the Token from the reset email, and the NewPassword to set.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The password was successfully reset. The user can now log in with the new password."
          },
          "400": {
            "description": "The request is null, UserName is missing, the reset token is invalid or expired, or the user is disabled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/verify": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Verify a user's email address using a confirmation code.",
        "description": "\r\n<b>Behavior:</b> Confirms the user's email address using the verification code sent during registration.\r\n            If the account requires admin approval, the response LoginStatus will be IsDisabled to indicate the account\r\n            is verified but not yet approved for use.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Marks the user's email address as verified.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. Throws if the verification token is invalid or expired.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.VerifyEmailRequestModel containing the UserName (email) and the Token from the verification email.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The email was verified. Check LoginStatus — null means active, IsDisabled means pending approval.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, UserName is missing, or the verification token is invalid/expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/ads/vmap/{assetId}": {
      "get": {
        "tags": [
          "Ad"
        ],
        "summary": "Retrieves the VMAP (Video Multiple Ad Playlist) XML for an asset.",
        "description": "\r\n<b>Behavior:</b> Generates and returns the VMAP XML document that defines all ad break\r\n            positions and their associated VAST ad tag URLs for the specified asset. Video players use\r\n            this to schedule ad insertions during playback.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no VMAP data exists for the asset.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve VMAP data for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The VMAP XML was generated successfully.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "404": {
            "description": "No VMAP data found for the asset.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/ads/vast": {
      "get": {
        "tags": [
          "Ad"
        ],
        "summary": "Retrieves a VAST (Video Ad Serving Template) XML response for ad playback.",
        "description": "\r\n<b>Behavior:</b> Returns a VAST XML document containing the ad creative details for playback\r\n            at the specified timecode position. The response can be filtered by content categories and\r\n            ad position type (pre-roll, mid-roll, post-roll).\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no VAST ad is available for the given parameters.",
        "parameters": [
          {
            "name": "timeCode",
            "in": "query",
            "description": "The timecode position in the video where the ad will be inserted.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "categories",
            "in": "query",
            "description": "Optional content category filters for ad targeting.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "vpos",
            "in": "query",
            "description": "The ad position type (e.g., \"preroll\", \"midroll\", \"postroll\").",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The VAST XML was generated successfully.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "404": {
            "description": "No VAST ad available for the given parameters.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/ads/impression": {
      "get": {
        "tags": [
          "Ad"
        ],
        "summary": "Records an ad impression tracking beacon.",
        "description": "\r\n<b>Behavior:</b> Accepts an impression beacon request triggered when an ad is displayed\r\n            to a viewer. Returns a minimal HTML response suitable for use as a tracking pixel.\r\n            Currently acts as a placeholder for future impression analytics.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None currently. Reserved for future impression tracking analytics.\r\n\r\n<b>Error Scenarios:</b> None — always returns a successful response.",
        "parameters": [
          {
            "name": "assetId",
            "in": "query",
            "description": "The unique identifier of the ad asset that was displayed.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The impression was recorded.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          }
        }
      },
      "head": {
        "tags": [
          "Ad"
        ],
        "summary": "Records an ad impression tracking beacon.",
        "description": "\r\n<b>Behavior:</b> Accepts an impression beacon request triggered when an ad is displayed\r\n            to a viewer. Returns a minimal HTML response suitable for use as a tracking pixel.\r\n            Currently acts as a placeholder for future impression analytics.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None currently. Reserved for future impression tracking analytics.\r\n\r\n<b>Error Scenarios:</b> None — always returns a successful response.",
        "parameters": [
          {
            "name": "assetId",
            "in": "query",
            "description": "The unique identifier of the ad asset that was displayed.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The impression was recorded.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          }
        }
      }
    },
    "/asset/{id}/subtitle/{relatedAssetId}/export": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Exports subtitles for an asset in the specified format (DOCX, SRT, VTT, or TXT).",
        "description": "\r\n<b>Behavior:</b> Converts the transcription data for the specified related asset (subtitle track)\r\n            into the requested export format and returns the file as a downloadable binary response.\r\n            Supported formats: DOCX (Word document), SRT (SubRip), VTT (WebVTT), and TXT (plain text).\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 204 if the export format is invalid.\r\n            Returns 400 if the subtitle data is empty or the asset needs reprocessing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "relatedAssetId",
            "in": "path",
            "description": "The unique identifier of the subtitle-related asset to export.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The export options including the desired output format.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The subtitle file was exported successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "204": {
            "description": "The export format is not supported."
          },
          "400": {
            "description": "The subtitle data is empty or the asset needs reprocessing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/clip": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a clip (sub-segment) from a video asset.",
        "description": "\r\n<b>Behavior:</b> Extracts a segment from the specified video asset based on the provided\r\n            timecode range. The clip is created as a new related asset linked to the original.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new clip asset is created asynchronously.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the video asset to clip.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The clip parameters including start and end timecodes.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The clip operation was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/build-media": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Renders a media builder composition into a final output file.",
        "description": "\r\n<b>Behavior:</b> Submits a media builder render job that combines multiple assets, overlays,\r\n            and effects into a single output media file. The rendering occurs asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A media rendering job is created and processed asynchronously.\r\n            The resulting output file will be created as a new asset upon completion.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the input model is null.",
        "requestBody": {
          "description": "The media builder render configuration including source assets and output settings.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media render job was submitted successfully."
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The input model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/set-cookies/{id}": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves secure streaming cookies for an asset's related media.",
        "description": "\r\n<b>Behavior:</b> Generates signed cookies required for secure streaming of a related asset\r\n            (e.g., proxy video, preview). The response includes cookies both in the response headers\r\n            (for browser-based playback) and in the response body (for programmatic access).\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Signed streaming cookies are set in the HTTP response headers.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset or related asset is not found.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the related asset to generate streaming cookies for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The streaming cookies were generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseCookieWrapper"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset or related asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/detail": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the full detail model for an asset, including all media properties and related assets.",
        "description": "\r\n<b>Behavior:</b> Returns comprehensive asset details including media properties (dimensions,\r\n            duration, codec), URLs for streaming and preview, related assets (proxies, thumbnails, subtitles),\r\n            AI-generated metadata, and processing status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve details for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset details were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetDetailModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/restore": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Restores an archived asset back to active storage.",
        "description": "\r\n<b>Behavior:</b> Initiates restoration of a previously archived asset, making it accessible\r\n            for streaming and download again. The restore process may take time depending on the archive\r\n            storage tier.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset is queued for restoration from archival storage.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the archived asset to restore.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset restoration was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/local-restore": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Restores multiple assets from archive using specified restore profiles.",
        "description": "\r\n<b>Behavior:</b> Initiates a batch restore operation for multiple archived assets using the\r\n            specified restore profile names. Assets are queued for restoration asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The specified assets are queued for restoration from archival storage.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The restore parameters including source asset IDs and restore profile names.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The batch restore was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/localRestore": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Restores a single asset from archive using specified restore profiles.",
        "description": "\r\n<b>Behavior:</b> Initiates a restore operation for the specified archived asset using the\r\n            given restore profile names. The asset is queued for restoration asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset is queued for restoration from archival storage.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the archived asset to restore.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The restore parameters including restore profile names.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The restore was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/annotation": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a new annotation on an asset.",
        "description": "\r\n<b>Behavior:</b> Adds a new annotation (marker, comment, or note) to the specified asset.\r\n            Annotations can include timecodes for video assets, spatial coordinates for images,\r\n            and descriptive text. The created annotation is returned with its generated ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new annotation record is created for the asset.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to annotate.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The annotation details including text, timecode, and position.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The annotation was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotationModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves all annotations for an asset.",
        "description": "\r\n<b>Behavior:</b> Returns all annotations associated with the specified asset, including\r\n            timecodes, positions, and descriptive text. The caller must have access permissions on the asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token with access permissions on the asset.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the caller does not have permission on the asset.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve annotations for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The annotations were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AnnotationModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The caller does not have permission on the asset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/share": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a shareable link for an asset.",
        "description": "\r\n<b>Behavior:</b> Generates a shareable URL for the specified asset based on the sharing\r\n            configuration provided. Options include expiration time, password protection, and access permissions.\r\n            The generated link can be distributed to external recipients.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A share record is created. Depending on configuration, notification emails\r\n            may be sent to specified recipients.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to share.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The sharing configuration including recipients, expiration, and permissions.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The share link was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/generate-image": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Generates an AI image for an asset using a text prompt.",
        "description": "\r\n<b>Behavior:</b> Uses AI image generation to create a new image based on the provided text prompt.\r\n            The generated image is saved as a new asset. A prompt is required in the request body.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new image asset is created from the AI-generated content.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the prompt is empty or the request body is missing.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the input model is null.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset context for the image generation.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The image generation parameters including the text prompt.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The image was generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateImageModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "The prompt is empty or the request body is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The input model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/annotation/import": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Bulk imports multiple annotations for an asset in a single request.",
        "description": "\r\n<b>Behavior:</b> Creates multiple annotations on the specified asset at once. Each annotation\r\n            in the list is created individually. All annotations are associated with the specified asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Multiple annotation records are created for the asset.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to import annotations for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The list of annotations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The annotations were imported successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AnnotationModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/annotation/{annonationId}": {
      "delete": {
        "tags": [
          "Asset"
        ],
        "summary": "Deletes an annotation from an asset.",
        "description": "\r\n<b>Behavior:</b> Permanently removes the specified annotation from the asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The annotation is permanently deleted.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "annonationId",
            "in": "path",
            "description": "The unique identifier of the annotation to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "assetId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The annotation was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates an existing annotation on an asset.",
        "description": "\r\n<b>Behavior:</b> Updates the specified annotation's properties including text, timecode,\r\n            and position. The annotation must exist for the specified asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The annotation record is updated.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the annotation is not found.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the annotation.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "annonationId",
            "in": "path",
            "description": "The unique identifier of the annotation to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The updated annotation details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The annotation was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotationModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The annotation was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/related-asset/{relatedAssetId}": {
      "delete": {
        "tags": [
          "Asset"
        ],
        "summary": "Deletes a related asset from a parent asset.",
        "description": "\r\n<b>Behavior:</b> Removes the association between the parent asset and the specified related asset\r\n            (e.g., proxy video, subtitle file, thumbnail). The related asset is permanently deleted.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The related asset is permanently deleted and disassociated from the parent.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "relatedAssetId",
            "in": "path",
            "description": "The unique identifier of the related asset to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The related asset was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/transcript/{transcriptId}": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates the transcription content for an asset.",
        "description": "\r\n<b>Behavior:</b> Replaces or updates specific segments of the transcription associated with\r\n            the specified asset and transcript ID. Use this to correct auto-generated transcription text\r\n            or adjust word timings.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The transcription data is updated and re-indexed.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the transcription.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "transcriptId",
            "in": "path",
            "description": "The unique identifier of the transcription to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The list of transcription updates to apply.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The transcription was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/tracking": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Records a video or ad tracking beacon event.",
        "description": "\r\n<b>Behavior:</b> Records a playback tracking event (e.g., play, pause, quartile, complete) for\r\n            analytics and reporting. Supports both asset-level and live channel tracking. Responds with\r\n            an HTML \"OK\" suitable for use as a tracking pixel/beacon endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A tracking record is created for analytics purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            No tracking is recorded if neither assetId nor livechannelId is provided.",
        "parameters": [
          {
            "name": "trackingEvent",
            "in": "query",
            "description": "The type of tracking event (e.g., play, pause, complete).\n\nProgress\n\nFirstQuartile\n\nMidpoint\n\nThirdQuartile\n\nComplete\n\nHide\n\nLiveStream",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/VideoTrackingEvents"
                }
              ],
              "x-enumNames": [
                "Progress",
                "FirstQuartile",
                "Midpoint",
                "ThirdQuartile",
                "Complete",
                "Hide",
                "LiveStream"
              ]
            },
            "x-enumNames": [
              "Progress",
              "FirstQuartile",
              "Midpoint",
              "ThirdQuartile",
              "Complete",
              "Hide",
              "LiveStream"
            ]
          },
          {
            "name": "assetId",
            "in": "query",
            "description": "The ID of the asset being tracked. Required if not tracking a live channel.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "livechannelId",
            "in": "query",
            "description": "The ID of the live channel being tracked. Required if not tracking an asset.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "query",
            "description": "Optional content ID to associate with the tracking event.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "second",
            "in": "query",
            "description": "The second mark into the video or ad when the event occurred.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "profileId",
            "in": "query",
            "description": "Optional profile ID to associate the tracking data with a specific viewer.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tracking event was recorded successfully.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "head": {
        "tags": [
          "Asset"
        ],
        "summary": "Records a video or ad tracking beacon event.",
        "description": "\r\n<b>Behavior:</b> Records a playback tracking event (e.g., play, pause, quartile, complete) for\r\n            analytics and reporting. Supports both asset-level and live channel tracking. Responds with\r\n            an HTML \"OK\" suitable for use as a tracking pixel/beacon endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A tracking record is created for analytics purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            No tracking is recorded if neither assetId nor livechannelId is provided.",
        "parameters": [
          {
            "name": "trackingEvent",
            "in": "query",
            "description": "The type of tracking event (e.g., play, pause, complete).\n\nProgress\n\nFirstQuartile\n\nMidpoint\n\nThirdQuartile\n\nComplete\n\nHide\n\nLiveStream",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/VideoTrackingEvents"
                }
              ],
              "x-enumNames": [
                "Progress",
                "FirstQuartile",
                "Midpoint",
                "ThirdQuartile",
                "Complete",
                "Hide",
                "LiveStream"
              ]
            },
            "x-enumNames": [
              "Progress",
              "FirstQuartile",
              "Midpoint",
              "ThirdQuartile",
              "Complete",
              "Hide",
              "LiveStream"
            ]
          },
          {
            "name": "assetId",
            "in": "query",
            "description": "The ID of the asset being tracked. Required if not tracking a live channel.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "livechannelId",
            "in": "query",
            "description": "The ID of the live channel being tracked. Required if not tracking an asset.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "query",
            "description": "Optional content ID to associate with the tracking event.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "second",
            "in": "query",
            "description": "The second mark into the video or ad when the event occurred.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "profileId",
            "in": "query",
            "description": "Optional profile ID to associate the tracking data with a specific viewer.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tracking event was recorded successfully.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/download-archive": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a downloadable ZIP archive containing multiple assets.",
        "description": "\r\n<b>Behavior:</b> Packages the specified assets into a single ZIP archive for download.\r\n            You can optionally specify a custom filename and a download proxy URL. The request must include\r\n            at least one asset ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A ZIP archive is created asynchronously.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or contains no asset IDs.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the request model is null or invalid.",
        "requestBody": {
          "description": "The download request containing asset IDs, optional filename, and download proxy settings.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The archive creation was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or contains no asset IDs.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The request model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}": {
      "patch": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates specific properties of an asset such as its display name or custom metadata.",
        "description": "\r\n<b>Behavior:</b> Updates the specified properties on the asset without affecting other\r\n            attributes. Use this for lightweight property changes. For more complex operations (e.g., clipping,\r\n            language change, archiving), use the dedicated endpoints.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset's search index entry is updated with the new properties.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The properties to update on the asset.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The asset properties were updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/assign-person/{faceId}/{personId}": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Associates a detected face in an asset with a known person.",
        "description": "\r\n<b>Behavior:</b> Links the specified detected face (identified by its external face ID) to\r\n            a person record. This is used to confirm or assign facial recognition matches, updating the\r\n            face's match status from probable to confirmed.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The face record is updated with the person association.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the detected face.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "faceId",
            "in": "path",
            "description": "The external face identifier from the facial recognition analysis.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "personId",
            "in": "path",
            "description": "The unique identifier of the person to associate with the face.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The person was assigned to the face successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/remove-person/{faceId}": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Removes the person association from a detected face in an asset.",
        "description": "\r\n<b>Behavior:</b> Removes the link between a detected face and its assigned person. The face\r\n            detection data is retained, but it will no longer be associated with a specific person record.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The face record's person association is removed.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the detected face.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "faceId",
            "in": "path",
            "description": "The external face identifier to remove the person association from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The person association was removed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset-queue": {
      "post": {
        "tags": [
          "AssetQueue"
        ],
        "summary": "Adds assets to the download queue for batch downloading.",
        "description": "\r\n<b>Behavior:</b> Adds the specified assets to the user's download queue. Queued assets can be\r\n            processed for bulk download at a later time. This is useful for collecting multiple assets\r\n            before initiating a single download operation.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> New entries are created in the download queue.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The assets to add to the download queue.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The items were added to the download queue."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "patch": {
        "tags": [
          "AssetQueue"
        ],
        "summary": "Updates the properties of a download queue item.",
        "description": "\r\n<b>Behavior:</b> Updates an existing entry in the download queue, such as changing its\r\n            priority or status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The download queue entry is updated.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The updated download queue item properties.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The queue item was updated."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "AssetQueue"
        ],
        "summary": "Removes entries from the download queue.",
        "description": "\r\n<b>Behavior:</b> Deletes the specified entries from the download queue. The entries are\r\n            identified by their unique download queue IDs.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The specified queue entries are permanently removed.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The list of download queue entry IDs to delete.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The queue entries were deleted."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/start": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Initiates a new multipart upload for a single asset.",
        "description": "\r\n<b>Behavior:</b> Prepares a new asset upload by creating the upload record and generating\r\n            pre-signed URLs for each upload part. The client should upload each part directly to the provided\r\n            URLs, then call the complete endpoint when all parts are uploaded. The file is split into parts\r\n            based on the total file size.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> An upload record is created. Pre-signed upload URLs are generated\r\n            with limited validity.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The upload parameters including file name, size, parent folder, and MIME type.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The upload was initiated and part URLs were generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetUploadModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/start-related-asset": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Initiates a new multipart upload for a related asset (e.g., subtitle, proxy, thumbnail).",
        "description": "\r\n<b>Behavior:</b> Prepares an upload for a file that will be associated with an existing parent\r\n            asset as a related asset. Generates pre-signed URLs for each upload part. Use this for uploading\r\n            supplementary files such as subtitle tracks, proxy videos, or custom thumbnails.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> An upload record is created. Pre-signed upload URLs are generated.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The upload parameters including parent asset ID, file name, size, and relationship type.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The related asset upload was initiated and part URLs were generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetUploadModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/{id}/complete": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Completes a multipart upload after all parts have been transferred.",
        "description": "\r\n<b>Behavior:</b> Finalizes the multipart upload by combining all uploaded parts into the\r\n            final asset file. This triggers post-upload processing including media analysis, transcoding,\r\n            AI detection, and search indexing. Call this only after all parts have been uploaded and\r\n            confirmed via the complete-part endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The uploaded parts are assembled into the final file. Asynchronous\r\n            processing jobs (transcoding, AI analysis, indexing) are triggered.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the asset upload to complete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upload was completed and processing was initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/{id}/cancel": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Cancels an in-progress upload and deletes all uploaded parts.",
        "description": "\r\n<b>Behavior:</b> Aborts the multipart upload and cleans up all partially uploaded data.\r\n            An optional message can be provided to record the reason for cancellation.\r\n            Use this to abandon an upload that will not be completed.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> All uploaded parts are deleted from storage. The upload record\r\n            is marked as cancelled.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the asset upload to cancel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "message",
            "in": "query",
            "description": "Optional reason for cancelling the upload.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upload was cancelled and partial data was cleaned up."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/part/{id}/complete": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Confirms that an individual upload part was transferred successfully.",
        "description": "\r\n<b>Behavior:</b> Records that the specified upload part has been successfully uploaded to the\r\n            pre-signed URL. The ETag returned by the storage service after uploading the part data must be\r\n            provided to verify integrity. Call this for each part after uploading it, before calling\r\n            the complete-upload endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The part is marked as completed in the upload record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the ETag is missing or the request body is invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the upload part to mark as complete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The completion details including the ETag from the storage upload response.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The upload part was confirmed successfully."
          },
          "400": {
            "description": "The ETag is missing or the request body is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/cojudicial/streams": {
      "get": {
        "tags": [
          "CoJudicial"
        ],
        "summary": "Retrieves the list of counties and their associated live streams.",
        "description": "\r\n<b>Behavior:</b> Performs two search index queries: one to retrieve all county records and another\r\n            to retrieve all enabled live streams. Counties are returned as lookup models with their IDs and descriptions.\r\n            Live streams are returned as asset reference models enriched with description, short description, associated\r\n            county IDs, live channel status, status name, and output video URL. Disabled streams are excluded from results.\r\n\r\n<b>Authorization:</b> No authorization required. This is a publicly accessible endpoint.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> If no counties or streams are found, the response returns an empty\r\n            Nomad.Api.Portal.CoJudicial.Models.StreamsModel with empty county and stream lists. If the search service encounters an error,\r\n            the exception propagates to the caller.",
        "responses": {
          "200": {
            "description": "Returns the streams model containing counties and live streams.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StreamsModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/comment/{contentId}": {
      "get": {
        "tags": [
          "Comment"
        ],
        "summary": "Retrieves all comments associated with a specific content item.",
        "description": "\r\n<b>Behavior:</b> Returns a list of all comments for the specified content ID. If the content ID has no comments, an empty list is returned.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the contentId is not a valid GUID. Returns 404 if the content item is not found.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item to retrieve comments for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The comments were successfully retrieved.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid (e.g., malformed content ID).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content item was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "Comment"
        ],
        "summary": "Creates a new comment on a specific content item.",
        "description": "\r\n<b>Behavior:</b> Creates a new comment record associated with the specified content ID. The contentId from the route is assigned to the input model before saving.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> A new comment record is persisted in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item to create the comment for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The comment model containing the comment details to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The comment was successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentCommentModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/comment/{commentId}": {
      "put": {
        "tags": [
          "Comment"
        ],
        "summary": "Updates an existing comment.",
        "description": "\r\n<b>Behavior:</b> Updates the comment identified by the specified comment ID with the provided model data. The commentId from the route is assigned to the input model before saving.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The existing comment record is updated in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Returns 404 if the comment with the specified ID does not exist.",
        "parameters": [
          {
            "name": "commentId",
            "in": "path",
            "description": "The unique identifier of the comment to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The comment model containing the updated comment details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentCommentModel"
                  }
                ],
                "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The comment was successfully updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentCommentModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The comment with the specified ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Comment"
        ],
        "summary": "Deletes a specific comment by its identifier.",
        "description": "\r\n<b>Behavior:</b> Verifies the comment exists, then permanently deletes it from the data store. Returns the ID of the deleted comment.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The comment record is permanently removed from the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the comment with the specified ID does not exist. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "commentId",
            "in": "path",
            "description": "The unique identifier of the comment to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The comment was successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The comment with the specified ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/tag": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Adds tag associations to content items in bulk.",
        "description": "\r\n<b>Behavior:</b> Associates the specified tags with each content item in the list.\r\n            If a tag does not already exist and the createNew flag is set on the model, the tag is created automatically.\r\n            Returns a batch result with per-item status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates tag-to-content associations. May create new tags if the createNew flag is set.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty.\r\n            Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of tag-content associations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The tag associations were processed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/tag/delete": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Removes tag associations from content items in bulk.",
        "description": "\r\n<b>Behavior:</b> Removes the specified tag associations from each content item in the list.\r\n            This does not delete the tags themselves, only the associations between tags and content items.\r\n            Returns a batch result with per-item status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes tag-to-content association records.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty.\r\n            Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of tag-content associations to remove.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The tag associations were removed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/related": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Creates related content associations in bulk.",
        "description": "\r\n<b>Behavior:</b> Creates \"related content\" links between content items as specified in the list.\r\n            Related content represents semantic relationships between items (e.g., \"see also\", \"part of series\").\r\n            Returns a batch result with per-item status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates related content association records.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty.\r\n            Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of related content associations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The related content associations were created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/related/delete": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Removes related content associations in bulk.",
        "description": "\r\n<b>Behavior:</b> Removes the specified \"related content\" links between content items.\r\n            This does not delete the content items themselves, only the relationship associations.\r\n            Returns a batch result with per-item status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes related content association records.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty.\r\n            Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of related content associations to remove.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The related content associations were removed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/collection": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Adds collection associations to content items in bulk.",
        "description": "\r\n<b>Behavior:</b> Associates the specified collections with each content item in the list.\r\n            If a collection does not already exist and the createNew flag is set on the model,\r\n            the collection is created automatically. Returns a batch result with per-item status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates collection-to-content associations. May create new collections if the createNew flag is set.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty.\r\n            Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of collection-content associations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The collection associations were processed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/collection/delete": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Removes collection associations from content items in bulk.",
        "description": "\r\n<b>Behavior:</b> Removes the specified collection associations from each content item in the list.\r\n            This does not delete the collections themselves, only the associations between collections and content items.\r\n            Returns a batch result with per-item status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes collection-to-content association records.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty.\r\n            Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of collection-content associations to remove.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The collection associations were removed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition/{id}": {
      "get": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Retrieves a content definition by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Fetches the content definition schema for the given ID.\r\n            A security check is performed to verify the caller has permission to access this content definition.\r\n            Content definitions describe the structure and fields of a content type in the system.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token. The caller must also have permission\r\n            to access the requested content definition.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no content definition exists with the specified ID.\r\n            Returns 400 if the caller does not have permission to access the content definition.",
        "operationId": "GetContentDefinition",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content definition to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The content definition was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentDefinitionModel"
                }
              }
            }
          },
          "400": {
            "description": "The caller does not have permission to access this content definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No content definition found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentgroup": {
      "get": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Retrieves all content groups belonging to the current user.",
        "description": "\r\n<b>Behavior:</b> Returns all content groups created by or shared with the currently authenticated user.\r\n            Content groups are user-defined collections used to organize and curate content items.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The content groups were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ContentGroupModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Creates a new content group.",
        "description": "\r\n<b>Behavior:</b> Creates a new content group with the specified name and configuration.\r\n            Returns the fully populated content group after creation.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a new content group record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the model is null.",
        "requestBody": {
          "description": "The content group creation model containing the name and configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupAddModel"
                  }
                ],
                "description": "Model for creating a new content group."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupAddModel"
                  }
                ],
                "description": "Model for creating a new content group."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupAddModel"
                  }
                ],
                "description": "Model for creating a new content group."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupAddModel"
                  }
                ],
                "description": "Model for creating a new content group."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupAddModel"
                  }
                ],
                "description": "Model for creating a new content group."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupAddModel"
                  }
                ],
                "description": "Model for creating a new content group."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupAddModel"
                  }
                ],
                "description": "Model for creating a new content group."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The content group was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentGroupModel"
                }
              }
            }
          },
          "400": {
            "description": "The model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentgroup/{contentGroupId}": {
      "get": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Retrieves a content group by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the content group with the specified ID, including its member content items.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no content group exists with the specified ID.",
        "parameters": [
          {
            "name": "contentGroupId",
            "in": "path",
            "description": "The unique identifier of the content group to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The content group was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentGroupModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No content group found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "patch": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Renames an existing content group.",
        "description": "\r\n<b>Behavior:</b> Updates the display name of the content group identified by ID.\r\n            Returns the updated content group after the rename.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Modifies the content group name.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the rename model is null.",
        "parameters": [
          {
            "name": "contentGroupId",
            "in": "path",
            "description": "The unique identifier of the content group to rename.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The rename model containing the new name.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupRenameModel"
                  }
                ],
                "description": "Model for renaming a content group."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupRenameModel"
                  }
                ],
                "description": "Model for renaming a content group."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupRenameModel"
                  }
                ],
                "description": "Model for renaming a content group."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupRenameModel"
                  }
                ],
                "description": "Model for renaming a content group."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupRenameModel"
                  }
                ],
                "description": "Model for renaming a content group."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupRenameModel"
                  }
                ],
                "description": "Model for renaming a content group."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentGroupRenameModel"
                  }
                ],
                "description": "Model for renaming a content group."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The content group was renamed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentGroupModel"
                }
              }
            }
          },
          "400": {
            "description": "The rename model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Deletes a content group by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently removes the content group and all its associations.\r\n            The content items within the group are not deleted.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes the content group and its membership records.",
        "parameters": [
          {
            "name": "contentGroupId",
            "in": "path",
            "description": "The unique identifier of the content group to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The content group was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentgroup/add/{contentGroupId}": {
      "post": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Adds content items to a content group.",
        "description": "\r\n<b>Behavior:</b> Associates the specified content items with the content group.\r\n            Items already in the group are not duplicated. Returns the updated content group.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates content-to-group association records.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the content IDs array is null.",
        "parameters": [
          {
            "name": "contentGroupId",
            "in": "path",
            "description": "The unique identifier of the content group to add items to.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "An array of content item IDs to add to the group.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The content items were added to the group successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentGroupModel"
                }
              }
            }
          },
          "400": {
            "description": "The content IDs array is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentgroup/remove/{contentGroupId}": {
      "post": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Removes content items from a content group.",
        "description": "\r\n<b>Behavior:</b> Removes the specified content items from the content group.\r\n            The content items themselves are not deleted, only their association with the group.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes content-to-group association records.",
        "parameters": [
          {
            "name": "contentGroupId",
            "in": "path",
            "description": "The unique identifier of the content group to remove items from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "An array of content item IDs to remove from the group.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The content items were removed from the group successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentgroup/share/{contentGroupId}": {
      "post": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Shares a content group with other users.",
        "description": "\r\n<b>Behavior:</b> Grants the specified users access to view the content group.\r\n            Shared users can see the group and its contents in their content group list.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates sharing records for each specified user.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the user IDs array is null.",
        "parameters": [
          {
            "name": "contentGroupId",
            "in": "path",
            "description": "The unique identifier of the content group to share.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "An array of user IDs to share the content group with.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The content group was shared successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The user IDs array is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentgroup/stopshare/{contentGroupId}": {
      "post": {
        "tags": [
          "ContentGroup"
        ],
        "summary": "Stops sharing a content group with the specified users.",
        "description": "\r\n<b>Behavior:</b> Revokes access to the content group for the specified users.\r\n            Those users will no longer see the group in their content group list.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes sharing records for each specified user.",
        "parameters": [
          {
            "name": "contentGroupId",
            "in": "path",
            "description": "The unique identifier of the content group to stop sharing.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "An array of user IDs to revoke sharing from.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Sharing was revoked successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/eluvio/token": {
      "post": {
        "tags": [
          "Eluvio"
        ],
        "summary": "Gets a signed Eluvio security token using the specified mezzanine object ID.",
        "description": "\r\n<b>Behavior:</b> Generates and returns a signed Eluvio security token for the specified mezzanine object, enabling secure content access on the Eluvio Content Fabric.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 Not Found if the token could not be generated for the given request. Returns 401 Unauthorized if the caller is not authenticated.",
        "requestBody": {
          "description": "The Eluvio token request containing the mezzanine object ID.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The signed Eluvio security token was generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EluvioTokenResponseModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The token could not be generated for the specified object.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/embedded/iframe-media": {
      "get": {
        "tags": [
          "Embedded"
        ],
        "summary": "Retrieves an embedded iframe video player for a given asset.",
        "description": "\r\n<b>Behavior:</b> Generates an HTML iframe representation of the specified media asset. If the asset\r\n            is not found or an error occurs during retrieval, an HTML error page is returned instead of throwing an exception.\r\n\r\n<b>Authorization:</b> No authorization required. This is a publicly accessible endpoint for embedded content.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> If the asset ID is empty or null, a validation exception is thrown.\r\n            If the asset cannot be found, a not-found exception is thrown. Any other errors are caught and an HTML error\r\n            page is returned with the error message.",
        "parameters": [
          {
            "name": "assetId",
            "in": "query",
            "description": "The unique identifier of the asset to embed.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "width",
            "in": "query",
            "description": "The width of the iframe player in pixels. Defaults to 711 if not specified.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "height",
            "in": "query",
            "description": "The height of the iframe player in pixels. Defaults to 400 if not specified.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "autoplay",
            "in": "query",
            "description": "Whether the media should autoplay when loaded. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the HTML iframe content for the embedded media player.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseHtmlWrapper"
                }
              }
            }
          },
          "404": {
            "description": "The specified asset could not be found.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/embedded/media/{id}": {
      "get": {
        "tags": [
          "Embedded"
        ],
        "summary": "Retrieves an embedded media model for a given asset, share, or live channel.",
        "description": "\r\n<b>Behavior:</b> Looks up the media by the provided ID, which can be a public asset ID, a share ID,\r\n            or a live channel ID. If the media is found, returns a JSON model. If an error occurs, falls back to returning\r\n            an HTML error page as a ContentResult.\r\n\r\n<b>Authorization:</b> No authorization required. This is a publicly accessible endpoint for embedded content.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> If the ID is empty or null, a validation exception is thrown. If the media\r\n            cannot be found, a not-found exception is thrown. Any other errors result in an HTML error page being returned\r\n            with content type text/html.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The public asset ID, share ID, or live channel ID to retrieve media for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "assetId",
            "in": "query",
            "description": "An optional asset ID within a share to retrieve a specific asset.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the embedded media model as JSON, or an HTML error page on failure.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmbeddedMediaModel"
                }
              }
            }
          },
          "404": {
            "description": "The specified media could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/embedded/share-media": {
      "get": {
        "tags": [
          "Embedded"
        ],
        "summary": "Generates a server-side HTML page with social media metadata tags for sharing media.",
        "description": "\r\n<b>Behavior:</b> Produces a full HTML page with dynamically injected Open Graph and social media\r\n            metadata tags suitable for link previews. The asset can be identified either by a direct asset ID or by\r\n            a stream URL. When a stream URL is provided without an ID, the asset is looked up by its path in the\r\n            content bucket. When an ID is provided, it is validated as a share and checked for expiration before\r\n            rendering. Autoplay can be specified as \"true\", \"false\", \"1\", or \"0\".\r\n\r\n<b>Authorization:</b> No authorization required. This is a publicly accessible endpoint for shared and embedded content.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> If a share ID is provided but the share is unavailable or expired, an HTML\r\n            error page is returned. If neither a valid ID nor a resolvable stream URL is provided, an HTML error page\r\n            indicating the media or share could not be found is returned. Any unexpected errors during rendering also\r\n            produce an HTML error page.",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "The asset ID or share ID. Optional if streamUrl is provided.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "width",
            "in": "query",
            "description": "The width of the embedded player in pixels. Defaults to 711 if not specified.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "height",
            "in": "query",
            "description": "The height of the embedded player in pixels. Defaults to 400 if not specified.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "streamUrl",
            "in": "query",
            "description": "The full URL path to the asset stream. Must be URL-encoded. Optional if id is provided.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "autoplay",
            "in": "query",
            "description": "Whether the media should autoplay. Accepts \"true\", \"false\", \"1\", or \"0\". Defaults to \"true\".",
            "schema": {
              "type": "string",
              "default": "true"
            }
          },
          {
            "name": "title",
            "in": "query",
            "description": "An optional title for the shared video, used in metadata tags.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns an HTML page with embedded media and social metadata tags, or an HTML error page.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "404": {
            "description": "The specified asset or share could not be found.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/embedded/share/{shareId}": {
      "get": {
        "tags": [
          "Embedded"
        ],
        "summary": "Retrieves the shared asset list view for an embedded share player.",
        "description": "\r\n<b>Behavior:</b> Validates the share exists and has not expired, then searches for all file-type\r\n            assets belonging to the share. Results include preview URLs and, conditionally, download URLs (if the share\r\n            has download permissions and contains fewer than 500 items). Results are sorted by path depth (shallowest first)\r\n            and then alphabetically by display path. Share metadata (name, expiration, permissions, type, status) is\r\n            included in the related items of the response.\r\n\r\n<b>Authorization:</b> No authorization required. Access is controlled through share validation\r\n            (existence and expiration checks).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> If the share is unavailable, expired, or does not exist, a VibrantException\r\n            with a NotFound status code is thrown.",
        "parameters": [
          {
            "name": "shareId",
            "in": "path",
            "description": "The unique identifier of the share to retrieve assets for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the list of shared assets with metadata.",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The share was not found or has expired.",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "text/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/liveChannel/new": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a pre-filled template for creating a new live channel.",
        "description": "\r\n<b>Behavior:</b> Returns a pre-populated Nomad.Common.Models.Live.LiveChannelNewModel with default values\r\n            that can be modified and submitted to the create endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the template cannot be generated.",
        "responses": {
          "200": {
            "description": "The template was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelNewModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The template could not be generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a new live channel and requests provisioning of the underlying system resource.",
        "description": "\r\n<b>Behavior:</b> Creates a new live channel record and initiates resource provisioning.\r\n            The channel is not available immediately; it will have a status of Nomad.Common.Enums.LiveChannelStatuses.Creating\r\n            until provisioning completes. Use the M:Nomad.Controller.Live.LiveChannelController.New endpoint to obtain a starter template.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a live channel record and initiates cloud resource provisioning.",
        "requestBody": {
          "description": "The live channel creation model with configuration details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The live channel was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves all live channels in the system.",
        "description": "\r\n<b>Behavior:</b> Returns the complete list of live channels regardless of their current status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The live channels were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveChannelModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Updates an existing live channel configuration.",
        "description": "\r\n<b>Behavior:</b> Applies the changes from the edit model to the live channel.\r\n            Note that underlying cloud resources may not be updated immediately even though the\r\n            channel record reflects the changes.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the live channel record and may trigger cloud resource updates.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the edit model is null.",
        "requestBody": {
          "description": "The edit model containing the updated channel configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The live channel was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModel"
                }
              }
            }
          },
          "400": {
            "description": "The edit model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a specific live channel by its identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the full live channel model for the specified channel ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live channel was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Deletes a live channel and its associated cloud resource.",
        "description": "\r\n<b>Behavior:</b> Deletes the live channel record and requests deprovisioning of the underlying\r\n            cloud resource. The resource may not be deleted immediately, and the channel record may remain\r\n            temporarily accessible. The operation will fail if other resources (such as schedule events)\r\n            still reference this channel.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes the live channel record and initiates cloud resource deprovisioning.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live channel was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModelLiveResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/clip": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a clip from a live channel stream.",
        "description": "\r\n<b>Behavior:</b> Initiates a clip operation on the specified live channel using the provided\r\n            clip parameters (e.g., start time, duration). The clip is processed asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Initiates a clip extraction from the live stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to clip from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The clip parameters specifying the segment to extract.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The clip request was accepted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/clipsnapshot": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a snapshot clip from a live channel stream.",
        "description": "\r\n<b>Behavior:</b> Captures a snapshot clip from the specified live channel at the current\r\n            playback position. Returns clip details including the generated asset information.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a snapshot clip asset from the live stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to snapshot.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The snapshot clip was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveClipResponseModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/set-cookies": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves signed cookies or tokens for secure live stream playback.",
        "description": "\r\n<b>Behavior:</b> Generates and sets signed cookies on the response for authenticated\r\n            access to the live stream CDN. If the stream uses token-based authentication instead,\r\n            returns the playback token. This enables third-party integrations to obtain secured\r\n            stream URLs per user.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Sets signed cookies on the HTTP response for CDN authentication.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the channel has no configured output stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The cookies or tokens were generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The channel has no configured output stream.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/properties": {
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Updates the custom properties map for a live channel.",
        "description": "\r\n<b>Behavior:</b> Replaces or merges the specified key-value pairs into the\r\n            live channel's properties dictionary.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the channel's custom properties in the data store.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "A dictionary of property key-value pairs to update.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            },
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            },
            "text/json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The properties were updated successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/startOutputTracking": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Starts output tracking for a live channel.",
        "description": "\r\n<b>Behavior:</b> Initiates output tracking for the specified live channel,\r\n            enabling monitoring of the channel's output streams and viewer metrics.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Enables output tracking for the channel.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Output tracking was started successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/start": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Starts a live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a start command to the live channel, beginning the live stream.\r\n            The channel must be in a valid state (e.g., idle or stopped) to be started.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Starts the live channel and begins streaming.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to start.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was started successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/pause": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Pauses a live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a pause command to the live channel, temporarily suspending\r\n            the live stream. The channel can be resumed later without restarting.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Pauses the live channel stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to pause.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was paused successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/resume": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Resumes a paused live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a resume command to a previously paused live channel,\r\n            continuing the live stream from where it was paused.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Resumes the live channel stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to resume.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was resumed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/stop": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Stops a live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a stop command to the live channel, ending the live stream.\r\n            The channel can be started again later.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Stops the live channel stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to stop.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was stopped successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/nextEvent": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Advances a live channel to its next scheduled event.",
        "description": "\r\n<b>Behavior:</b> Triggers a transition to the next event in the channel's schedule,\r\n            skipping any remaining time on the current event.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Advances the channel schedule to the next event.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel advanced to the next event successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/refresh": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Refreshes all live channels in the system.",
        "description": "\r\n<b>Behavior:</b> Synchronizes the state of all live channels with their\r\n            underlying cloud resources, updating status and configuration information.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the cached state of all live channels.",
        "responses": {
          "200": {
            "description": "All channels were refreshed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/refresh/{utcDateTimeTicks}": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Refreshes a specific live channel at a given point in time.",
        "description": "\r\n<b>Behavior:</b> Synchronizes the state of the specified live channel with its\r\n            underlying cloud resource. The UTC date-time ticks parameter allows specifying the\r\n            reference point for the refresh; if the value cannot be parsed, the current UTC time is used.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the cached state of the specified live channel.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to refresh.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "utcDateTimeTicks",
            "in": "path",
            "description": "The UTC date-time ticks value for the refresh reference point.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was refreshed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent/new": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a pre-filled template for creating a new schedule event on a live channel.",
        "description": "\r\n<b>Behavior:</b> Returns a pre-populated Nomad.Common.Models.Live.LiveScheduleEventNewModel with default\r\n            values for the specified channel, which can be modified and submitted to the create schedule event endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The template was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a new schedule event on a live channel.",
        "description": "\r\n<b>Behavior:</b> Adds a new event to the channel's schedule. The channel ID in the\r\n            request body must match the channel ID in the route.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a new schedule event and may affect the channel's playback schedule.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the channel ID in the body does not match the route.\r\n            Returns 404 if the new schedule event model is null.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The schedule event creation model.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule event was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The channel ID in the body does not match the route.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The schedule event model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves all schedule events for a live channel.",
        "description": "\r\n<b>Behavior:</b> Returns the complete list of schedule events associated with the specified live channel.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule events were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveScheduleEventModel"
                  },
                  "description": "Represents a paginated list of live resource models."
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Updates an existing schedule event on a live channel.",
        "description": "\r\n<b>Behavior:</b> Applies the changes from the edit model to the schedule event.\r\n            The channel ID in the request body must match the channel ID in the route.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the schedule event and may affect the channel's playback schedule.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the channel ID in the body does not match the route.\r\n            Returns 404 if the schedule event model is null or the update fails.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The edit model containing the updated schedule event configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule event was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventModel"
                }
              }
            }
          },
          "400": {
            "description": "The channel ID in the body does not match the route.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The schedule event was not found or the update failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent/{scheduleEventId}": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a specific schedule event from a live channel.",
        "description": "\r\n<b>Behavior:</b> Returns the schedule event model for the specified event within the given channel.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the schedule event does not exist.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "scheduleEventId",
            "in": "path",
            "description": "The unique identifier of the schedule event.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule event was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The schedule event was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Deletes a schedule event from a live channel.",
        "description": "\r\n<b>Behavior:</b> Removes the specified schedule event from the channel's schedule.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes the schedule event and may affect the channel's playback schedule.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "scheduleEventId",
            "in": "path",
            "description": "The unique identifier of the schedule event to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule event was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent/{scheduleEventId}/move": {
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Moves a schedule event to a new position within the channel's schedule.",
        "description": "\r\n<b>Behavior:</b> Repositions the specified schedule event within the channel's schedule order.\r\n            The event is moved to immediately after the event specified by the previous schedule event ID\r\n            in the move model. Returns the updated list of schedule events reflecting the new order.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Reorders the channel's schedule events.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "scheduleEventId",
            "in": "path",
            "description": "The unique identifier of the schedule event to move.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The move model specifying the target position.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule event was moved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveScheduleEventModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveInput/new": {
      "get": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Gets a pre-filled template for creating a new live input.",
        "description": "**Behavior:**\r\nReturns a pre-populated Nomad.Common.Models.Live.LiveInputNewModel object with default values\r\nthat can be customized and submitted to M:Nomad.Controller.Live.LiveInputController.Create(Nomad.Common.Models.Live.LiveInputNewModel) to provision a new live input.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.\r\n- Returns 404 if the template could not be generated.",
        "responses": {
          "200": {
            "description": "Returns the pre-filled live input template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputNewModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Template could not be generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveInput": {
      "post": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Creates a new live input and begins provisioning the underlying resource.",
        "description": "**Behavior:**\r\nCreates a new Nomad.Common.Models.Live.LiveInputModel record and initiates provisioning of the live input resource.\r\nThe initial record will have a Nomad.Common.Models.Live.LiveInputModel.Status of Nomad.Common.Enums.LiveInputStatuses.Creating\r\nuntil provisioning completes.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new live input record is persisted.\r\n- Background provisioning of the live input resource is initiated.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the input model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Live.LiveInputNewModel object. A starter object can be obtained from M:Nomad.Controller.Live.LiveInputController.New.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the newly created live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided input model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Returns all live inputs, excluding those with a Deleting status.",
        "description": "**Behavior:**\r\nRetrieves all Nomad.Common.Models.Live.LiveInputModel records and filters out any that have a status of\r\nNomad.Common.Enums.LiveInputStatuses.Deleting. Inputs currently being deleted are excluded because\r\nfailed deletes transition to an error state which is visible in the UI.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the list of live inputs.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveInputModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Updates an existing live input configuration.",
        "description": "**Behavior:**\r\nUpdates a live input record using the values from the provided Nomad.Common.Models.Live.LiveInputEditModel.\r\nChanges to the underlying resource may not take effect immediately even though the\r\nNomad.Common.Models.Live.LiveInputModel record reflects the update.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live input record is updated in the data store.\r\n- Background propagation of changes to the provisioned resource may occur.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the edit model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Live.LiveInputEditModel containing updated values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the updated live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided edit model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveInput/{inputId}": {
      "get": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Gets a specific live input by its identifier.",
        "description": "**Behavior:**\r\nRetrieves a single Nomad.Common.Models.Live.LiveInputModel matching the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "inputId",
            "in": "path",
            "description": "The unique identifier of the live input to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Deletes a live input and its provisioned resources.",
        "description": "**Behavior:**\r\nDeletes the Nomad.Common.Models.Live.LiveInputModel record and its associated provisioned resource.\r\nThe deletion may not complete immediately; the resource transitions through intermediate states.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live input record is marked for deletion.\r\n- The provisioned resource is scheduled for teardown.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.\r\n- Fails if Nomad.Common.Models.Live.LiveChannelModel or Nomad.Common.Models.Live.LiveScheduleEventModel objects still reference the live input.",
        "parameters": [
          {
            "name": "inputId",
            "in": "path",
            "description": "The unique identifier of the live input to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the result model containing the deleted live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModelLiveResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfile/new": {
      "get": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Gets a pre-filled template for creating a new output profile.",
        "description": "**Behavior:**\r\nReturns a pre-populated Nomad.Common.Models.Live.LiveOutputProfileModel object with default values\r\nthat can be customized and submitted to M:Nomad.Controller.Live.LiveOutputProfileController.Create(Nomad.Common.Models.Live.LiveOutputProfileModel) to create a new output profile.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.\r\n- Returns 404 if the template could not be generated.",
        "responses": {
          "200": {
            "description": "Returns the pre-filled output profile template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Template could not be generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfile": {
      "post": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Creates a new output profile.",
        "description": "**Behavior:**\r\nCreates a new Nomad.Common.Models.Live.LiveOutputProfileModel record for configuring live output encoding settings.\r\nA starter object can be obtained from M:Nomad.Controller.Live.LiveOutputProfileController.New.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new output profile record is persisted.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Live.LiveOutputProfileModel object containing the output profile configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the newly created output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Returns all output profiles.",
        "description": "**Behavior:**\r\nRetrieves all Nomad.Common.Models.Live.LiveOutputProfileModel records configured in the system.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the list of output profiles.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Updates an existing output profile.",
        "description": "**Behavior:**\r\nUpdates an output profile record using the values from the provided Nomad.Common.Models.Live.LiveOutputProfileModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile record is updated in the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Live.LiveOutputProfileModel containing updated values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the updated output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfile/{liveOutputProfileId}": {
      "get": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Gets a specific output profile by its identifier.",
        "description": "**Behavior:**\r\nRetrieves a single Nomad.Common.Models.Live.LiveOutputProfileModel matching the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileId",
            "in": "path",
            "description": "The unique identifier of the output profile to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Deletes an output profile.",
        "description": "**Behavior:**\r\nDeletes the Nomad.Common.Models.Live.LiveOutputProfileModel record and its associated resources.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile record is removed from the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileId",
            "in": "path",
            "description": "The unique identifier of the output profile to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the result model containing the deleted output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModelLiveResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfileGroup": {
      "post": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Creates a new output profile group.",
        "description": "**Behavior:**\r\nCreates a new Nomad.Common.Models.Live.LiveOutputProfileGroupModel record that groups related output profiles together.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new output profile group record is persisted.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile group model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Live.LiveOutputProfileGroupModel object containing the group configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the newly created output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile group model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Returns all output profile groups.",
        "description": "**Behavior:**\r\nRetrieves all Nomad.Common.Models.Live.LiveOutputProfileGroupModel records configured in the system.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the list of output profile groups.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Updates an existing output profile group.",
        "description": "**Behavior:**\r\nUpdates an output profile group record using the values from the provided Nomad.Common.Models.Live.LiveOutputProfileGroupModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile group record is updated in the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile group model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Live.LiveOutputProfileGroupModel containing updated values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the updated output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile group model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfileGroup/{liveOutputProfileGroupId}": {
      "get": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Gets a specific output profile group by its identifier.",
        "description": "**Behavior:**\r\nRetrieves a single Nomad.Common.Models.Live.LiveOutputProfileGroupModel matching the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileGroupId",
            "in": "path",
            "description": "The unique identifier of the output profile group to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Deletes an output profile group.",
        "description": "**Behavior:**\r\nDeletes the Nomad.Common.Models.Live.LiveOutputProfileGroupModel record identified by the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile group record is removed from the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileGroupId",
            "in": "path",
            "description": "The unique identifier of the output profile group to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the identifier of the deleted output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Creates or updates a live schedule record for a content item.",
        "description": "**Behavior:**\r\nPersists a new live schedule or updates an existing one for the content item referenced\r\nin the provided Nomad.Common.Models.Live.LiveScheduleEditModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A live schedule record is created or updated in the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The create/edit DTO model for live schedule metadata.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The live schedule was saved successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}": {
      "get": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Gets the live schedule for a specific content item.",
        "description": "**Behavior:**\r\nRetrieves the Nomad.Common.Models.Live.LiveScheduleModel associated with the specified content identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the live schedule for the content item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Deletes the live schedule for a specific content item.",
        "description": "**Behavior:**\r\nRemoves the live schedule record associated with the specified content identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live schedule record is removed from the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live schedule was deleted successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}/start": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Starts a live schedule immediately.",
        "description": "**Behavior:**\r\nTriggers an immediate start of the live schedule associated with the specified content item.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live schedule transitions to a running state.\r\n- Associated live channel broadcasting may begin.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to start.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live schedule was started successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}/stop": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Stops a live schedule immediately.",
        "description": "**Behavior:**\r\nTriggers an immediate stop of the live schedule associated with the specified content item.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live schedule transitions to a stopped state.\r\n- Associated live channel broadcasting is halted.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to stop.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live schedule was stopped successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}/copy": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Copies a content item and its live schedule using recurring criteria.",
        "description": "**Behavior:**\r\nCreates copies of the content item referenced by the specified identifier along with its\r\nassociated live schedule, applying the recurring criteria defined in the Nomad.Common.Models.Live.LiveScheduleCopyModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- New content records and associated live schedule records are created.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item to copy.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The model containing recurring copy criteria.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The content and schedule were copied successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/lookup/{lookupType}": {
      "get": {
        "tags": [
          "Lookup"
        ],
        "summary": "Retrieves lookup values by type with an optional key filter.",
        "description": "\r\n<b>Behavior:</b> Returns a list of lookup values for the specified lookup type.\r\n            Lookups are system-defined reference data such as asset statuses, batch actions, content types, etc.\r\n            An optional key filter can narrow results to a specific subset within the lookup type.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the lookup type does not exist or the lookup list cannot be found.",
        "parameters": [
          {
            "name": "lookupType",
            "in": "path",
            "description": "The type of lookup to retrieve (e.g., AssetStatuses, BatchActions).\n\nPageTemplates\n\nFields\n\nLookupTypes\n\nContentTemplates\n\nContentDefinitions\n\nContentTypes\n\nContentDefinitionGroups\n\nWorkflowStatuses\n\nDataSelectorContentDefinitions\n\nContent\n\nTemplatePacks\n\nPopularTags\n\nAllTags\n\nPropertyValues\n\nMediaTypes\n\nAssetTypes\n\nContentFields\n\nFormSelectorContentDefinitions\n\nCustomRenderers\n\nConstantContactCampaigns\n\nLanguages\n\nSecurityGroups\n\nCollections\n\nSecurityPermissions\n\nCustomLabelerTypes\n\nCustomLabelerStatuses\n\nLabels\n\nUsers\n\nMeetingSources\n\nLiveScheduleEventStatuses\n\nLiveExternalOutputProfiles\n\nLiveScheduleEventTypes\n\nLiveChannelStatuses\n\nLiveInputCodecs\n\nLiveInputMaximumBitrates\n\nLiveInputResolutions\n\nLiveInputStatuses\n\nLiveInputTypes\n\nNodeTypes\n\nLiveChannelTypes\n\nLiveOutputTypes\n\nRoles\n\nNewsSystems\n\nNprProfileTypes\n\nPaymentStatuses\n\nPingStatuses\n\nPropertyValueTypes\n\nScheduleItemSearchTypes\n\nScheduleItemSourceTypes\n\nScheduleItemTypes\n\nScheduleStatuses\n\nScheduleTypes\n\nStorageClasses\n\nSubtitleTypes\n\nSubtitleValueTypes\n\nTextEntityTypes\n\nUploadOverwriteOptions\n\nUserSessionStatuses\n\nVideoSegmentTypes\n\nVideoTrackingEvents\n\nBatchActionProcessorExecutionTypes\n\nVideoTrackingAttributes\n\nTemplatePackTypes\n\nAdServerTypes\n\nAdSlotTypes\n\nAssetRestoreTiers\n\nAssetStatuses\n\nBatchActions\n\nBucketTypes\n\nCloudFrontDistributions\n\nContentAttributes\n\nContentLanguageStatuses\n\nContentTextTypes\n\nContentUnitOfWorkActions\n\nDataFilterFieldOperators\n\nDataIndexTypes\n\nDataJoinFilterFieldClauses\n\nDataPatchTypes\n\nDataSortHeading\n\nEmailTypes\n\nEndPointSystems\n\nFaceMatchTypes\n\nFeaturedContentTypes\n\nImageTypes\n\nIvsChannelTypes\n\nIvsLatencyTypes\n\nJobProcessorActions\n\nLiveRequestActions\n\nLiveRequestTargets\n\nLoginResponseStatuses\n\nMediaConvertTypes\n\nMessageInfoTypes\n\nMetadataTypes\n\nModelContainerModes\n\nDayOfWeek\n\nVideoTrackingActions\n\nFrameIngestActions\n\nArchivePrefixTypes\n\nLiveRecordingStatuses\n\nLiveContentStatuses\n\nLiveScheduleStatuses\n\nContentActionTypes\n\nLiveChannelRealtimeTypes\n\nMediaLiveOutputTypes\n\nTextCaptionTypes\n\nLiveStateUpdateModes\n\nMediaBuilderItemSourceTypes\n\nMediaBuilderStatuses\n\nLocalRestoreProfiles\n\nUserSessionTrackingTypes\n\nShareDurationTypes\n\nTranscoders\n\nBulkIteratorStates\n\nResourceClass\n\nContentVersions\n\nContentFieldClassifications\n\nContentAttributeFlags\n\nContentDataIndexTypes\n\nImportActions\n\nContentMutatorClassifications\n\nShareTypes\n\nSharePermissions\n\nShareStatuses\n\nSearchTextFields\n\nPropertyChangeTypes\n\nUploadReplaceOptions\n\nAdvanceSearchFields\n\nRollupMeasurementSourceTypes\n\nStatMeasurementAggregationOperationTypes\n\nTranscribers\n\nEmbeddingTypes\n\nAssetTransferStatuses\n\nVideoTrackingStatuses\n\nVideoTrackingAlertStatuses\n\nFrameStateFlags\n\nNewsRoomFailureTypes",
            "required": true,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LookupTypes"
                }
              ],
              "x-enumNames": [
                "PageTemplates",
                "Fields",
                "LookupTypes",
                "ContentTemplates",
                "ContentDefinitions",
                "ContentTypes",
                "ContentDefinitionGroups",
                "WorkflowStatuses",
                "DataSelectorContentDefinitions",
                "Content",
                "TemplatePacks",
                "PopularTags",
                "AllTags",
                "PropertyValues",
                "MediaTypes",
                "AssetTypes",
                "ContentFields",
                "FormSelectorContentDefinitions",
                "CustomRenderers",
                "ConstantContactCampaigns",
                "Languages",
                "SecurityGroups",
                "Collections",
                "SecurityPermissions",
                "CustomLabelerTypes",
                "CustomLabelerStatuses",
                "Labels",
                "Users",
                "MeetingSources",
                "LiveScheduleEventStatuses",
                "LiveExternalOutputProfiles",
                "LiveScheduleEventTypes",
                "LiveChannelStatuses",
                "LiveInputCodecs",
                "LiveInputMaximumBitrates",
                "LiveInputResolutions",
                "LiveInputStatuses",
                "LiveInputTypes",
                "NodeTypes",
                "LiveChannelTypes",
                "LiveOutputTypes",
                "Roles",
                "NewsSystems",
                "NprProfileTypes",
                "PaymentStatuses",
                "PingStatuses",
                "PropertyValueTypes",
                "ScheduleItemSearchTypes",
                "ScheduleItemSourceTypes",
                "ScheduleItemTypes",
                "ScheduleStatuses",
                "ScheduleTypes",
                "StorageClasses",
                "SubtitleTypes",
                "SubtitleValueTypes",
                "TextEntityTypes",
                "UploadOverwriteOptions",
                "UserSessionStatuses",
                "VideoSegmentTypes",
                "VideoTrackingEvents",
                "BatchActionProcessorExecutionTypes",
                "VideoTrackingAttributes",
                "TemplatePackTypes",
                "AdServerTypes",
                "AdSlotTypes",
                "AssetRestoreTiers",
                "AssetStatuses",
                "BatchActions",
                "BucketTypes",
                "CloudFrontDistributions",
                "ContentAttributes",
                "ContentLanguageStatuses",
                "ContentTextTypes",
                "ContentUnitOfWorkActions",
                "DataFilterFieldOperators",
                "DataIndexTypes",
                "DataJoinFilterFieldClauses",
                "DataPatchTypes",
                "DataSortHeading",
                "EmailTypes",
                "EndPointSystems",
                "FaceMatchTypes",
                "FeaturedContentTypes",
                "ImageTypes",
                "IvsChannelTypes",
                "IvsLatencyTypes",
                "JobProcessorActions",
                "LiveRequestActions",
                "LiveRequestTargets",
                "LoginResponseStatuses",
                "MediaConvertTypes",
                "MessageInfoTypes",
                "MetadataTypes",
                "ModelContainerModes",
                "DayOfWeek",
                "VideoTrackingActions",
                "FrameIngestActions",
                "ArchivePrefixTypes",
                "LiveRecordingStatuses",
                "LiveContentStatuses",
                "LiveScheduleStatuses",
                "ContentActionTypes",
                "LiveChannelRealtimeTypes",
                "MediaLiveOutputTypes",
                "TextCaptionTypes",
                "LiveStateUpdateModes",
                "MediaBuilderItemSourceTypes",
                "MediaBuilderStatuses",
                "LocalRestoreProfiles",
                "UserSessionTrackingTypes",
                "ShareDurationTypes",
                "Transcoders",
                "BulkIteratorStates",
                "ResourceClass",
                "ContentVersions",
                "ContentFieldClassifications",
                "ContentAttributeFlags",
                "ContentDataIndexTypes",
                "ImportActions",
                "ContentMutatorClassifications",
                "ShareTypes",
                "SharePermissions",
                "ShareStatuses",
                "SearchTextFields",
                "PropertyChangeTypes",
                "UploadReplaceOptions",
                "AdvanceSearchFields",
                "RollupMeasurementSourceTypes",
                "StatMeasurementAggregationOperationTypes",
                "Transcribers",
                "EmbeddingTypes",
                "AssetTransferStatuses",
                "VideoTrackingStatuses",
                "VideoTrackingAlertStatuses",
                "FrameStateFlags",
                "NewsRoomFailureTypes"
              ]
            },
            "x-enumNames": [
              "PageTemplates",
              "Fields",
              "LookupTypes",
              "ContentTemplates",
              "ContentDefinitions",
              "ContentTypes",
              "ContentDefinitionGroups",
              "WorkflowStatuses",
              "DataSelectorContentDefinitions",
              "Content",
              "TemplatePacks",
              "PopularTags",
              "AllTags",
              "PropertyValues",
              "MediaTypes",
              "AssetTypes",
              "ContentFields",
              "FormSelectorContentDefinitions",
              "CustomRenderers",
              "ConstantContactCampaigns",
              "Languages",
              "SecurityGroups",
              "Collections",
              "SecurityPermissions",
              "CustomLabelerTypes",
              "CustomLabelerStatuses",
              "Labels",
              "Users",
              "MeetingSources",
              "LiveScheduleEventStatuses",
              "LiveExternalOutputProfiles",
              "LiveScheduleEventTypes",
              "LiveChannelStatuses",
              "LiveInputCodecs",
              "LiveInputMaximumBitrates",
              "LiveInputResolutions",
              "LiveInputStatuses",
              "LiveInputTypes",
              "NodeTypes",
              "LiveChannelTypes",
              "LiveOutputTypes",
              "Roles",
              "NewsSystems",
              "NprProfileTypes",
              "PaymentStatuses",
              "PingStatuses",
              "PropertyValueTypes",
              "ScheduleItemSearchTypes",
              "ScheduleItemSourceTypes",
              "ScheduleItemTypes",
              "ScheduleStatuses",
              "ScheduleTypes",
              "StorageClasses",
              "SubtitleTypes",
              "SubtitleValueTypes",
              "TextEntityTypes",
              "UploadOverwriteOptions",
              "UserSessionStatuses",
              "VideoSegmentTypes",
              "VideoTrackingEvents",
              "BatchActionProcessorExecutionTypes",
              "VideoTrackingAttributes",
              "TemplatePackTypes",
              "AdServerTypes",
              "AdSlotTypes",
              "AssetRestoreTiers",
              "AssetStatuses",
              "BatchActions",
              "BucketTypes",
              "CloudFrontDistributions",
              "ContentAttributes",
              "ContentLanguageStatuses",
              "ContentTextTypes",
              "ContentUnitOfWorkActions",
              "DataFilterFieldOperators",
              "DataIndexTypes",
              "DataJoinFilterFieldClauses",
              "DataPatchTypes",
              "DataSortHeading",
              "EmailTypes",
              "EndPointSystems",
              "FaceMatchTypes",
              "FeaturedContentTypes",
              "ImageTypes",
              "IvsChannelTypes",
              "IvsLatencyTypes",
              "JobProcessorActions",
              "LiveRequestActions",
              "LiveRequestTargets",
              "LoginResponseStatuses",
              "MediaConvertTypes",
              "MessageInfoTypes",
              "MetadataTypes",
              "ModelContainerModes",
              "DayOfWeek",
              "VideoTrackingActions",
              "FrameIngestActions",
              "ArchivePrefixTypes",
              "LiveRecordingStatuses",
              "LiveContentStatuses",
              "LiveScheduleStatuses",
              "ContentActionTypes",
              "LiveChannelRealtimeTypes",
              "MediaLiveOutputTypes",
              "TextCaptionTypes",
              "LiveStateUpdateModes",
              "MediaBuilderItemSourceTypes",
              "MediaBuilderStatuses",
              "LocalRestoreProfiles",
              "UserSessionTrackingTypes",
              "ShareDurationTypes",
              "Transcoders",
              "BulkIteratorStates",
              "ResourceClass",
              "ContentVersions",
              "ContentFieldClassifications",
              "ContentAttributeFlags",
              "ContentDataIndexTypes",
              "ImportActions",
              "ContentMutatorClassifications",
              "ShareTypes",
              "SharePermissions",
              "ShareStatuses",
              "SearchTextFields",
              "PropertyChangeTypes",
              "UploadReplaceOptions",
              "AdvanceSearchFields",
              "RollupMeasurementSourceTypes",
              "StatMeasurementAggregationOperationTypes",
              "Transcribers",
              "EmbeddingTypes",
              "AssetTransferStatuses",
              "VideoTrackingStatuses",
              "VideoTrackingAlertStatuses",
              "FrameStateFlags",
              "NewsRoomFailureTypes"
            ]
          },
          {
            "name": "lookupKey",
            "in": "query",
            "description": "Optional key to filter lookup values within the type.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The lookup values were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LookupModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The lookup type is invalid or the lookup list cannot be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/media/group/{fullSlugOrId}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves a media group by its slug or unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the corresponding media content for the specified ID or slug.\r\n            In addition to Media Group IDs, this endpoint also supports: Asset Folders, Content Ratings,\r\n            Events, Genres, Performers, Series, Media Attributes, Media Tags, Venues, and Watchlist.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the slug or ID cannot be resolved to a media group. Returns 400 if the request parameters are malformed.",
        "parameters": [
          {
            "name": "fullSlugOrId",
            "in": "path",
            "description": "Any of the supported content IDs or a slug that resolves to an ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "filterIds",
            "in": "query",
            "description": "One or more UUID filters to narrow the results.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            }
          },
          {
            "name": "languageId",
            "in": "query",
            "description": "Optional language identifier to localize the response.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaGroupModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found for the specified identifier."
          },
          "400": {
            "description": "Bad request due to invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The ID or slug was not found or is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/my-group/{id}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves user-specific media group content for the authenticated user.",
        "description": "\r\n<b>Behavior:</b> Returns the corresponding \"my\" media content for the specified ID.\r\n            This content is not cached and is unique for the currently logged-in user.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if the ID was not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Any of the supported \"my content\" IDs.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "filterIds",
            "in": "query",
            "description": "One or more UUID filters to narrow the results.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaGroupModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found."
          },
          "400": {
            "description": "Bad request due to invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The ID was not found or is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/media/my-group/{id}/{profileId}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves user-specific media group content for a specific profile.",
        "description": "\r\n<b>Behavior:</b> Returns the corresponding \"my\" media content for the specified ID and profile.\r\n            This content is not cached and is unique for the specified profile ID.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if the ID or profile was not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Any of the supported \"my content\" IDs.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "profileId",
            "in": "path",
            "description": "The unique identifier of the user profile to retrieve content for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "filterIds",
            "in": "query",
            "description": "One or more UUID filters to narrow the results.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaGroupModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found."
          },
          "400": {
            "description": "Bad request due to invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The ID or profile was not found or is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/media/item/{fullSlugOrId}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves a media item by its slug or unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the item details for the specified ID or slug. Supports the following content types:\r\n            Asset File, Episode, Event, Series, Season, and Video.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the slug or ID cannot be resolved to a media item. Returns 400 if the request is malformed.",
        "parameters": [
          {
            "name": "fullSlugOrId",
            "in": "path",
            "description": "Any of the supported content IDs or a slug that resolves to an ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaItemModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found."
          },
          "400": {
            "description": "Bad request due to invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The ID or slug was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/content/{fullSlugOrId}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves a dynamic content record by its slug or unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the dynamic content record for the specified ID or slug.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the ID or slug does not match any dynamic content record.",
        "parameters": [
          {
            "name": "fullSlugOrId",
            "in": "path",
            "description": "The dynamic content record ID or slug.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DynamicContentModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found."
          },
          "400": {
            "description": "Bad request due to invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The ID or slug was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/content": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves all dynamic content records.",
        "description": "\r\n<b>Behavior:</b> Returns a list of all dynamic content records available in the system.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 204 if no dynamic content records exist.",
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DynamicContentModel"
                  }
                }
              }
            }
          },
          "204": {
            "description": "No content records exist."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/config/{id}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves the site configuration settings for a specific identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the site configuration settings for the specified site config ID.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the specified site config ID does not exist.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the site configuration record.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteConfigModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found."
          },
          "400": {
            "description": "Bad request due to invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The site configuration ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/config": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves the default site configuration settings.",
        "description": "\r\n<b>Behavior:</b> Returns the default site configuration settings when no specific ID is provided.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no default site configuration is defined.",
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SiteConfigModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The default site configuration is not defined.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/search": {
      "post": {
        "tags": [
          "Media"
        ],
        "summary": "Searches for media items based on the provided search criteria.",
        "description": "\r\n<b>Behavior:</b> Returns matching media items as per the search criteria defined in the request body.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the search model is null or invalid. Returns 204 if no items match the criteria.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Media.MediaSearchModel containing search criteria.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaSearchModel"
                  }
                ],
                "description": "Represents a search request for media items with pagination, text query, sorting, and identifier filtering."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaSearchModel"
                  }
                ],
                "description": "Represents a search request for media items with pagination, text query, sorting, and identifier filtering."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaSearchModel"
                  }
                ],
                "description": "Represents a search request for media items with pagination, text query, sorting, and identifier filtering."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaSearchModel"
                  }
                ],
                "description": "Represents a search request for media items with pagination, text query, sorting, and identifier filtering."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FeaturedItemModel"
                  }
                }
              }
            }
          },
          "204": {
            "description": "No content matched the search criteria."
          },
          "400": {
            "description": "Bad request due to invalid search model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The specified resource was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/my-content": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves the authenticated user's personalized content lists.",
        "description": "\r\n<b>Behavior:</b> Gets favorites and continue watching lists of IDs for the currently logged-in user.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if no content is found for the user.",
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyContentModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found for the user."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/media/my-content/{profileId}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves personalized content lists for a specific user profile.",
        "description": "\r\n<b>Behavior:</b> Gets favorites and continue watching lists of IDs for the specified profile.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if no content is found for the profile.",
        "parameters": [
          {
            "name": "profileId",
            "in": "path",
            "description": "The unique identifier of the user profile to retrieve content for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request was successful.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyContentModel"
                }
              }
            }
          },
          "204": {
            "description": "No content found for the profile."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/media/clear-watchlist": {
      "post": {
        "tags": [
          "Media"
        ],
        "summary": "Clears the authenticated user's watchlist (favorites).",
        "description": "\r\n<b>Behavior:</b> Deletes the user's list of favorites. If no user ID is passed, it clears the watchlist of the currently logged-in user.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> All favorites for the specified or current user are permanently removed.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if the user ID was not found.",
        "parameters": [
          {
            "name": "userId",
            "in": "query",
            "description": "Optional user ID. If not provided, the currently authenticated user's watchlist is cleared.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The watchlist was successfully cleared."
          },
          "204": {
            "description": "No content."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The user ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/media/clear-watching": {
      "post": {
        "tags": [
          "Media"
        ],
        "summary": "Clears continue watching markers for the authenticated user or a specific asset.",
        "description": "\r\n<b>Behavior:</b> Deletes continue watching markers. If no user ID is passed, it clears markers for the currently logged-in user. If no asset ID is passed, it clears all markers.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Continue watching progress markers are permanently removed for the specified scope.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if the user or asset ID was not found.",
        "parameters": [
          {
            "name": "userId",
            "in": "query",
            "description": "Optional user ID. If not provided, the currently authenticated user's markers are cleared.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "assetId",
            "in": "query",
            "description": "Optional asset ID. If not provided, all continue watching markers are cleared.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The continue watching markers were successfully cleared."
          },
          "204": {
            "description": "No content."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The user or asset ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/media/form/{id}": {
      "post": {
        "tags": [
          "Media"
        ],
        "summary": "Submits a custom form record into a content definition.",
        "description": "\r\n<b>Behavior:</b> Posts a new record into a custom content definition identified by the specified ID.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> A new form record is persisted in the data store under the specified content definition.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the content definition ID does not exist. Returns 400 if the form data is invalid.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content definition to post the form data to.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The form data to submit.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormDataModel"
                  }
                ],
                "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormDataModel"
                  }
                ],
                "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormDataModel"
                  }
                ],
                "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormDataModel"
                  }
                ],
                "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormDataModel"
                  }
                ],
                "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormDataModel"
                  }
                ],
                "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormDataModel"
                  }
                ],
                "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The form was successfully submitted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "204": {
            "description": "No content."
          },
          "400": {
            "description": "Bad request due to invalid form data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content definition ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/routes": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves all URL routes for pre-rendering the UI.",
        "description": "\r\n<b>Behavior:</b> Returns a plain-text list of all URL routes available for pre-rendering the user interface.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 500 if an error occurs while generating routes.",
        "responses": {
          "200": {
            "description": "The routes were successfully retrieved.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/sitemap/{baseUrl}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Generates a sitemap for the specified base URL.",
        "description": "\r\n<b>Behavior:</b> Returns a plain-text sitemap of all URL routes prefixed with the specified base URL, suitable for search engine indexing.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the base URL parameter is missing or invalid. Returns 500 if an error occurs during generation.",
        "parameters": [
          {
            "name": "baseUrl",
            "in": "path",
            "description": "The base URL to prepend to all routes in the sitemap.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The sitemap was successfully generated.",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "The base URL parameter was missing or invalid.",
            "content": {
              "text/plain": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/media/set-cookies/{id}": {
      "get": {
        "tags": [
          "Media"
        ],
        "summary": "Retrieves anonymous secure cookies for content delivery.",
        "description": "\r\n<b>Behavior:</b> Generates and sets signed cookies for anonymous access to secure content (live streams or assets).\r\n            The cookies are appended to the HTTP response and also returned in the response body. Supports both\r\n            live channel content definitions and asset content definitions based on system configuration.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible for anonymous cookie generation.\r\n\r\n<b>Side Effects:</b> Secure signed cookies are set on the HTTP response for CDN authentication. Cookie expiration is controlled by system settings.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the ID does not match an enabled content type, if URL signing fails, or if no cookies could be generated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the content to retrieve cookies for. This can be the ID for the content definition of the LiveChannel, a folder asset ID, or a specific Asset ID.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The cookies were successfully generated and set.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request due to invalid parameters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content ID does not match an enabled content type or cookie generation failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        }
      }
    },
    "/mediaBuilder": {
      "get": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Retrieves all media builders created by the current user.",
        "description": "\r\n<b>Behavior:</b> Returns an array of all media builders owned by the currently authenticated user.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the request is invalid.",
        "responses": {
          "200": {
            "description": "The media builders were successfully retrieved.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MediaBuilderModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Creates a new media builder.",
        "description": "\r\n<b>Behavior:</b> Creates a new media builder using the provided model and returns the fully populated media builder after creation.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> A new media builder record is persisted in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Returns 401 if the user is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.MediaBuilder.MediaBuilderAddModel containing the media builder creation parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderAddModel"
                  }
                ],
                "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderAddModel"
                  }
                ],
                "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderAddModel"
                  }
                ],
                "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderAddModel"
                  }
                ],
                "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderAddModel"
                  }
                ],
                "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderAddModel"
                  }
                ],
                "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderAddModel"
                  }
                ],
                "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media builder was successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}": {
      "get": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Retrieves a specific media builder by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the media builder matching the specified ID. Throws a 404 error if the media builder does not exist.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no media builder exists with the specified ID. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The media builder was successfully retrieved.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The media builder with the specified ID was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Updates an existing media builder.",
        "description": "\r\n<b>Behavior:</b> Updates the media builder identified by the specified ID with the provided model data and returns the updated media builder.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The existing media builder record is updated in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The Nomad.Common.Models.MediaBuilder.MediaBuilderUpdateModel containing the updated media builder parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderUpdateModel"
                  }
                ],
                "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderUpdateModel"
                  }
                ],
                "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderUpdateModel"
                  }
                ],
                "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderUpdateModel"
                  }
                ],
                "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderUpdateModel"
                  }
                ],
                "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderUpdateModel"
                  }
                ],
                "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderUpdateModel"
                  }
                ],
                "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media builder was successfully updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Deletes a media builder by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the media builder identified by the specified ID and returns the ID of the deleted resource.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The media builder record and its associated items are permanently removed from the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the media builder ID is invalid.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The media builder was successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/idsbysource/{sourceAssetId}": {
      "get": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Retrieves all media builder IDs associated with a specific source asset.",
        "description": "\r\n<b>Behavior:</b> Returns an array of GUIDs representing all media builders that reference the specified source asset ID.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the source asset ID is invalid.",
        "parameters": [
          {
            "name": "sourceAssetId",
            "in": "path",
            "description": "The unique identifier of the source asset to find media builders for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The media builder IDs were successfully retrieved.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}/items": {
      "get": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Retrieves all items within a specific media builder.",
        "description": "\r\n<b>Behavior:</b> Returns an array of all media builder items belonging to the specified media builder ID.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the media builder ID is invalid.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to retrieve items for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The media builder items were successfully retrieved.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MediaBuilderItemModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Creates a single media builder item within a media builder.",
        "description": "\r\n<b>Behavior:</b> Creates a new media builder item associated with the specified media builder ID. The media builder ID from the route is assigned to the input model before creation. Returns the change tracking result.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> A new media builder item record is persisted in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to add the item to.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The Nomad.Common.Models.MediaBuilder.MediaBuilderItemAddModel containing the item creation parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                  }
                ],
                "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                  }
                ],
                "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                  }
                ],
                "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                  }
                ],
                "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                  }
                ],
                "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                  }
                ],
                "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                  }
                ],
                "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media builder item was successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderItemChangeModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}/items/{sourceAssetId}/add-annotations": {
      "post": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Creates media builder items from annotations of a source asset.",
        "description": "\r\n<b>Behavior:</b> Creates media builder items from the annotations of the specified source asset and adds them to the specified media builder. Returns the change tracking results for all created items.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> New media builder item records are persisted in the data store based on source asset annotations.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the IDs are invalid.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to add items to.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "sourceAssetId",
            "in": "path",
            "description": "The unique identifier of the source asset to create media builder items from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The media builder items were successfully created from annotations.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MediaBuilderItemChangeModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}/items/bulk": {
      "post": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Creates multiple media builder items in bulk within a media builder.",
        "description": "\r\n<b>Behavior:</b> Creates multiple media builder items associated with the specified media builder ID. The media builder ID from the route is assigned to each input model before creation. Returns the change tracking results for all created items.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Multiple new media builder item records are persisted in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input array is null or contains invalid models. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to add items to.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "An array of Nomad.Common.Models.MediaBuilder.MediaBuilderItemAddModel containing the item creation parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MediaBuilderItemAddModel"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media builder items were successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MediaBuilderItemChangeModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or contained invalid models.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}/items/{itemId}": {
      "delete": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Deletes a specific item from a media builder.",
        "description": "\r\n<b>Behavior:</b> Removes the specified item from the media builder and returns the change tracking result reflecting the deletion.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The media builder item record is permanently removed from the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if either ID is invalid.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder containing the item.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "itemId",
            "in": "path",
            "description": "The unique identifier of the media builder item to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The media builder item was successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderItemChangeModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}/items/{itemId}/move": {
      "post": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Moves a media builder item to a new position within the media builder.",
        "description": "\r\n<b>Behavior:</b> Repositions the specified media builder item within its parent media builder according to the move model parameters. Returns the change tracking result.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The ordering of media builder items is updated in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the IDs or move model are invalid.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder containing the item.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "itemId",
            "in": "path",
            "description": "The unique identifier of the media builder item to move.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The Nomad.Common.Models.MediaBuilder.MediaBuilderItemMoveModel containing the move parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemMoveModel"
                  }
                ],
                "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemMoveModel"
                  }
                ],
                "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemMoveModel"
                  }
                ],
                "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemMoveModel"
                  }
                ],
                "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemMoveModel"
                  }
                ],
                "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemMoveModel"
                  }
                ],
                "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderItemMoveModel"
                  }
                ],
                "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media builder item was successfully moved.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderItemChangeModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid or the move model was null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}/render": {
      "post": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Renders a media builder, processing it for output.",
        "description": "\r\n<b>Behavior:</b> Triggers the render process for the specified media builder and returns the updated media builder model after rendering completes.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The media builder is rendered, which may produce output assets and update the media builder state.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the media builder ID is invalid.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to render.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The media builder was successfully rendered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mediaBuilder/{mediaBuilderId}/duplicate": {
      "post": {
        "tags": [
          "MediaBuilder"
        ],
        "summary": "Duplicates an existing media builder.",
        "description": "\r\n<b>Behavior:</b> Creates a duplicate of the specified media builder using the provided duplication parameters and returns the newly created copy.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> A new media builder record (and its items) are created as a copy in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the duplicate model is null or invalid. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "mediaBuilderId",
            "in": "path",
            "description": "The unique identifier of the media builder to duplicate.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The Nomad.Common.Models.MediaBuilder.MediaBuilderDuplicateModel containing the duplication parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderDuplicateModel"
                  }
                ],
                "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderDuplicateModel"
                  }
                ],
                "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderDuplicateModel"
                  }
                ],
                "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderDuplicateModel"
                  }
                ],
                "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderDuplicateModel"
                  }
                ],
                "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderDuplicateModel"
                  }
                ],
                "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderDuplicateModel"
                  }
                ],
                "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media builder was successfully duplicated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MediaBuilderModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mrss/feed": {
      "get": {
        "tags": [
          "Mrss"
        ],
        "summary": "Retrieves the MRSS (Media RSS) feed as XML content.",
        "description": "\r\n<b>Behavior:</b> Generates and returns an MRSS feed in XML format. The XML is serialized without the XML declaration\r\n            and uses the media namespace (http://search.yahoo.com/mrss/) for media-specific elements such as media:description.\r\n            Returns 404 if the feed model cannot be generated.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if the feed data is not available.",
        "responses": {
          "200": {
            "description": "The MRSS feed was successfully generated and returned."
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The feed data is not available or could not be generated.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred during feed generation."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/payment/start-transaction": {
      "post": {
        "tags": [
          "Payment"
        ],
        "summary": "Initiates a payment transaction with the merchant processor.",
        "description": "\r\n<b>Behavior:</b> Starts a new payment transaction by communicating with the configured merchant processor. This should be called when the user is most likely going to be making the transaction. The Cognito contact ID is extracted from the authenticated user's claims.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]). The user's Cognito contact ID claim is required.\r\n\r\n<b>Side Effects:</b> A new payment transaction is initiated with the merchant processor. The transaction state is persisted for subsequent cancel or complete operations.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request model is invalid or the Cognito contact ID claim is missing. Returns 401 if the user is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Payment.StartTransactionRequestModel containing the transaction parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StartTransactionRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StartTransactionRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StartTransactionRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StartTransactionRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StartTransactionRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StartTransactionRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StartTransactionRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The transaction was successfully initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartTransactionResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid or the required claims were missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/payment/{id}/cancel-transaction": {
      "post": {
        "tags": [
          "Payment"
        ],
        "summary": "Cancels an in-progress payment transaction with the merchant processor.",
        "description": "\r\n<b>Behavior:</b> Cancels the payment transaction identified by the specified ID. This should be used when the user has decided not to continue with the purchase. The Cognito contact ID is extracted from the authenticated user's claims.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]). The user's Cognito contact ID claim is required.\r\n\r\n<b>Side Effects:</b> The payment transaction is cancelled with the merchant processor and the transaction state is updated.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the transaction ID is invalid or the Cognito contact ID claim is missing. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the transaction to cancel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The transaction was successfully cancelled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid or the required claims were missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/payment/{id}/complete-transaction": {
      "post": {
        "tags": [
          "Payment"
        ],
        "summary": "Completes a payment transaction with the merchant processor.",
        "description": "\r\n<b>Behavior:</b> Marks the payment transaction identified by the specified ID as complete. This API call is optional and is used to help move the UI along. The actual successful status comes directly from the merchant processor in the form of a callback. The Cognito contact ID is extracted from the authenticated user's claims.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]). The user's Cognito contact ID claim is required.\r\n\r\n<b>Side Effects:</b> The payment transaction completion is recorded. The definitive completion status is determined by the merchant processor callback.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the transaction ID is invalid or the Cognito contact ID claim is missing. Returns 401 if the user is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the transaction to complete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The transaction was successfully marked as complete.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid or the required claims were missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/person": {
      "post": {
        "tags": [
          "Person"
        ],
        "summary": "Create a new person entity for facial recognition matching.",
        "description": "\r\n<b>Behavior:</b> Creates a new person with the specified name. The name must be unique —\r\n            duplicate names are not allowed. Optionally accepts lists of matched, unmatched, and blurry face identifiers.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Creates a new person record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or Name is null/empty. Throws if a person with the same name already exists.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Admin.Person.PersonSubmitModel containing the Name and optional face matching lists (MatchedFaces, UnmatchedFaces, BlurryFaces).",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The person was created successfully. Returns the person's ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, Name is null or empty, or a person with this name already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/person/{id}": {
      "get": {
        "tags": [
          "Person"
        ],
        "summary": "Retrieve a person by ID.",
        "description": "\r\n<b>Behavior:</b> Returns the person's details including name, face match counts\r\n            (automatch, probable match, confirmed match, not match), and celebrity detection data.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no person exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the person entity.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PersonModel"
                }
              }
            }
          },
          "404": {
            "description": "No person was found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Person"
        ],
        "summary": "Delete a person by ID.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the person with the specified ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Permanently removes the person record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the ID is empty.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The person was successfully deleted. Returns the deleted person's ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The ID is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Person"
        ],
        "summary": "Update a person by ID. Note: this endpoint is currently stubbed and returns Guid.Empty.",
        "description": "\r\n<b>Behavior:</b> Currently stubbed — validates input and name but does not perform the update.\r\n            Always returns an IdModel with Guid.Empty. The intended behavior is to update the person's name and face matching lists.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None (stubbed).\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or Name is null/empty.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "A Nomad.Common.Models.Admin.Person.PersonSubmitModel containing the updated Name, MatchedFaces, UnmatchedFaces, and BlurryFaces.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns an IdModel. Note: currently returns Guid.Empty as this endpoint is not fully implemented.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null or Name is null/empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/person/{id}/{personFaceType}": {
      "get": {
        "tags": [
          "Person"
        ],
        "summary": "Retrieve faces associated with a person, filtered by match type. Note: this endpoint is currently stubbed and returns null.",
        "description": "\r\n<b>Behavior:</b> Currently stubbed — always returns null. The intended behavior is to retrieve\r\n            face detection results (bounding boxes, similarity scores, preview images) for a person,\r\n            filtered by the specified face match type.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None (stubbed).\r\n\r\n<b>Error Scenarios:</b> Currently returns null regardless of input.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to get faces for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "personFaceType",
            "in": "path",
            "description": "The Nomad.Common.Enums.FaceMatchTypes filter — e.g., Automatch, ProbableMatch, ConfirmedMatch, NotMatch, or Blurry.\n\nAutomatch\n\nProbableMatch\n\nNotMatch\n\nConfirmedMatch\n\nBlurry",
            "required": true,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/FaceMatchTypes"
                }
              ],
              "description": "Categorizes the type of facial recognition match between a detected face and a person.\r\nUsed to filter face results when querying person faces.",
              "x-enumNames": [
                "Automatch",
                "ProbableMatch",
                "NotMatch",
                "ConfirmedMatch",
                "Blurry"
              ]
            },
            "x-enumNames": [
              "Automatch",
              "ProbableMatch",
              "NotMatch",
              "ConfirmedMatch",
              "Blurry"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the list of faces. Note: currently returns null as this endpoint is not fully implemented.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PersonFaceModelListResultModel"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/ping": {
      "get": {
        "tags": [
          "Ping"
        ],
        "summary": "Health check endpoint that returns \"Pong\" to confirm the API is running.",
        "description": "\r\n<b>Behavior:</b> Returns the string \"Pong\" as a simple health check response.\r\n            If includeHeaders is true, returns a formatted string listing all HTTP request headers and their values instead,\r\n            which is useful for debugging proxy and load balancer configurations.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> None — this endpoint always succeeds.",
        "parameters": [
          {
            "name": "includeHeaders",
            "in": "query",
            "description": "When true, returns all HTTP request headers instead of \"Pong\". Useful for debugging. Default is false.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns \"Pong\" or the request header listing.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/ping/auth": {
      "get": {
        "tags": [
          "Ping"
        ],
        "summary": "Authenticated health check endpoint that validates the Bearer token is still valid.",
        "description": "\r\n<b>Behavior:</b> Returns the string \"Pong Auth\". Use this endpoint to verify that a Bearer token\r\n            is still valid. If the token is invalid or expired, the request will be rejected with 401.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the Bearer token is missing, invalid, or expired.",
        "responses": {
          "200": {
            "description": "The Bearer token is valid. Returns \"Pong Auth\".",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "The Bearer token is missing, invalid, or expired."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/groups": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Retrieves the portal content groups used for navigation.",
        "description": "\r\n<b>Behavior:</b> Returns the portal group structure based on the content request parameters.\r\n            Groups represent the navigational hierarchy displayed in the portal sidebar.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request model is null.",
        "requestBody": {
          "description": "The portal content request specifying which groups to retrieve.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortalContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving portal content groups."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortalContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving portal content groups."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortalContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving portal content groups."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortalContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving portal content groups."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortalContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving portal content groups."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortalContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving portal content groups."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortalContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving portal content groups."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The portal groups were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PortalModel"
                }
              }
            }
          },
          "400": {
            "description": "The request model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/featured-content": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Retrieves featured content for the portal.",
        "description": "\r\n<b>Behavior:</b> Returns featured content items based on the request parameters.\r\n            Featured content is typically displayed prominently on the portal home page or content sections.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request model is null.",
        "requestBody": {
          "description": "The featured content request specifying which content to retrieve.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FeaturedContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving featured content."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FeaturedContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving featured content."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FeaturedContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving featured content."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FeaturedContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving featured content."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FeaturedContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving featured content."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FeaturedContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving featured content."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FeaturedContentRequestModel"
                  }
                ],
                "description": "Request model for retrieving featured content."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The featured content was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PortalModel"
                }
              }
            }
          },
          "400": {
            "description": "The request model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/savedsearch": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Creates a new saved search for the current user.",
        "description": "\r\n<b>Behavior:</b> Persists the search criteria so the user can re-execute it later.\r\n            If an ID is provided in the model, it is used; otherwise a new ID is generated.\r\n            Returns the fully populated saved search after creation.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a new saved search record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request model is null.",
        "requestBody": {
          "description": "The saved search definition to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The saved search was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SavedSearchModel"
                }
              }
            }
          },
          "400": {
            "description": "The request model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Retrieves all saved searches belonging to the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Returns the complete list of saved searches created by the current user.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The saved searches were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SavedSearchModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/search": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Executes a search query against the search index.",
        "description": "\r\n<b>Behavior:</b> Accepts a full search model with filters, sort fields, pagination, and query text.\r\n            Returns a paginated list of matching search results.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the search model is null or contains invalid filter criteria.",
        "parameters": [
          {
            "name": "includeInternalFieldsInResults",
            "in": "query",
            "description": "When true, includes internal system fields in the search result output. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "The search query model containing filters, sort fields, pagination, and query text.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The search completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The search model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/search-saved/{id}": {
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Executes a previously saved search by its ID.",
        "description": "\r\n<b>Behavior:</b> Loads the saved search definition by ID and executes it against the search index.\r\n            Optionally limits which fields are returned in the results.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the saved search to execute.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "returnedFieldNames",
            "in": "query",
            "description": "Optional list of field names to include in the results. If empty, all fields are returned.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The saved search executed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The saved search ID is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/search-saved": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Executes a saved search using the full saved search model provided in the request body.",
        "description": "\r\n<b>Behavior:</b> Accepts a complete saved search model and executes it against the search index.\r\n            Unlike the GET variant, this allows passing a modified saved search without persisting the changes.\r\n            Optionally limits which fields are returned in the results.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the saved search model is null.",
        "parameters": [
          {
            "name": "returnedFieldNames",
            "in": "query",
            "description": "Optional list of field names to include in the results. If empty, all fields are returned.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "requestBody": {
          "description": "The saved search model to execute.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchModel"
                  }
                ],
                "description": "Represents a persisted saved search with its full configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchModel"
                  }
                ],
                "description": "Represents a persisted saved search with its full configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchModel"
                  }
                ],
                "description": "Represents a persisted saved search with its full configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchModel"
                  }
                ],
                "description": "Represents a persisted saved search with its full configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The saved search executed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The saved search model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/search/export": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Exports search results as an Excel spreadsheet or queues the export for background processing.",
        "description": "\r\n<b>Behavior:</b> Executes the search query and exports matching results as an XLSX file.\r\n            If no sort fields are provided, results are sorted by masterId by default.\r\n            When the background flag is set, the export is queued as a batch action\r\n            and the caller receives a 204 response immediately; the exported file is delivered via email when ready.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> When running in background mode, creates a batch job for asynchronous processing.\r\n\r\n<b>Error Scenarios:</b> Returns 204 if no records match the search criteria.\r\n            Returns 400 if the search model is null or invalid.",
        "parameters": [
          {
            "name": "background",
            "in": "query",
            "description": "When true, queues the export for background processing and returns immediately. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "The search query model defining which results to export.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The export file was generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "204": {
            "description": "No matching records found, or background export was queued."
          },
          "400": {
            "description": "The search model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/search/{id}": {
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Retrieves a single indexed document by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Fetches a specific document from the search index by ID.\r\n            In the Portal API, only Asset and Live Channel content definitions are accessible;\r\n            requests for other content types return 404.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no document with the given ID exists\r\n            or if the document is not an asset or live channel.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the indexed document to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "includeInternalFieldsInResults",
            "in": "query",
            "description": "When true, includes internal system fields in the result. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The document was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No document found with the specified ID, or the document type is not accessible from the portal.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/savedsearch/{id}": {
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Retrieves a saved search by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the full saved search definition including its filter criteria,\r\n            sort fields, and display configuration.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no saved search exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the saved search.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The saved search was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SavedSearchModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No saved search found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Portal"
        ],
        "summary": "Partially updates an existing saved search.",
        "description": "\r\n<b>Behavior:</b> Applies the specified patch changes to the saved search identified by ID.\r\n            Only the fields provided in the patch model are updated; other fields remain unchanged.\r\n            Returns the fully updated saved search after the patch is applied.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Modifies the saved search record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the patch model is null.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the saved search to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The patch model containing the fields to update.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchPatchModel"
                  }
                ],
                "description": "Model for partially updating a saved search. Only non-null fields are applied."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchPatchModel"
                  }
                ],
                "description": "Model for partially updating a saved search. Only non-null fields are applied."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchPatchModel"
                  }
                ],
                "description": "Model for partially updating a saved search. Only non-null fields are applied."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchPatchModel"
                  }
                ],
                "description": "Model for partially updating a saved search. Only non-null fields are applied."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchPatchModel"
                  }
                ],
                "description": "Model for partially updating a saved search. Only non-null fields are applied."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchPatchModel"
                  }
                ],
                "description": "Model for partially updating a saved search. Only non-null fields are applied."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchPatchModel"
                  }
                ],
                "description": "Model for partially updating a saved search. Only non-null fields are applied."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The saved search was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SavedSearchModel"
                }
              }
            }
          },
          "400": {
            "description": "The patch model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Portal"
        ],
        "summary": "Replaces an existing saved search with a new definition.",
        "description": "\r\n<b>Behavior:</b> Fully replaces the saved search identified by ID with the provided model.\r\n            All fields are overwritten. Returns the updated saved search after replacement.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Overwrites the saved search record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the model is null.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the saved search to replace.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The complete saved search definition to store.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SavedSearchAddModel"
                  }
                ],
                "description": "Model for creating a new saved search."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The saved search was replaced successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SavedSearchModel"
                }
              }
            }
          },
          "400": {
            "description": "The model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Portal"
        ],
        "summary": "Deletes a saved search by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently removes the saved search identified by ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes the saved search record.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the saved search to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The saved search was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/searchprofile/{id}": {
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Retrieves a search profile by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the search profile configuration including default filters,\r\n            display columns, and sorting preferences.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no search profile exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the search profile.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The search profile was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchProfileModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No search profile found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Portal"
        ],
        "summary": "Replaces an existing search profile with a new definition.",
        "description": "\r\n<b>Behavior:</b> Fully replaces the search profile identified by ID with the provided model.\r\n            The ID in the route is assigned to the model before saving. Returns the updated profile.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Overwrites the search profile record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the model is null.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the search profile to replace.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The complete search profile definition to store.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The search profile was replaced successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchProfileModel"
                }
              }
            }
          },
          "400": {
            "description": "The model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Portal"
        ],
        "summary": "Deletes a search profile by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently removes the search profile identified by ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes the search profile record.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the search profile to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The search profile was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/searchprofile": {
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Retrieves all search profiles belonging to the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Returns the complete list of search profiles created by the current user.\r\n            Search profiles define default search configurations including filters, display columns, and sort order.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The search profiles were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Creates a new search profile for the current user.",
        "description": "\r\n<b>Behavior:</b> Persists a new search profile configuration including default filters,\r\n            display columns, and sorting preferences. Returns the fully populated profile after creation.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a new search profile record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the model is null.",
        "requestBody": {
          "description": "The search profile definition to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchProfileModel"
                  }
                ],
                "description": "Represents a user's search profile with default search configurations."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The search profile was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchProfileModel"
                }
              }
            }
          },
          "400": {
            "description": "The model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/userContentAttribute/add": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Adds a user content attribute (e.g., favorite, like, bookmark) for the current user.",
        "description": "\r\n<b>Behavior:</b> Associates a content attribute with the specified content item for the current user.\r\n            Content attributes track user-specific interactions such as favorites, likes, and bookmarks.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a user content attribute record.",
        "requestBody": {
          "description": "The user content attribute to add, including the content ID and attribute type.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user content attribute was added successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BoolModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/remove-watching/{assetOrContentId}": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Removes a video from the user's or profile's continue watching list.",
        "description": "\r\n<b>Behavior:</b> Marks the specified content item as hidden in the user's video tracking data,\r\n            removing it from the continue watching list. Accepts either an asset ID or a content ID;\r\n            if a content ID is provided, the main video asset is resolved automatically.\r\n            An optional profile ID can be provided for multi-profile scenarios.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a \"Hide\" tracking event for the specified content.\r\n\r\n<b>Error Scenarios:</b> If the content is not found in the search index, no tracking event is created.",
        "parameters": [
          {
            "name": "assetOrContentId",
            "in": "path",
            "description": "The unique identifier of the asset or content item to remove from the watching list.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "profileId",
            "in": "query",
            "description": "Optional profile identifier for multi-profile users.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The item was removed from the continue watching list.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/userContentAttribute/remove": {
      "post": {
        "tags": [
          "Portal"
        ],
        "summary": "Removes a user content attribute (e.g., favorite, like, bookmark) for the current user.",
        "description": "\r\n<b>Behavior:</b> Removes the specified content attribute association for the current user.\r\n            This reverses a previously added attribute such as a favorite or bookmark.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes the user content attribute record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the model is null.",
        "requestBody": {
          "description": "The user content attribute to remove, including the content ID and attribute type.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentAttributeModel"
                  }
                ],
                "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user content attribute was removed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "The model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/profile/{name}": {
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Gets or creates a user profile by name or external ID.",
        "description": "\r\n<b>Behavior:</b> Looks up an existing profile by the provided name or external ID.\r\n            If no matching profile exists, a new one is created automatically.\r\n            Profiles are used for multi-profile scenarios such as parental controls or personalized recommendations.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> May create a new profile record if one does not already exist.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The name or external identifier of the profile.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The profile was retrieved or created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/portal/profile/{name}/{sourceId}": {
      "get": {
        "tags": [
          "Portal"
        ],
        "summary": "Gets or creates a user profile by name and source system ID.",
        "description": "\r\n<b>Behavior:</b> Looks up an existing profile by the provided name and source system ID.\r\n            If no matching profile exists, a new one is created automatically.\r\n            The source ID identifies the external system that owns or tracks this profile,\r\n            allowing multiple external systems to maintain separate profile namespaces.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> May create a new profile record if one does not already exist.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The name or external identifier of the profile.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sourceId",
            "in": "path",
            "description": "The unique identifier of the external system that tracks this profile.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The profile was retrieved or created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/recommendation/index-assets": {
      "post": {
        "tags": [
          "Recommendation"
        ],
        "summary": "Indexes all media assets into the recommendation engine.",
        "description": "\r\n<b>Behavior:</b> Triggers a full indexing of all media assets into the recommendation engine, making them available for personalized recommendations.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> All media assets are indexed or re-indexed in the recommendation engine. This may be a long-running operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the request is invalid. Returns 500 if the indexing process fails.",
        "responses": {
          "200": {
            "description": "The assets were successfully indexed."
          },
          "204": {
            "description": "No content to index."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred during indexing."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/recommendation/index-content": {
      "post": {
        "tags": [
          "Recommendation"
        ],
        "summary": "Indexes all media content into the recommendation engine.",
        "description": "\r\n<b>Behavior:</b> Triggers a full indexing of all media content into the recommendation engine, making it available for personalized recommendations.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> All media content is indexed or re-indexed in the recommendation engine. This may be a long-running operation.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the request is invalid. Returns 500 if the indexing process fails.",
        "responses": {
          "200": {
            "description": "The content was successfully indexed."
          },
          "204": {
            "description": "No content to index."
          },
          "400": {
            "description": "Bad request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred during indexing."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/recommendation/interaction": {
      "post": {
        "tags": [
          "Recommendation"
        ],
        "summary": "Submits a user interaction event to the recommendation engine.",
        "description": "\r\n<b>Behavior:</b> Records a user interaction (such as a view, click, or like) with a specific content item to improve personalized recommendations.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The user interaction is recorded in the recommendation engine, which may influence future recommendations for this user.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the action or ID parameters are invalid. Returns 500 if the interaction submission fails.",
        "parameters": [
          {
            "name": "action",
            "in": "query",
            "description": "The type of recommendation action being performed.\n\n0 = Click\n\n1 = Play\n\n2 = Watch\n\n3 = Bookmark\n\n4 = Preview\n\n5 = Purchase\n\n6 = Like\n\n7 = Dislike",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecommendationActions"
                }
              ],
              "x-enumNames": [
                "Click",
                "Play",
                "Watch",
                "Bookmark",
                "Preview",
                "Purchase",
                "Like",
                "Dislike"
              ]
            },
            "x-enumNames": [
              "Click",
              "Play",
              "Watch",
              "Bookmark",
              "Preview",
              "Purchase",
              "Like",
              "Dislike"
            ]
          },
          {
            "name": "id",
            "in": "query",
            "description": "The unique identifier of the content item the user interacted with.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The interaction was successfully recorded."
          },
          "204": {
            "description": "No content."
          },
          "400": {
            "description": "Bad request due to invalid action or ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/recommendation/delete-item/{id}": {
      "delete": {
        "tags": [
          "Recommendation"
        ],
        "summary": "Deletes a content item from the recommendation engine index.",
        "description": "\r\n<b>Behavior:</b> Removes the specified content item from the recommendation engine index so it will no longer appear in recommendations.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (method-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The content item is removed from the recommendation engine index. It will no longer be included in personalized recommendations.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 400 if the ID is invalid. Returns 500 if the deletion fails.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content item to remove from the recommendation index.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The item was successfully deleted from the recommendation index."
          },
          "204": {
            "description": "No content."
          },
          "400": {
            "description": "Bad request due to invalid ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/roku/feed": {
      "get": {
        "tags": [
          "Roku"
        ],
        "summary": "Retrieves the Roku Direct Publisher feed.",
        "description": "\r\n<b>Behavior:</b> Generates and returns the complete Roku Direct Publisher feed model, which contains all the content data structured for Roku channel consumption.\r\n\r\n<b>Authorization:</b> No authentication required. This endpoint is publicly accessible for Roku device consumption.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 500 if an error occurs during feed generation.",
        "responses": {
          "200": {
            "description": "The Roku feed was successfully generated and returned.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DirectPublisherFeedModel"
                }
              }
            }
          },
          "500": {
            "description": "An unknown error occurred during feed generation."
          }
        }
      }
    },
    "/share/{shareId}": {
      "get": {
        "tags": [
          "Share"
        ],
        "summary": "Retrieves a share by its identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the share model for the specified identifier.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no share exists with the specified ID.",
        "parameters": [
          {
            "name": "shareId",
            "in": "path",
            "description": "The unique identifier of the share to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The share was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No share found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Share"
        ],
        "summary": "Updates an existing share.",
        "description": "\r\n<b>Behavior:</b> Updates the share identified by the route ID with the values\r\n            from the update model. Invalidates the share cache after the update.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the share record and invalidates the share cache.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the update model is null.\r\n            Returns 404 if the share does not exist.",
        "parameters": [
          {
            "name": "shareId",
            "in": "path",
            "description": "The unique identifier of the share to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The share update model with new values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareUpdateModel"
                  }
                ],
                "description": "Represents the input model for updating an existing share."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareUpdateModel"
                  }
                ],
                "description": "Represents the input model for updating an existing share."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareUpdateModel"
                  }
                ],
                "description": "Represents the input model for updating an existing share."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareUpdateModel"
                  }
                ],
                "description": "Represents the input model for updating an existing share."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareUpdateModel"
                  }
                ],
                "description": "Represents the input model for updating an existing share."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareUpdateModel"
                  }
                ],
                "description": "Represents the input model for updating an existing share."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareUpdateModel"
                  }
                ],
                "description": "Represents the input model for updating an existing share."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The share was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareModel"
                }
              }
            }
          },
          "400": {
            "description": "The share update model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No share found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Share"
        ],
        "summary": "Deletes a share.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the share identified by the specified ID\r\n            and invalidates the share cache.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes the share record and invalidates the share cache.",
        "parameters": [
          {
            "name": "shareId",
            "in": "path",
            "description": "The unique identifier of the share to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The share was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/share": {
      "post": {
        "tags": [
          "Share"
        ],
        "summary": "Creates a new share.",
        "description": "\r\n<b>Behavior:</b> Creates a new share record using the provided add model and returns\r\n            the created share.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a new share record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the add model is null.\r\n            Returns 404 if the share could not be created.",
        "requestBody": {
          "description": "The share creation model.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareAddModel"
                  }
                ],
                "description": "Represents the input model for creating a new share."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareAddModel"
                  }
                ],
                "description": "Represents the input model for creating a new share."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareAddModel"
                  }
                ],
                "description": "Represents the input model for creating a new share."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareAddModel"
                  }
                ],
                "description": "Represents the input model for creating a new share."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareAddModel"
                  }
                ],
                "description": "Represents the input model for creating a new share."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareAddModel"
                  }
                ],
                "description": "Represents the input model for creating a new share."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareAddModel"
                  }
                ],
                "description": "Represents the input model for creating a new share."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The share was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareModel"
                }
              }
            }
          },
          "400": {
            "description": "The share add model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The share could not be created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/share/{shareId}/notification": {
      "post": {
        "tags": [
          "Share"
        ],
        "summary": "Creates a share notification.",
        "description": "\r\n<b>Behavior:</b> Sends a notification for the specified share, such as an email\r\n            notification to intended recipients.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Sends a notification (e.g., email) to the share recipients.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the notification model is null.",
        "parameters": [
          {
            "name": "shareId",
            "in": "path",
            "description": "The unique identifier of the share to notify about.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The notification configuration model.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareNotificationModel"
                  }
                ],
                "description": "Represents the input model for sending a share notification to recipients."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareNotificationModel"
                  }
                ],
                "description": "Represents the input model for sending a share notification to recipients."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareNotificationModel"
                  }
                ],
                "description": "Represents the input model for sending a share notification to recipients."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareNotificationModel"
                  }
                ],
                "description": "Represents the input model for sending a share notification to recipients."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareNotificationModel"
                  }
                ],
                "description": "Represents the input model for sending a share notification to recipients."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareNotificationModel"
                  }
                ],
                "description": "Represents the input model for sending a share notification to recipients."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareNotificationModel"
                  }
                ],
                "description": "Represents the input model for sending a share notification to recipients."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The notification was sent successfully."
          },
          "400": {
            "description": "The notification model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/share/expire/{shareId}": {
      "post": {
        "tags": [
          "Share"
        ],
        "summary": "Force-expires one or all shares.",
        "description": "\r\n<b>Behavior:</b> Forces the expiration of the specified share, or all shares if no ID\r\n            is provided. Invalidates the share cache after expiration.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Marks the share(s) as expired and invalidates the share cache.",
        "parameters": [
          {
            "name": "shareId",
            "in": "path",
            "description": "Optional share ID. If null, expires all shares.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The share(s) were expired successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/stage/auth": {
      "post": {
        "tags": [
          "Stage"
        ],
        "summary": "Authenticates a user using a token and identifier for stage access.",
        "description": "\r\n<b>Behavior:</b> Validates the provided authentication token and identifier against the stage system. The token is normally supplied by the calling system as the unique identifier of the experience, and the token is the temporary authentication credential for the user. Returns 404 if validation fails.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> A stage session may be created or updated for the authenticated user.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if the token validation fails or the user cannot be found.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Security.AuthTokenRequestModel containing the token and identifier for authentication.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user was successfully authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StageLoginResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The token validation failed or the user was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/stage/ping/{id}": {
      "get": {
        "tags": [
          "Stage"
        ],
        "summary": "Sends a ping to indicate the client is still connected to the stage session.",
        "description": "\r\n<b>Behavior:</b> Pings the server to tell it that the client is still connected. The userSessionId normally comes from the Login or AuthToken command. Optionally updates the user's screen name. Returns 404 if the session is not found.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The session's last activity timestamp is updated. The user's screen name may be updated if the sn parameter is provided.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the user is not authenticated. Returns 404 if the session ID is not found or has expired.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The user session ID of the logged-in user, typically obtained from the Login or AuthToken command.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "sn",
            "in": "query",
            "description": "The latest screen name of the user (optional).",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The ping was successfully processed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StagePingResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request was invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The session ID was not found or has expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/stage/start-session": {
      "post": {
        "tags": [
          "Stage"
        ],
        "summary": "Starts a new stage session for the authenticated user.",
        "description": "\r\n<b>Behavior:</b> Initiates a new stage session using the provided authentication token and identifier. The token is normally supplied by the calling system as the unique identifier of the experience. Returns 404 if the session cannot be started.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> A new stage session is created for the authenticated user.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Returns 401 if the user is not authenticated. Returns 404 if the session could not be started.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Security.AuthTokenRequestModel containing the token and identifier for session creation.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The session was successfully started.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StageLoginResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The session could not be started or the user was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/stage/verify-session": {
      "post": {
        "tags": [
          "Stage"
        ],
        "summary": "Verifies an existing stage session is still valid.",
        "description": "\r\n<b>Behavior:</b> Validates that the specified stage session is still active and valid using the provided authentication token and identifier. Returns 404 if the session is invalid or expired.\r\n\r\n<b>Authorization:</b> Requires an authenticated user (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> The session validity is checked but the session state may be updated as part of verification.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Returns 401 if the user is not authenticated. Returns 404 if the session is invalid or has expired.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Security.AuthTokenRequestModel containing the token and identifier for session verification.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AuthTokenRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The session was successfully verified.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StageLoginResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The session is invalid or has expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/all": {
      "get": {
        "tags": [
          "Statistics"
        ],
        "summary": "Retrieves all statistics records.",
        "description": "\r\n<b>Behavior:</b> Returns a complete list of all statistics records in the system without any date filtering.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the statistics retrieval fails.",
        "responses": {
          "200": {
            "description": "Statistics records retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StatisticsListModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "An error occurred while retrieving statistics.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/date-range": {
      "get": {
        "tags": [
          "Statistics"
        ],
        "summary": "Retrieves statistics records within a specified date range.",
        "description": "\r\n<b>Behavior:</b> Returns statistics records filtered by the specified date range (inclusive of fromDate and toDate).\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the date range is invalid or the statistics retrieval fails.",
        "parameters": [
          {
            "name": "fromDate",
            "in": "query",
            "description": "The start date of the range to query statistics for.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "toDate",
            "in": "query",
            "description": "The end date of the range to query statistics for.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Statistics records for the date range retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StatisticsListModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The date range is invalid or an error occurred while retrieving statistics.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/measurements/config": {
      "get": {
        "tags": [
          "Statistics"
        ],
        "summary": "Gets statistics measurement config data.",
        "description": "\r\n<b>Behavior:</b> Retrieves the configuration for available statistics measurements including measurement types, available periods, and display options.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the configuration retrieval fails.",
        "responses": {
          "200": {
            "description": "Statistics measurement configuration retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatisticsConfigResultModel"
                }
              }
            }
          },
          "400": {
            "description": "An error occurred while retrieving the measurement configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/measurements": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Lists statistics measurement data from search indexes over the specified period.",
        "description": "\r\n<b>Behavior:</b> Queries the search indexes for measurement data matching the specified period and measurement types in the request model, and returns the results as graph-ready data.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request model is invalid or the measurement retrieval fails.",
        "requestBody": {
          "description": "A model containing period and measurements to retrieve.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statistics measurements retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StatisiticsDataGraph"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request model is invalid or an error occurred while retrieving measurements.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/measurements/rollup": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Restores measurement statistics by loading available rollup snapshot data from S3 into the search index.",
        "description": "\r\n<b>Behavior:</b> Reads rollup snapshot files from S3 and loads the measurement data into the search index. This is used to restore or rebuild measurement statistics from previously generated snapshots.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Modifies the search index by loading measurement data from S3 rollup snapshots. Existing measurement data in the index may be overwritten.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the rollup snapshot restoration fails or no snapshots are available.",
        "responses": {
          "200": {
            "description": "Rollup snapshots were successfully restored into the search index."
          },
          "400": {
            "description": "An error occurred while restoring rollup snapshots.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Statistics"
        ],
        "summary": "Generates rollup snapshot data for the specified date and stores it in S3.",
        "description": "\r\n<b>Behavior:</b> Generates rollup measurement snapshots for the specified date (or the current date if not provided) and stores them in S3. These snapshots can later be restored using the POST measurements/rollup endpoint.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates or overwrites rollup snapshot files in S3 for the specified date.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the snapshot generation fails.",
        "parameters": [
          {
            "name": "snapshotDate",
            "in": "query",
            "description": "The date of rollups snapshot to generate. If null, defaults to the current date.",
            "schema": {
              "type": "string",
              "format": "date"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Rollup snapshots were successfully generated."
          },
          "400": {
            "description": "An error occurred while generating rollup snapshots.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/exportjournal": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Exports statistics journal entries for the specified date range as an Excel file.",
        "description": "\r\n<b>Behavior:</b> Exports journal entries for the specified date range. When background is true (default), the export is queued as a batch action for asynchronous processing. When background is false, the export runs synchronously and returns the Excel file directly. If no data is available, returns 204 No Content.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> When background is true, queues a batch export job. When background is false, generates an Excel file in memory.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the export date is invalid or the export process fails. Returns 204 if no journal data exists for the specified date range.",
        "parameters": [
          {
            "name": "exportDate",
            "in": "query",
            "description": "The start date for the journal export.",
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "exportEndDate",
            "in": "query",
            "description": "The optional end date for the journal export. If null, only the export date is used.",
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "background",
            "in": "query",
            "description": "When true, the export runs as a background batch job. When false, the export runs synchronously and returns the file. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The journal export was completed and the file is returned (synchronous mode only)."
          },
          "204": {
            "description": "The export was queued as a background job or no data exists for the specified date range."
          },
          "400": {
            "description": "The export date is invalid or an error occurred during the export.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/generate-statistics": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Generates the system statistics for the environment.",
        "description": "\r\n<b>Behavior:</b> Triggers generation of system-level statistics. When forceReload is true, statistics are regenerated even if they already exist for the current period.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute. Additionally, the user must be an admin (checked via IsAdminUser).\r\n\r\n<b>Side Effects:</b> Generates and persists system statistics records. When forceReload is true, existing statistics may be overwritten.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the user is not an admin or the statistics generation fails. Throws a VibrantException if the user lacks admin permissions.",
        "parameters": [
          {
            "name": "forceReload",
            "in": "query",
            "description": "When true, forces statistics to regenerate even if they already exist for the current period.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Statistics were successfully generated.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "The user lacks admin permissions or statistics generation failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/user-session/{id}": {
      "get": {
        "tags": [
          "UserSession"
        ],
        "summary": "Get all active user sessions, offline shared-access users, and pending invitations for a live channel.",
        "description": "\r\n<b>Behavior:</b> Returns the list of users associated with a live channel, organized into two groups:\r\n            Items contains currently online users with active sessions, and RelatedItems contains offline shared-access\r\n            users (with \" (offline)\" suffix on LastName) and users with pending invitations.\r\n            Currently only supports live channel content definitions — other content types return an empty result.\r\n            The authenticated user is always included in the online results.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns an empty result if the id does not match a supported live channel content definition. Returns 404 if the session data cannot be retrieved.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Optional. Must be the LiveChannelContentDefinitionId (LVEP) to return results. Can also be a UserSessionId, UserId, ContentId, or ContentDefinitionId but only LVEP is currently supported.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the session list. Items = online users, RelatedItems = offline + pending users.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserSessionModelListResultModel"
                }
              }
            }
          },
          "404": {
            "description": "Session data could not be retrieved.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AccountLoginResponseModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the authenticated user.",
            "format": "uuid"
          },
          "userName": {
            "type": "string",
            "description": "Gets or sets the username (email address) of the authenticated user.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the authenticated user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the authenticated user.",
            "nullable": true
          },
          "loginStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LoginResponseStatuses"
              }
            ],
            "description": "Gets or sets the login status indicating the result of the authentication attempt.\r\nA null value typically indicates success. Non-null values indicate a specific condition\r\n(e.g., IsDisabled, RequiresNewPassword, IsPendingEmailConfirmation).\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
            "nullable": true
          },
          "cookies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LoginCookieModel"
            },
            "description": "Gets or sets the list of cookies to be set on the client after a successful login.",
            "nullable": true
          },
          "token": {
            "type": "string",
            "description": "Gets or sets the JWT access token. Include this in the Authorization header of all API requests, prefixed with \"Bearer \".",
            "nullable": true
          },
          "refreshToken": {
            "type": "string",
            "description": "Gets or sets the refresh token. Use this to obtain a new access token when the current one expires.",
            "nullable": true
          },
          "expirationSeconds": {
            "type": "number",
            "description": "Gets or sets the duration in seconds until the access token expires.",
            "format": "double"
          },
          "scopeId": {
            "type": "string",
            "description": "Gets or sets the scope identifier, if applicable.",
            "format": "uuid",
            "nullable": true
          },
          "scopeName": {
            "type": "string",
            "description": "Gets or sets the scope name, if applicable.",
            "nullable": true
          },
          "twoFactorQRCodeImage": {
            "type": "string",
            "description": "Gets or sets the base64-encoded QR code image for two-factor authentication setup, if required.",
            "nullable": true
          },
          "twoFactorQRCode": {
            "type": "string",
            "description": "Gets or sets the two-factor authentication secret code for manual entry, if required.",
            "nullable": true
          },
          "claims": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Claim"
            },
            "description": "Gets or sets the list of claims associated with the authenticated user's token.",
            "nullable": true
          },
          "isAdmin": {
            "type": "boolean",
            "description": "Gets or sets whether the user has system administrator privileges.",
            "nullable": true
          },
          "isGuest": {
            "type": "boolean",
            "description": "Gets or sets whether the user is a guest user with limited access.",
            "nullable": true
          },
          "userSessionId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the session created by this login. Use this for session ping and logout.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AdBreakModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the ID of the ad break",
            "format": "uuid"
          },
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the timecode of the ad break in the format of hh:mm:ss:ff",
            "nullable": true
          },
          "score": {
            "type": "number",
            "description": "Gets or sets the calculated score of the ad break from the AI analysis. The higher the better.",
            "format": "double",
            "nullable": true
          },
          "adBreakType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AdSlotTypes"
              }
            ],
            "description": "Gets or sets the type of the ad break (pre-roll, post-roll, mid-roll)\n\nPreroll\n\nMidroll\n\nPostroll",
            "x-enumNames": [
              "Preroll",
              "Midroll",
              "Postroll"
            ]
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags that are targeted with this ad break",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of labels that are targeted with this ad break",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an ad break marker within a media asset, defining the insertion point, type, and targeting criteria."
      },
      "AdSlotTypes": {
        "enum": [
          "Preroll",
          "Midroll",
          "Postroll"
        ],
        "type": "string",
        "description": "\n\nPreroll\n\nMidroll\n\nPostroll",
        "x-enumNames": [
          "Preroll",
          "Midroll",
          "Postroll"
        ]
      },
      "AddAnnotationModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the annotation; if null, a new identifier will be generated.",
            "format": "uuid",
            "nullable": true
          },
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation begins.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation ends.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of custom properties associated with the annotation.",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the content identifier used internally for processing.",
            "format": "uuid"
          },
          "imageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the image associated with the annotation, used internally for processing.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
      },
      "AddDownloadQueueModel": {
        "type": "object",
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of asset identifiers to add to the download queue.",
            "nullable": true
          },
          "downloadProxy": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to download the lower-resolution proxy version of the assets."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
      },
      "AnnotationModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the annotation.",
            "format": "uuid"
          },
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation begins.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation ends.",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the image associated with the annotation.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of custom properties associated with the annotation.",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the content identifier used internally for processing.",
            "format": "uuid"
          }
        },
        "additionalProperties": false,
        "description": "Represents an annotation on a media asset, including its time range, image reference, and custom properties."
      },
      "AssetDetailModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the asset.",
            "format": "uuid"
          },
          "permission": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityPermissions"
              }
            ],
            "description": "Gets or sets the permission level the current user has for this asset.\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
            "nullable": true
          },
          "isRestricted": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether access to this asset is restricted.",
            "nullable": true
          },
          "isShared": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether this asset has been shared with others.",
            "nullable": true
          },
          "inheritSecurity": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether this asset inherits security settings from its parent."
          },
          "relatedAudio": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of related audio assets associated with this asset.",
            "nullable": true
          },
          "relatedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of general related assets associated with this asset.",
            "nullable": true
          },
          "relatedVideos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of related video assets associated with this asset.",
            "nullable": true
          },
          "relatedImages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of related image assets associated with this asset.",
            "nullable": true
          },
          "relatedContentGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content groups associated with this asset.",
            "nullable": true
          },
          "screenshots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of screenshot references captured from this asset.",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LabelModel"
            },
            "description": "Gets or sets the list of labels applied to this asset for categorization.",
            "nullable": true
          },
          "faceItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FaceModel"
            },
            "description": "Gets or sets the list of detected faces within this asset.",
            "nullable": true
          },
          "persons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PersonReferenceModel"
            },
            "description": "Gets or sets the list of identified persons associated with this asset.",
            "nullable": true
          },
          "textItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextItemGroupModel"
            },
            "description": "Gets or sets the list of detected text item groups within this asset.",
            "nullable": true
          },
          "availability": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AvailabilityModel"
            },
            "description": "Gets or sets the list of availability windows that define when this asset is accessible.",
            "nullable": true
          },
          "geoData": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoData"
              }
            ],
            "description": "Gets or sets the geographic location data associated with this asset.",
            "nullable": true
          },
          "parents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetModel"
            },
            "description": "Gets or sets the list of parent folder assets that contain this asset.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of collections this asset belongs to.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags assigned to this asset.",
            "nullable": true
          },
          "shares": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of shares this asset is included in.",
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of security groups that have access to this asset.",
            "nullable": true
          },
          "securityUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of individual users that have access to this asset.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content items linked to this asset.",
            "nullable": true
          },
          "assetStats": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetStatsModel"
              }
            ],
            "description": "Gets or sets the usage and engagement statistics for this asset.",
            "nullable": true
          },
          "textCaptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextCaptionModel"
            },
            "description": "Gets or sets the list of text captions or subtitles associated with this asset.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of system-level properties for this asset.",
            "nullable": true
          },
          "customAttributes": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of user-defined custom attributes for this asset.",
            "nullable": true
          },
          "attributeSummary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserContentAttributeSummaryModel"
              }
            ],
            "description": "Gets or sets the summary of content attribute definitions available for this asset.",
            "nullable": true
          },
          "highlights": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VideoHighlightModel"
            },
            "description": "Gets or sets the list of video highlights or bookmarked moments within this asset.",
            "nullable": true
          },
          "chapters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VideoHighlightModel"
            },
            "description": "Gets or sets the list of chapters defining segments within this asset.",
            "nullable": true
          },
          "adBreaks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdBreakModel"
            },
            "description": "Gets or sets the list of ad break markers within this asset.",
            "nullable": true
          },
          "audioTracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AudioTrackModel"
            },
            "description": "Gets or sets the list of audio tracks available for this asset.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the full detail view of an asset, including metadata, relationships, security settings, and associated content."
      },
      "AssetDownloadModel": {
        "type": "object",
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of asset identifiers to include in the download.",
            "nullable": true
          },
          "filename": {
            "type": "string",
            "description": "Gets or sets the desired filename for the download output.",
            "nullable": true
          },
          "downloadProxy": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to download the lower-resolution proxy version of the assets."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to download one or more assets, optionally packaged into a single file."
      },
      "AssetModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the asset.",
            "format": "uuid"
          },
          "parentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the parent folder that contains this asset.",
            "format": "uuid",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "Gets or sets the user-friendly display name of the asset.",
            "nullable": true
          },
          "displayDate": {
            "type": "string",
            "description": "Gets or sets the display date associated with the asset.",
            "format": "date-time",
            "nullable": true
          },
          "bucketName": {
            "type": "string",
            "description": "Gets or sets the name of the storage bucket where the asset resides.",
            "nullable": true
          },
          "objectKey": {
            "type": "string",
            "description": "Gets or sets the storage object key that identifies the asset within its bucket.",
            "nullable": true
          },
          "fullUrl": {
            "type": "string",
            "description": "Gets or sets the fully qualified URL for accessing the asset.",
            "nullable": true
          },
          "assetStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetStatuses"
              }
            ],
            "description": "Gets or sets the current processing or lifecycle status of the asset.\n\nAvailable\n\nRenaming\n\nCopying\n\nRestoring\n\nRegistering\n\nUploading\n\nArchiving\n\nArchived\n\nPendingArchive\n\nPendingRestore\n\nRestored\n\nDeleting\n\nMoving\n\nSlugReplaced\n\nUpdating\n\nError\n\nAssembling\n\nClipping\n\nPlaceholder\n\nCreating\n\nReplacing",
            "nullable": true
          },
          "storageClass": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StorageClasses"
              }
            ],
            "description": "Gets or sets the storage class tier for the asset.\n\nStandard\n\nReducedRedundancy\n\nGlacier\n\nStandardInfrequentAccess\n\nOneZoneInfrequentAccess\n\nIntelligentTiering\n\nDeepArchive\n\nGlacierInstantRetrieval\n\nOutposts",
            "nullable": true
          },
          "assetType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetTypes"
              }
            ],
            "description": "Gets or sets the type classification of the asset (e.g., video, image, audio, document).\n\nFolder\n\nFile\n\nBucket",
            "x-enumNames": [
              "Folder",
              "File",
              "Bucket"
            ]
          }
        },
        "additionalProperties": false,
        "description": "Represents a summary view of an asset, including its identity, location, and current status."
      },
      "AssetPartUploadModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the ID of this specific part",
            "format": "uuid"
          },
          "url": {
            "type": "string",
            "description": "Gets or sets the URL that can be used to upload TO. This is meant to be a partial file upload location and will expire.",
            "nullable": true
          },
          "partNumber": {
            "type": "integer",
            "description": "Gets or sets the # of the part being uploaded",
            "format": "int32"
          },
          "startingPosition": {
            "type": "integer",
            "description": "Gets or sets the starting byte of the upload chunk for this part",
            "format": "int64"
          },
          "endingPosition": {
            "type": "integer",
            "description": "Gets or sets the ending byte of the upload chunk for this part",
            "format": "int64"
          },
          "isCompleted": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether if the part has already been uploaded"
          }
        },
        "additionalProperties": false,
        "description": "Represents a single part within a multipart upload, including its upload URL and byte range."
      },
      "AssetReferenceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "jobId": {
            "type": "string",
            "nullable": true
          },
          "url": {
            "type": "string",
            "nullable": true
          },
          "fullUrl": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "language": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LanguageModel"
              }
            ],
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "nullable": true
          },
          "metadataTypeDisplay": {
            "type": "string",
            "nullable": true
          },
          "mediaType": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "mediaTypeDisplay": {
            "type": "string",
            "nullable": true
          },
          "format": {
            "type": "string",
            "nullable": true
          },
          "templateName": {
            "type": "string",
            "nullable": true
          },
          "videoDuration": {
            "type": "string",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "isUrlSecure": {
            "type": "boolean",
            "nullable": true
          },
          "hasAds": {
            "type": "boolean",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "AssetStatsModel": {
        "type": "object",
        "properties": {
          "mediaTypeCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "assetTypeCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "assetStatusCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "storageClassCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "totalContentLength": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "totalContentLengthDisplay": {
            "type": "string",
            "nullable": true
          },
          "totalVideoDuration": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "totalVideoDurationDisplay": {
            "type": "string",
            "nullable": true
          },
          "totalAudioDuration": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "totalAudioDurationDisplay": {
            "type": "string",
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AssetStatuses": {
        "enum": [
          "Available",
          "Renaming",
          "Copying",
          "Restoring",
          "Registering",
          "Uploading",
          "Archiving",
          "Archived",
          "PendingArchive",
          "PendingRestore",
          "Restored",
          "Deleting",
          "Moving",
          "SlugReplaced",
          "Updating",
          "Error",
          "Assembling",
          "Clipping",
          "Placeholder",
          "Creating",
          "Replacing"
        ],
        "type": "string",
        "description": "Indicates the current processing or lifecycle status of an asset.\r\nAn asset transitions through various statuses during operations such as upload, archive, restore, and delete.\n\nAvailable\n\nRenaming\n\nCopying\n\nRestoring\n\nRegistering\n\nUploading\n\nArchiving\n\nArchived\n\nPendingArchive\n\nPendingRestore\n\nRestored\n\nDeleting\n\nMoving\n\nSlugReplaced\n\nUpdating\n\nError\n\nAssembling\n\nClipping\n\nPlaceholder\n\nCreating\n\nReplacing",
        "x-enumNames": [
          "Available",
          "Renaming",
          "Copying",
          "Restoring",
          "Registering",
          "Uploading",
          "Archiving",
          "Archived",
          "PendingArchive",
          "PendingRestore",
          "Restored",
          "Deleting",
          "Moving",
          "SlugReplaced",
          "Updating",
          "Error",
          "Assembling",
          "Clipping",
          "Placeholder",
          "Creating",
          "Replacing"
        ]
      },
      "AssetTransferStatuses": {
        "enum": [
          "Queued",
          "Downloading",
          "Uploading",
          "Error",
          "Complete",
          "Cancelled"
        ],
        "type": "string",
        "description": "\n\nQueued\n\nDownloading\n\nUploading\n\nError\n\nComplete\n\nCancelled",
        "x-enumNames": [
          "Queued",
          "Downloading",
          "Uploading",
          "Error",
          "Complete",
          "Cancelled"
        ]
      },
      "AssetTypes": {
        "enum": [
          "Folder",
          "File",
          "Bucket"
        ],
        "type": "string",
        "description": "Categorizes the type of an asset in the media library.\n\nFolder\n\nFile\n\nBucket",
        "x-enumNames": [
          "Folder",
          "File",
          "Bucket"
        ]
      },
      "AssetUploadCompletePartRequestModel": {
        "type": "object",
        "properties": {
          "etag": {
            "type": "string",
            "description": "Gets or sets the etag that was returned from the client upload",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
      },
      "AssetUploadModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the ID of the upload",
            "format": "uuid"
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the Asset ID where the upload will become",
            "format": "uuid"
          },
          "etag": {
            "type": "string",
            "description": "Gets or sets determines if the asset has been uploaded. If it has, the etag is there, else null.",
            "nullable": true
          },
          "url": {
            "type": "string",
            "description": "Gets or sets the URL of the upload",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "description": "Gets or sets the size of the file",
            "format": "int64"
          },
          "startDate": {
            "type": "string",
            "description": "Gets or sets the date the original upload was started",
            "format": "date-time"
          },
          "parts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetPartUploadModel"
            },
            "description": "Gets or sets the collection of individual upload parts that make up this multipart upload.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an active or completed asset upload session, including progress and part details."
      },
      "AssetUploadStartRequestModel": {
        "type": "object",
        "properties": {
          "existingAssetId": {
            "type": "string",
            "description": "Gets or sets the Existing AssetId (file) that should be overwritten with this upload.\r\nNote that by specifying this attribute then the parentId, relativePath and displayName are all ignored.",
            "format": "uuid",
            "nullable": true
          },
          "relatedContentId": {
            "type": "string",
            "description": "Gets or sets the Content ID of the related content record to associate this asset to.\r\nNote that by specifying this attribute then the parentId and relativePath attributes are both ignored.",
            "format": "uuid",
            "nullable": true
          },
          "parentId": {
            "type": "string",
            "description": "Gets or sets the Parent AssetId (folder) to add the upload to. Note that if there is a full relativePath, then it is appended to this parent path. If this value is omitted then the file will be added to the predefined incoming folder.\r\nThis is ignored if the ExistingAssetId or if the RelatedContentId has a value",
            "format": "uuid",
            "nullable": true
          },
          "relativePath": {
            "type": "string",
            "description": "Gets or sets the filename to upload - or a full path with the filename at the end.\r\nThis is ignored if the ExistingAssetId or if the RelatedContentId has a value",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "description": "Gets or sets the language of the asset to upload. If this is left blank then the default system language is used.",
            "format": "uuid",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "Gets or sets the display name of the file to upload (does not include the path) and must include the file extension\r\nThis is ignored if the ExistingAssetId has a value",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "description": "Gets or sets the size of the asset to upload. This is used to calculate the upload parts.",
            "format": "int64"
          },
          "chunkSize": {
            "type": "integer",
            "description": "Gets or sets the size of the upload chunks. This should be adjusted to optimize the upload size based on the user's internet connection.",
            "format": "int64"
          },
          "uploadOverwriteOption": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UploadOverwriteOptions"
              }
            ],
            "description": "Gets or sets if the file already exists on the server, this decides how to handle the situation\n\nCancel\n\nContinue\n\nReplace\n\nAssetReplace",
            "x-enumNames": [
              "Cancel",
              "Continue",
              "Replace",
              "AssetReplace"
            ]
          },
          "uploadReplaceOptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UploadReplaceOptions"
            },
            "description": "Gets or sets if the asset already exists on the server, this decides how to handle the situation with related assets.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties for the uploaded file",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
      },
      "AudioTrackModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "bitRate": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "samplingRate": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "numChannels": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "format": {
            "type": "string",
            "nullable": true
          },
          "frameRate": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "frameCount": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "bitDepth": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "bitRateMode": {
            "type": "string",
            "nullable": true
          },
          "durationSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "language": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LanguageModel"
              }
            ],
            "nullable": true
          },
          "trackPosition": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "inputTracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AudioTrackModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AuthProviderModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "priority": {
            "type": "integer",
            "format": "int32"
          },
          "visible": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AuthTokenRequestModel": {
        "required": [
          "identifier",
          "token"
        ],
        "type": "object",
        "properties": {
          "token": {
            "minLength": 1,
            "type": "string"
          },
          "identifier": {
            "minLength": 1,
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "AvailabilityModel": {
        "type": "object",
        "properties": {
          "availableStartDate": {
            "type": "string",
            "description": "Gets or sets the availability starting date of the asset for entitlement purposes.",
            "format": "date-time",
            "nullable": true
          },
          "availableEndDate": {
            "type": "string",
            "description": "Gets or sets the availability ending date of the asset for entitlement purposes.",
            "format": "date-time",
            "nullable": true
          },
          "isInherited": {
            "type": "boolean",
            "description": "Gets or sets availability isInherited flag.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BatchResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": { },
              "description": "A dictionary-based model that extends CaseInsensitiveDictionary. Contains a primary key Id (Guid) and dynamic key-value pairs representing entity properties. Use GetProperty<T>(key) to access typed values."
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          }
        },
        "additionalProperties": false,
        "description": "Contains a list of PartialModel items representing the results of a batch operation, along with TotalItemCount indicating how many items were processed."
      },
      "BigDecimal": {
        "type": "object",
        "properties": {
          "sign": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "significantDigits": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "length": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "decimalPlaces": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "wholeValue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BigInteger"
              }
            ],
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "BigInteger": {
        "type": "object",
        "properties": {
          "isPowerOfTwo": {
            "type": "boolean",
            "readOnly": true
          },
          "isZero": {
            "type": "boolean",
            "readOnly": true
          },
          "isOne": {
            "type": "boolean",
            "readOnly": true
          },
          "isEven": {
            "type": "boolean",
            "readOnly": true
          },
          "sign": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "BoolModel": {
        "type": "object",
        "properties": {
          "val": {
            "type": "boolean"
          }
        },
        "additionalProperties": false,
        "description": "A wrapper containing a single boolean Result property indicating the outcome of an operation."
      },
      "BoundingBoxModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "format": "double"
          },
          "top": {
            "type": "number",
            "format": "double"
          },
          "left": {
            "type": "number",
            "format": "double"
          },
          "height": {
            "type": "number",
            "format": "double"
          },
          "width": {
            "type": "number",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "CaptionModel": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Gets or sets the URL of the video caption file. The URL must use the secure protocol prefix \"https://\".\r\nRequired",
            "nullable": true
          },
          "language": {
            "type": "string",
            "description": "Gets or sets a language code for the subtitle (e.g., “en”, “es-mx”, “fr”, etc).\r\nhttps://www.loc.gov/standards/iso639-2/php/code_list.php\r\nRequired",
            "nullable": true
          },
          "captionType": {
            "type": "string",
            "description": "Gets or sets the type of caption. Default is SUBTITLE. Must be one of the following:\r\n    CLOSED_CAPTION\r\n    SUBTITLE\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a single video caption file of a video content.\r\nThe supported formats are described in https://developer.roku.com/docs/developer-program/media-playback/closed-caption.md\r\nThe preferred closed caption formats are as follows:\r\n    WebVTT\r\n    SRT"
      },
      "CategoryModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the category that will show up in the channel.\r\nRequired",
            "nullable": true
          },
          "playlistName": {
            "type": "string",
            "description": "Gets or sets the name of the playlist in this feed that contains the content for this category.\r\nRequired (A category must contain either a playlistName or query field)",
            "nullable": true
          },
          "query": {
            "type": "string",
            "description": "Gets or sets the query that will specify the content for this category. It is a Boolean expression containing tags that you have provided in your content feed.\r\nThe available operators are:\r\n    AND\r\n    OR\r\n            \r\nYou cannot use both operators in the same query; however, you can use more than one in a single query.\r\nFor example, if your feed has the tags \"romance\", \"movie\", \"korean\" and \"dramas\", you could do:\r\n    movie AND korean\r\n    movie AND korean AND dramas\r\n    romance OR dramas\r\n            \r\nThe following is NOT supported:\r\n    movie AND romance OR dramas\r\n            \r\nRequired (A category must contain either a playlistName or query field)",
            "nullable": true
          },
          "order": {
            "type": "string",
            "description": "Gets or sets the order of the category. Must be one of the following:\r\n    manual: For playlists only\r\n    most_recent: reverse chronological order\r\n    chronological: the order in which the content was published(e.g., Episode 1, Episode 2, etc.)\r\n    most_popular: sort by popularity(based on Roku usage data).\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "The category object defines a new category your channel will display, and the content included in it based either on a playlist\r\nor a query containing one or multiple tags. You can also create them directly in Direct Publisher.\r\nThere are three default categories in every channel: \"Continue Watching\", \"Most Popular\", and \"Recently Added\".\r\nEach category is displayed as a separate row to end-users."
      },
      "ChangeAssetPropertiesModel": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "description": "Gets or sets the visual name of the asset for display purposes",
            "nullable": true
          },
          "displayDate": {
            "type": "string",
            "description": "Gets or sets the visual date of the asset for display purposes",
            "format": "date-time",
            "nullable": true
          },
          "availableStartDate": {
            "type": "string",
            "description": "Gets or sets the availability starting date of the asset for entitlement purposes\r\nMinValue is used to differentiate between null values and missing properties\r\nWe technically want null so we can clear the date.",
            "format": "date-time",
            "nullable": true
          },
          "availableEndDate": {
            "type": "string",
            "description": "Gets or sets the availability ending date of the asset for entitlement purposes\r\nMinValue is used to differentiate between null values and missing properties\r\nWe technically want null so we can clear the date.",
            "format": "date-time",
            "nullable": true
          },
          "customProperties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets a list of custom properties that should be saved for the asset.\r\nTo remove a property value, set the value to null.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to modify the display properties and custom attributes of an asset."
      },
      "ChangeEmailRequestModel": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Gets or sets the user's current password for verification.",
            "nullable": true
          },
          "newEmail": {
            "type": "string",
            "description": "Gets or sets the new email address to set for the user.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ChangePasswordRequestModel": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Gets or sets the user's current password for verification.",
            "nullable": true
          },
          "newPassword": {
            "type": "string",
            "description": "Gets or sets the new password to set for the user.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CheckEmailAvailabilityRequestModel": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "Gets or sets the email address to check for availability.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "Claim": {
        "type": "object",
        "properties": {
          "issuer": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "originalIssuer": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "readOnly": true
          },
          "subject": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ClaimsIdentity"
              }
            ],
            "nullable": true,
            "readOnly": true
          },
          "type": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "value": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "valueType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ClaimsIdentity": {
        "type": "object",
        "properties": {
          "authenticationType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "isAuthenticated": {
            "type": "boolean",
            "readOnly": true
          },
          "actor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ClaimsIdentity"
              }
            ],
            "nullable": true
          },
          "bootstrapContext": {
            "nullable": true
          },
          "claims": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Claim"
            },
            "nullable": true,
            "readOnly": true
          },
          "label": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "nameClaimType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "roleClaimType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ClipModel": {
        "type": "object",
        "properties": {
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the clip begins.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the clip ends.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the clip.",
            "nullable": true
          },
          "outputFolderId": {
            "type": "string",
            "description": "Gets or sets the identifier of the folder where the generated clip will be placed.",
            "format": "uuid",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags to apply to the generated clip.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of collections to assign the generated clip to.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content items to link to the generated clip.",
            "nullable": true
          },
          "internalMasterManifestUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the master manifest used for clip generation.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
      },
      "CollectionContentModel": {
        "type": "object",
        "properties": {
          "contentDefinition": {
            "type": "string",
            "description": "Gets or sets the content definition string name of the content records that should be affected\r\nLike asset, video, etc",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the ID of the content record to apply the new or removed attributes",
            "format": "uuid"
          },
          "createNew": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether defaults to False. If true, then the attribute will be added if it doesn't already exist with a matching name"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the collection that should be added or removed. If the name and the collectionId are both specified, the name is ignored.",
            "nullable": true
          },
          "collectionId": {
            "type": "string",
            "description": "Gets or sets the collection ID that should be added or removed",
            "format": "uuid",
            "nullable": true
          },
          "childId": {
            "type": "string",
            "description": "Gets the child identifier, which is the collection identifier.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "childPropertyName": {
            "type": "string",
            "description": "Gets the name of the child property used for serialization.",
            "nullable": true,
            "readOnly": true
          },
          "indexPropertyName": {
            "type": "string",
            "description": "Gets the name of the index property used in search indexing.",
            "nullable": true,
            "readOnly": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets the content definition identifier for collections.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the association between a content item and a collection, used for adding or removing content from collections."
      },
      "CollectionContentModelListModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CollectionContentModel"
            },
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ConfigLookupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ContentAttributes": {
        "enum": [
          "Undefined",
          "Liked",
          "Disliked",
          "Favorite"
        ],
        "type": "string",
        "description": "\n\nUndefined\n\nLiked\n\nDisliked\n\nFavorite",
        "x-enumNames": [
          "Undefined",
          "Liked",
          "Disliked",
          "Favorite"
        ]
      },
      "ContentCommentModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the comment.",
            "format": "uuid"
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the content item this comment is associated with.",
            "format": "uuid",
            "nullable": true
          },
          "parentId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the parent comment when this is a reply in a threaded discussion.",
            "format": "uuid",
            "nullable": true
          },
          "date": {
            "type": "string",
            "description": "Gets or sets the date and time when the comment was posted.",
            "format": "date-time"
          },
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the time code reference within video content that this comment relates to.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Gets or sets the text body of the comment.",
            "nullable": true
          },
          "user": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the user who posted the comment.",
            "nullable": true
          },
          "replies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentCommentModel"
            },
            "description": "Gets or sets the collection of reply comments in a threaded discussion.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a user comment on a content item, supporting threaded replies and optional time code references for video content."
      },
      "ContentDefinitionModel": {
        "type": "object",
        "properties": {
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "editorTemplate": {
            "type": "string",
            "nullable": true
          },
          "permission": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityPermissions"
              }
            ],
            "description": "\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
            "nullable": true
          },
          "isSystemModule": {
            "type": "boolean"
          },
          "useEditorFormOverride": {
            "type": "boolean"
          },
          "templateFolderAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentFieldModel"
            },
            "nullable": true,
            "readOnly": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          },
          "assignedSecurity": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ContentFieldModel": {
        "type": "object",
        "properties": {
          "contentFieldId": {
            "type": "string",
            "format": "uuid"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "listViewSequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "editorViewSequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "isInEditorForm": {
            "type": "boolean"
          },
          "isInContentList": {
            "type": "boolean"
          },
          "isDeleted": {
            "type": "boolean"
          },
          "isSystemField": {
            "type": "boolean"
          },
          "isReadOnly": {
            "type": "boolean"
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ContentGroupAddModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Display name of the content group.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Additional custom properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Model for creating a new content group."
      },
      "ContentGroupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier of the content group.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Display name of the content group.",
            "nullable": true
          },
          "sharedUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "The list of users this content group is shared with.",
            "nullable": true
          },
          "contents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "The list of content items (assets) in this group.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Additional custom properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a content group with its members and sharing configuration."
      },
      "ContentGroupRenameModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The new display name for the content group.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Model for renaming a content group."
      },
      "ContentLanguageStatuses": {
        "enum": [
          "Original",
          "Override",
          "Auto"
        ],
        "type": "string",
        "description": "\n\nOriginal\n\nOverride\n\nAuto",
        "x-enumNames": [
          "Original",
          "Override",
          "Auto"
        ]
      },
      "ContentModel": {
        "type": "object",
        "properties": {
          "dateAdded": {
            "type": "string",
            "description": "Gets or sets the date the video was added to the library in the ISO 8601 format: {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}+{TZ}.\r\nFor example, 2020-11-11T22:21:37+00:00.\r\nThis information is used to generate the “Recently Added” category.\r\nRequired",
            "nullable": true
          },
          "videos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VideoModel"
            },
            "description": "Gets or sets one or more video files. For non-adaptive streams, the same video may be specified with different qualities\r\nso the Roku player can choose the best one based on bandwidth.\r\nRequired",
            "nullable": true
          },
          "duration": {
            "type": "integer",
            "description": "Gets or sets runtime in seconds.\r\nRequired",
            "format": "int32"
          },
          "captions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CaptionModel"
            },
            "description": "Gets or sets supported formats are described in https://developer.roku.com/docs/developer-program/media-playback/closed-caption.md\r\nRequired for live broadcast replay",
            "nullable": true
          },
          "trickPlayFiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TrickPlayFileModel"
            },
            "description": "Gets or sets the trickplay file(s) that displays images as a user scrubs through a video, in Roku’s BIF format.\r\nTrickplay files in multiple qualities can be provided.\r\nOptional",
            "nullable": true
          },
          "language": {
            "type": "string",
            "description": "Gets or sets the language in which the video was originally produced (e.g., “en”, “en-US”, “es”, etc). ISO 639 alpha-2 or alpha-3 language code string.\r\nRequired",
            "nullable": true
          },
          "validityPeriodStart": {
            "type": "string",
            "description": "Gets or sets the date when the content should become available in ISO 8601format: {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}+{TZ}.\r\nFor example, 2020-11-11T22:21:37+00:00\r\nOptional",
            "nullable": true
          },
          "validityPeriodEnd": {
            "type": "string",
            "description": "Gets or sets the date when the content is no longer available in ISO 8601format: {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}+{TZ}.\r\nFor example, 2020-11-11T22:21:37+00:00\r\nOptional",
            "nullable": true
          },
          "adBreaks": {
            "type": "string",
            "description": "Gets or sets one or more time codes. Represents a time duration from the beginning of the video where an ad shows up.\r\nConforms to the format: {hh}:{mm}:{ss} and in the form of an SCTE-35 marker.\r\nSee each content type for its ad policy.\r\nhttps://en.wikipedia.org/wiki/SCTE-35\r\nRequired if monetizing content",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents the details about a single video content item such as a movie, episode, short-form video, or TV special.\r\nA content object must contain both a video object and a caption object."
      },
      "ContentResult": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "nullable": true
          },
          "contentType": {
            "type": "string",
            "nullable": true
          },
          "statusCode": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ContentTextTypes": {
        "enum": [
          "Line",
          "Word",
          "Person",
          "Location",
          "Organization",
          "CommercialItem",
          "Event",
          "Date",
          "Quantity",
          "Title",
          "Entity",
          "KeyPhrase",
          "MixedSentiment",
          "NegativeSentiment",
          "NeutralSentiment",
          "PositiveSentiment",
          "Transcript",
          "Other"
        ],
        "type": "string",
        "description": "\n\nLine\n\nWord\n\nPerson\n\nLocation\n\nOrganization\n\nCommercialItem\n\nEvent\n\nDate\n\nQuantity\n\nTitle\n\nEntity\n\nKeyPhrase\n\nMixedSentiment\n\nNegativeSentiment\n\nNeutralSentiment\n\nPositiveSentiment\n\nTranscript\n\nOther",
        "x-enumNames": [
          "Line",
          "Word",
          "Person",
          "Location",
          "Organization",
          "CommercialItem",
          "Event",
          "Date",
          "Quantity",
          "Title",
          "Entity",
          "KeyPhrase",
          "MixedSentiment",
          "NegativeSentiment",
          "NeutralSentiment",
          "PositiveSentiment",
          "Transcript",
          "Other"
        ]
      },
      "CreditModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets name of the person\r\nRequired",
            "nullable": true
          },
          "role": {
            "type": "string",
            "description": "Gets or sets the role of the person, which must be one of the following values:\r\n    actor\r\n    anchor\r\n    host\r\n    narrator\r\n    voice\r\n    director\r\n    producer\r\n    screenwriter\r\nRequired",
            "nullable": true
          },
          "birthDate": {
            "type": "string",
            "description": "Gets or sets birth date of the person\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a single person in the credits of a video content."
      },
      "DirectPublisherFeedModel": {
        "type": "object",
        "properties": {
          "providerName": {
            "type": "string",
            "description": "Gets or sets the name of the feed provider. E.g.: “Acme Productions”.\r\nRequired",
            "nullable": true
          },
          "lastUpdated": {
            "type": "string",
            "description": "Gets or sets the date that the feed was last modified in ISO 8601 format: {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}+{TZ}.\r\nFor example, 2020-11-11T22:21:37+00:00\r\nRequired",
            "nullable": true
          },
          "language": {
            "type": "string",
            "description": "Gets or sets the language the channel uses for all its information and descriptions.\r\n(e.g., “en”, “en-US”, “es”, etc.). ISO 639 alpha-2 or alpha-3 language code string.\r\nRequired",
            "nullable": true
          },
          "movies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MovieModel"
            },
            "description": "Gets or sets a list of one or more movies.\r\nRequired (The root object must contain at least 1 movie or 1 live feed or 1 series or 1 short form video or 1 TV Special)",
            "nullable": true
          },
          "liveFeeds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveFeedModel"
            },
            "description": "Gets or sets a list of one or more live linear streams.\r\nRequired (The root object must contain at least 1 movie or 1 live feed or 1 series or 1 short form video or 1 TV Special)",
            "nullable": true
          },
          "series": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SeriesModel"
            },
            "description": "Gets or sets a list of one or more series. Series are episodic in nature and would include TV shows, daily/weekly shows, etc.\r\nRequired (The root object must contain at least 1 movie or 1 live feed or 1 series or 1 short form video or 1 TV Special)",
            "nullable": true
          },
          "shortFormVideos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ShortFormVideoModel"
            },
            "description": "Gets or sets a list of one or more short-form videos. Short-form videos are usually less than 15 minutes long and are not TV Shows or Movies.\r\nRequired (The root object must contain at least 1 movie or 1 live feed or 1 series or 1 short form video or 1 TV Special)",
            "nullable": true
          },
          "tvSpecials": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TvSpecialModel"
            },
            "description": "Gets or sets a list of one or more TV Specials. TV Specials are one-time TV programs that are not part of a series.\r\nRequired (The root object must contain at least 1 movie or 1 live feed or 1 series or 1 short form video or 1 TV Special)",
            "nullable": true
          },
          "categories": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CategoryModel"
            },
            "description": "Gets or sets an ordered list of one or more categories that will show up in your Roku Channel.\r\nCategories may also be manually specified within Direct Publisher if you do not want to provide them directly in the feed.\r\nEach time the feed is updated it will refresh the categories\r\nOptional",
            "nullable": true
          },
          "playlists": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PlaylistModel"
            },
            "description": "Gets or sets a list of one or more playlists. They are useful for creating manually ordered categories inside your channel.\r\nOptional",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "https://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md"
      },
      "DynamicContentModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the dynamic content block.",
            "format": "uuid",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the display title of the dynamic content block.",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "description": "Gets or sets the URL-friendly slug for the dynamic content block.",
            "nullable": true
          },
          "content": {
            "type": "string",
            "description": "Gets or sets the HTML or text content body of the dynamic content block.",
            "nullable": true
          },
          "mediaGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of media groups this dynamic content block is associated with.",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "description": "Gets or sets the display sequence order of this dynamic content block within its parent.",
            "format": "int32",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs via JSON extension data.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a dynamic content block that can be associated with media groups, containing customizable HTML or text content."
      },
      "EluvioTokenRequestModel": {
        "type": "object",
        "properties": {
          "mezzanineObjectId": {
            "type": "string",
            "description": "Gets or sets the Eluvio mezzanine object identifier.",
            "nullable": true
          },
          "mezzanineLibraryId": {
            "type": "string",
            "description": "Gets or sets the Eluvio mezzanine library identifier.",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the content identifier associated with the token request.",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets or sets the content definition identifier associated with the token request.",
            "format": "uuid",
            "nullable": true
          },
          "useJsClientApi": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to use the JavaScript client API for token generation."
          }
        },
        "additionalProperties": false,
        "description": "Represents the request model for generating a signed Eluvio content fabric security token."
      },
      "EluvioTokenResponseModel": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Gets or sets the signed Eluvio security token.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response containing a signed Eluvio security token."
      },
      "EmbeddedDownloadModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "fullUrl": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "language": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EmbeddedMediaModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the embedded media item.",
            "format": "uuid"
          },
          "mediaType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaTypes"
              }
            ],
            "description": "Gets or sets the type of media (e.g., video, audio, image).\n\nImage\n\nVideo\n\nDocument\n\nText\n\nAudio\n\nOther\n\nMediaManifest",
            "nullable": true
          },
          "assetType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetTypes"
              }
            ],
            "description": "Gets or sets the type of asset for this embedded media.\n\nFolder\n\nFile\n\nBucket",
            "nullable": true
          },
          "fullUrl": {
            "type": "string",
            "description": "Gets or sets the full URL for the primary media stream.",
            "nullable": true
          },
          "hlsFullUrl": {
            "type": "string",
            "description": "Gets or sets the full URL for the HLS adaptive streaming version of the media.",
            "nullable": true
          },
          "previewFullUrl": {
            "type": "string",
            "description": "Gets or sets the full URL for the preview version of the media.",
            "nullable": true
          },
          "thumbnailTrackFullUrl": {
            "type": "string",
            "description": "Gets or sets the full URL for the thumbnail track file used for seek preview scrubbing.",
            "nullable": true
          },
          "previewImageFullUrl": {
            "type": "string",
            "description": "Gets or sets the full URL for the preview image of the media.",
            "nullable": true
          },
          "thumbnailImageFullUrl": {
            "type": "string",
            "description": "Gets or sets the full URL for the thumbnail image of the media.",
            "nullable": true
          },
          "playerUrl": {
            "type": "string",
            "description": "Gets or sets the URL for the video player page. Used internally.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the display title of the embedded media.",
            "nullable": true
          },
          "duration": {
            "type": "integer",
            "description": "Gets or sets the duration of the media in milliseconds.",
            "format": "int64",
            "nullable": true
          },
          "height": {
            "type": "integer",
            "description": "Gets or sets the height in pixels of the media.",
            "format": "int32",
            "nullable": true
          },
          "width": {
            "type": "integer",
            "description": "Gets or sets the width in pixels of the media.",
            "format": "int32",
            "nullable": true
          },
          "language": {
            "type": "string",
            "description": "Gets or sets the language of the embedded media content.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Gets or sets a description of the embedded media content.",
            "nullable": true
          },
          "author": {
            "type": "string",
            "description": "Gets or sets the author or creator of the embedded media content.",
            "nullable": true
          },
          "twitterSite": {
            "type": "string",
            "description": "Gets or sets the Twitter site handle for social media card metadata.",
            "nullable": true
          },
          "transcripts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmbeddedTranscriptModel"
            },
            "description": "Gets or sets the collection of transcript tracks available for the embedded media.",
            "nullable": true
          },
          "sharePermissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of permissions that control who can access the shared media.",
            "nullable": true
          },
          "shareType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of share link (e.g., public, private, password-protected).",
            "nullable": true
          },
          "shareStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the share link (e.g., active, expired).",
            "nullable": true
          },
          "shareName": {
            "type": "string",
            "description": "Gets or sets the display name of the share link.",
            "nullable": true
          },
          "shareExpirationDate": {
            "type": "string",
            "description": "Gets or sets the expiration date after which the share link is no longer valid.",
            "format": "date-time",
            "nullable": true
          },
          "itemCount": {
            "type": "integer",
            "description": "Gets or sets the total number of items included in this embedded media share.",
            "format": "int32"
          },
          "downloads": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmbeddedDownloadModel"
            },
            "description": "Gets or sets the collection of downloadable renditions available for the embedded media.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an embedded media item with playback URLs, metadata, sharing configuration, and transcript information for external embedding."
      },
      "EmbeddedTranscriptModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "fullUrl": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "language": {
            "type": "string",
            "nullable": true
          },
          "isDefault": {
            "type": "boolean"
          },
          "format": {
            "type": "string",
            "nullable": true
          },
          "kind": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "EpisodeModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets an immutable string reference ID for the episode that does not exceed 50 characters.\r\nThis should serve as a unique identifier for the episode across different locales.\r\nOnce created, the ID for the content item may not be changed.\r\nRequired",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the episode in plain text. This field is used for matching in Roku Search.\r\nDo not include extra information such as year, version label, and so on.\r\nRequired",
            "nullable": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentModel"
              }
            ],
            "description": "Gets or sets the video content, such as the URL of the video file, subtitles, and so on.\r\nRequired",
            "nullable": true
          },
          "thumbnail": {
            "type": "string",
            "description": "Gets or sets the URL of the thumbnail for the episode. This is used within the channel and in search results.\r\nImage dimensions must be at least 800x450 (width x height, 16x9 aspect ratio).\r\nRequired",
            "nullable": true
          },
          "releaseDate": {
            "type": "string",
            "description": "Gets or sets the date the episode was initially released or first aired. This field is used to sort programs chronologically and group related content in Roku Search.\r\nConforms to the ISO 8601 format: {YYYY}-{MM}-{DD}. For example, 2020-12-26.\r\nRequired",
            "nullable": true
          },
          "episodeNumber": {
            "type": "integer",
            "description": "Gets or sets the unique ID assigned to the episode.\r\nRequired",
            "format": "int32"
          },
          "shortDescription": {
            "type": "string",
            "description": "Gets or sets an episode description that does not exceed 200 characters. The text will be clipped if longer.\r\nRequired",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "description": "Gets or sets a longer episode description that does not exceed 500 characters. The text will be clipped if longer.\r\nMust be different from shortDescription.\r\nRequired",
            "nullable": true
          },
          "credits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreditModel"
            },
            "description": "Gets or sets one or more credits. The cast and crew of the episode.\r\nOptional",
            "nullable": true
          },
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RatingModel"
              }
            ],
            "description": "Gets or sets a parental rating for the content.\r\nRequired",
            "nullable": true
          },
          "externalIds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            },
            "description": "Gets or sets one or more third-party metadata provider IDs.\r\nOptional",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a single episode in a series or a season."
      },
      "ExternalId": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the third-party metadata provider ID for the video content.\r\nIf IMDB was being used for example, the last part of the URL of a movie would be used such as:\r\n\"http://www.imdb.com/title/tt0371724\".\r\nRequired",
            "nullable": true
          },
          "idType": {
            "type": "string",
            "description": "Gets or sets must be one of the following:\r\n    TMS  – A Tribune Metadata Service ID for the content\r\n    ROVI - A Rovi ID for the content\r\n    IMDB – An Internet Movie Database ID\r\n    EIDR – An Entertainment Identifier Registry ID\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "FaceMatchTypes": {
        "enum": [
          "Automatch",
          "ProbableMatch",
          "NotMatch",
          "ConfirmedMatch",
          "Blurry"
        ],
        "type": "string",
        "description": "Categorizes the type of facial recognition match between a detected face and a person.\r\nUsed to filter face results when querying person faces.\n\nAutomatch\n\nProbableMatch\n\nNotMatch\n\nConfirmedMatch\n\nBlurry",
        "x-enumNames": [
          "Automatch",
          "ProbableMatch",
          "NotMatch",
          "ConfirmedMatch",
          "Blurry"
        ]
      },
      "FaceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "confidence": {
            "type": "number",
            "format": "double"
          },
          "externalFaceId": {
            "type": "string",
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "similarityScore": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "personId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "nullable": true
          },
          "rotationCorrection": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "celebrityExternalId": {
            "type": "string",
            "nullable": true
          },
          "celebrityConfidence": {
            "type": "number",
            "format": "float",
            "nullable": true
          },
          "celebrityName": {
            "type": "string",
            "nullable": true
          },
          "celebrityUrls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "isPersonValidated": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "FeaturedContentModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "searchKeys": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "searchTerms": {
            "type": "string",
            "nullable": true
          },
          "searchSortType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchSortTypes"
              }
            ],
            "description": "\n\n0 = Ascending\n\n1 = Descending",
            "nullable": true
          },
          "sortField": {
            "type": "string",
            "nullable": true
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultModel"
            },
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "public": {
            "type": "boolean"
          },
          "searchDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "endSearchDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "contentDefinitionIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "assetTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetTypes"
            },
            "nullable": true
          },
          "mediaTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaTypes"
            },
            "nullable": true
          },
          "searchTextFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchTextFields"
            },
            "nullable": true
          },
          "advanceSearchFilters": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "shares": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "includeVideoClips": {
            "type": "boolean",
            "nullable": true
          },
          "useLlmSearch": {
            "type": "boolean",
            "nullable": true
          },
          "includeFolders": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "FeaturedContentRequestModel": {
        "type": "object",
        "properties": {
          "returnedFieldNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of field names to include in each featured content item. If null, all fields are returned.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for retrieving featured content."
      },
      "FeaturedContentTypes": {
        "enum": [
          "List",
          "PreviewImage",
          "Header"
        ],
        "type": "string",
        "description": "\n\nList\n\nPreviewImage\n\nHeader",
        "x-enumNames": [
          "List",
          "PreviewImage",
          "Header"
        ]
      },
      "FeaturedGroupModel": {
        "type": "object",
        "properties": {
          "groupId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "groupType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "nullable": true
          },
          "subtitle": {
            "type": "string",
            "nullable": true
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeaturedItemModel"
            },
            "nullable": true
          },
          "showEmptyGroup": {
            "type": "boolean"
          },
          "sequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "FeaturedItemModel": {
        "type": "object",
        "properties": {
          "itemId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the featured item.",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the content definition that describes the type of this featured item.",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the primary image for the featured item.",
            "nullable": true
          },
          "previewUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the preview media (e.g., animated thumbnail or short clip).",
            "nullable": true
          },
          "previewHeight": {
            "type": "integer",
            "description": "Gets or sets the height in pixels of the preview media.",
            "format": "int32",
            "nullable": true
          },
          "previewWidth": {
            "type": "integer",
            "description": "Gets or sets the width in pixels of the preview media.",
            "format": "int32",
            "nullable": true
          },
          "duration": {
            "type": "integer",
            "description": "Gets or sets the duration of the featured media item in seconds.",
            "format": "int32",
            "nullable": true
          },
          "rating": {
            "type": "integer",
            "description": "Gets or sets the user rating for the featured item.",
            "format": "int32",
            "nullable": true
          },
          "date": {
            "type": "string",
            "description": "Gets or sets the date associated with the featured item (e.g., release or event date).",
            "format": "date-time",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the display title of the featured item.",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "description": "Gets or sets the URL-friendly slug for the featured item.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Gets or sets a brief description of the featured item.",
            "nullable": true
          },
          "actionText": {
            "type": "string",
            "description": "Gets or sets the label text for the call-to-action button.",
            "nullable": true
          },
          "actionUrl": {
            "type": "string",
            "description": "Gets or sets the URL that the call-to-action button navigates to.",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "description": "Gets or sets the display sequence order of this item within its featured group.",
            "format": "int32",
            "nullable": true
          },
          "groupSequence": {
            "type": "integer",
            "description": "Gets or sets the display sequence order of the parent featured group.",
            "format": "int32",
            "nullable": true
          },
          "sortNumber": {
            "type": "integer",
            "description": "Gets or sets the sort order number used for custom ordering.",
            "format": "int32",
            "nullable": true
          },
          "seasonCount": {
            "type": "integer",
            "description": "Gets or sets the total number of seasons when this featured item represents a series.",
            "format": "int32",
            "nullable": true
          },
          "episodeCount": {
            "type": "integer",
            "description": "Gets or sets the total number of episodes when this featured item represents a season or series.",
            "format": "int32",
            "nullable": true
          },
          "continueWatchingSeconds": {
            "type": "integer",
            "description": "Gets or sets the number of seconds the user has already watched, used for continue watching functionality.",
            "format": "int32",
            "nullable": true
          },
          "video": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VideoReferenceModel"
              }
            ],
            "description": "Gets or sets the video reference containing playback URLs and video metadata.",
            "nullable": true
          },
          "content": {
            "type": "string",
            "description": "Gets or sets the HTML or text content body associated with this featured item.",
            "nullable": true
          },
          "season": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the season this featured item belongs to.",
            "nullable": true
          },
          "performers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PerformerModel"
            },
            "description": "Gets or sets the collection of performers associated with this featured item.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs via JSON extension data.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a featured media item displayed in portal carousels and featured content sections with summary metadata and display configuration."
      },
      "ForgotPasswordRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to reset. Required."
          }
        },
        "additionalProperties": false,
        "description": "Request model for initiating a password reset flow."
      },
      "FormDataModel": {
        "type": "object",
        "properties": {
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the collection of form field values as key-value pairs captured via JSON extension data.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a generic form data container that captures arbitrary key-value pairs from form submissions via JSON extension data."
      },
      "GenerateImageModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the source asset to use as a reference for image generation.",
            "format": "uuid"
          },
          "prompt": {
            "type": "string",
            "description": "Gets or sets the text prompt describing the desired image output.",
            "nullable": true
          },
          "negativePrompt": {
            "type": "string",
            "description": "Gets or sets the optional negative prompt describing elements to exclude from the generated image.",
            "nullable": true
          },
          "boundingBox": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BoundingBoxModel"
              }
            ],
            "description": "Gets or sets the optional bounding box that defines the region of interest for image generation.",
            "nullable": true
          },
          "applyInternalBoundingBox": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to apply the internally computed bounding box during generation."
          },
          "maskPrompt": {
            "type": "string",
            "description": "Gets or sets the optional mask prompt used to define areas of the image to modify.",
            "nullable": true
          },
          "variation": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to generate a variation of the source image rather than a new image."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
      },
      "GenerateImageModelResponse": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the newly generated image asset, or null if generation failed.",
            "format": "uuid",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "description": "Gets or sets the URL where the generated image can be accessed, or null if generation failed.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response from an AI image generation request, containing the resulting asset and its URL."
      },
      "GeoData": {
        "type": "object",
        "properties": {
          "latitude": {
            "type": "number",
            "description": "Latitude measures the distance north or south of the equator.",
            "format": "double",
            "nullable": true
          },
          "longitude": {
            "type": "number",
            "description": "Longitude is a geographic coordinate that specifies the east–west position of a point on the surface of the Earth, or another celestial body.",
            "format": "double",
            "nullable": true
          },
          "altitude": {
            "type": "number",
            "description": "Altitude is the vertical elevation of an object above a surface (such as sea level or land) of a planet or natural satellite.",
            "format": "double",
            "nullable": true
          },
          "latitudeSpan": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "longitudeSpan": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Google Photos Specific Class For GeoData.\r\nhttps://exiftool.org/forum/index.php?topic=9972.0 --> ExifTool Parsing Google JSON.\r\n\r\nhttps://github.com/StarGeekSpaceNerd/Metadata_Reference/blob/master/Photos.google.com.md\r\ngeoData (Location entered on website)\r\ngeoDataExif (original location per file exif)"
      },
      "HeroModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "subtitle": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "actionText": {
            "type": "string",
            "nullable": true
          },
          "actionUrl": {
            "type": "string",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "previewUrl": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "previewHeight": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "deprecated": true
          },
          "previewWidth": {
            "type": "integer",
            "format": "int32",
            "nullable": true,
            "deprecated": true
          },
          "itemId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "itemType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaImageModel"
            },
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "IdModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "additionalProperties": false,
        "description": "A wrapper containing a single Guid identifier. The Id property represents the unique identifier of the created or affected entity."
      },
      "IncludeCustomFieldModel": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "nullable": true
          },
          "property": {
            "type": "string",
            "nullable": true
          },
          "id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "additionalProperties": false
      },
      "LabelModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the label.",
            "format": "uuid"
          },
          "labelName": {
            "type": "string",
            "description": "Gets or sets the name of the detected label.",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "description": "Gets or sets the confidence score of the label detection, expressed as a value between 0 and 100.",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "description": "Gets or sets the number of times this label was detected across segments or frames.",
            "format": "int64",
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "description": "Gets or sets the list of time-based segments where this label was detected.",
            "nullable": true
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LabelModel"
            },
            "description": "Gets or sets the list of child labels that are more specific subcategories of this label.",
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "description": "Gets or sets the list of bounding boxes that indicate where this label was detected in the image.",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "description": "Gets or sets the source identifier used when no bounding box data is available.",
            "format": "uuid",
            "nullable": true
          },
          "rollupCount": {
            "type": "integer",
            "description": "Gets or sets the aggregated count across all child labels and segments.",
            "format": "int32",
            "nullable": true
          },
          "rollupConfidence": {
            "type": "number",
            "description": "Gets or sets the aggregated confidence score across all child labels and segments.",
            "format": "double",
            "nullable": true
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "Gets or sets the type of metadata analysis that produced this label.\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a detected label or category identified within an asset, including confidence scores and hierarchical relationships."
      },
      "LanguageModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "translatedTitle": {
            "type": "string",
            "nullable": true
          },
          "iso2": {
            "type": "string",
            "nullable": true
          },
          "iso3": {
            "type": "string",
            "nullable": true
          },
          "iso5": {
            "type": "string",
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "float",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveChannelEditModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "thumbnailImage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "archivePrefixes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "nullable": true
          },
          "externalUrl": {
            "type": "string",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean"
          },
          "enableHighAvailability": {
            "type": "boolean",
            "nullable": true
          },
          "enableLiveClipping": {
            "type": "boolean",
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputScreenshots": {
            "type": "boolean"
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the security groups that this live channel is part of",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveChannelModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the live channel.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the live channel.",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "description": "Gets or sets the URL-friendly route name for the live channel.",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the output stream uses secure (signed) URLs."
          },
          "outputScreenshots": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether output screenshots are enabled for the channel."
          },
          "enableHighAvailability": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether high availability mode is enabled for the channel.",
            "nullable": true
          },
          "disableChannelControls": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether channel controls are disabled in the UI.",
            "nullable": true
          },
          "disableRecordingControls": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether recording controls are disabled in the UI.",
            "nullable": true
          },
          "thumbnailImageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the channel's thumbnail image.",
            "nullable": true
          },
          "thumbnailImage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the thumbnail image asset reference for the channel.",
            "nullable": true
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the folder asset reference where archived recordings are stored.",
            "nullable": true
          },
          "channelId": {
            "type": "string",
            "description": "Gets or sets the external channel identifier from the live streaming provider.",
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of the live channel.",
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output type configuration for the live channel.",
            "nullable": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the live channel.",
            "nullable": true
          },
          "recordingStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current recording status of the live channel.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "nullable": true
          },
          "outputStartTime": {
            "type": "string",
            "description": "Gets or sets the date and time when the output stream started.",
            "format": "date-time",
            "nullable": true
          },
          "inputMaximumBitrate": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the maximum bitrate configuration for the input stream.",
            "nullable": true
          },
          "inputResolution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the resolution configuration for the input stream.",
            "nullable": true
          },
          "inputCodec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the codec configuration for the input stream.",
            "nullable": true
          },
          "outputLiveVideoUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the live video output stream.",
            "nullable": true
          },
          "outputLiveVideoHlsUrl": {
            "type": "string",
            "description": "Gets or sets the HLS URL of the live video output stream.",
            "nullable": true
          },
          "outputLiveVideoRtcUrl": {
            "type": "string",
            "description": "Gets or sets the WebRTC URL of the live video output stream.",
            "nullable": true
          },
          "inputIngestAddress": {
            "type": "string",
            "description": "Gets or sets the ingest address for the input stream.",
            "nullable": true
          },
          "inputStreamKey": {
            "type": "string",
            "description": "Gets or sets the stream key used to authenticate the input stream.",
            "nullable": true
          },
          "inputAuthKey": {
            "type": "string",
            "description": "Gets or sets the authentication key for the input stream.",
            "nullable": true
          },
          "scheduleEvents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "description": "Gets or sets the list of schedule events associated with this channel.",
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the channel was last modified.",
            "format": "date-time"
          },
          "lastStateChangedDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the channel state last changed.",
            "format": "date-time",
            "nullable": true
          },
          "lastRecordingStateChangedDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the recording state last changed.",
            "format": "date-time",
            "nullable": true
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of output encoding profiles for the channel.",
            "nullable": true
          },
          "statusMessages": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets the collection of status messages for the channel.",
            "nullable": true,
            "readOnly": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output profile group reference for the channel.",
            "nullable": true
          },
          "recordingStartedByUser": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the user who started the current recording.",
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of external output profiles for the channel.",
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of security groups assigned to the channel.",
            "nullable": true
          },
          "archivePrefixes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of archive prefix paths for the channel.",
            "nullable": true
          },
          "archiveOutputFilename": {
            "type": "string",
            "description": "Gets or sets the filename pattern used for archived output recordings.",
            "nullable": true
          },
          "liveScheduleId": {
            "type": "string",
            "description": "Gets or sets the identifier of the live schedule associated with this channel.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the internal live channel model with extended configuration, status, and recording information."
      },
      "LiveChannelModelLiveResultModel": {
        "type": "object",
        "properties": {
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveChannelModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveChannelNewModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean"
          },
          "outputScreenshots": {
            "type": "boolean"
          },
          "enableHighAvailability": {
            "type": "boolean",
            "nullable": true
          },
          "enableLiveClipping": {
            "type": "boolean",
            "nullable": true
          },
          "thumbnailImage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "externalUrl": {
            "type": "string",
            "nullable": true
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "archivePrefixes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the security groups that this live channel is part of",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveClipResponseModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the clip.",
            "format": "uuid"
          },
          "internalMasterManifestUrl": {
            "type": "string",
            "description": "Gets or sets the internal URL to the master manifest for the clip.",
            "nullable": true
          },
          "masterHlsSnapshotUrl": {
            "type": "string",
            "description": "Gets or sets the master HLS snapshot URL for the clip.",
            "nullable": true
          },
          "snapshotStartDtUtc": {
            "type": "string",
            "description": "Gets or sets the UTC date and time when the snapshot started.",
            "format": "date-time",
            "nullable": true
          },
          "snapshotDuration": {
            "type": "number",
            "description": "Gets or sets the duration of the snapshot in seconds.",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response from a live stream snapshot clip operation."
      },
      "LiveEndpointInfoModel": {
        "type": "object",
        "properties": {
          "ip": {
            "type": "string",
            "nullable": true
          },
          "port": {
            "type": "string",
            "nullable": true
          },
          "url": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveFeedModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets an immutable string reference ID for the live feed that does not exceed 50 characters.\r\nThis should serve as a unique identifier for the live feed across different locales.\r\nOnce created, the ID for the content item may not be changed.\r\nRequired",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the live stream in plain text. This field is used for matching in Roku Search.\r\nDo not include extra information such as year, version label, and so on.\r\nRequired",
            "nullable": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentModel"
              }
            ],
            "description": "Gets or sets the actual video content, such as the URL of the live stream.\r\nRequired",
            "nullable": true
          },
          "thumbnail": {
            "type": "string",
            "description": "Gets or sets the URL of the primary thumbnail for the live stream. This is used within the channel and in search results.\r\nImage dimensions must be at least 800x450 (width x height, 16x9 aspect ratio).\r\nRequired",
            "nullable": true
          },
          "brandedThumbnail": {
            "type": "string",
            "description": "Gets or sets the URL of the secondary thumbnail for the live stream. This is used as a backup in the event that the primary image is not suitable.\r\nImage dimensions must be at least 800x450 (width x height, 16x9 aspect ratio)\r\nRequired",
            "nullable": true
          },
          "shortDescription": {
            "type": "string",
            "description": "Gets or sets a live stream description that does not exceed 200 characters. The text will be clipped if longer.\r\nRequired",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "description": "Gets or sets a longer live stream description that does not exceed 500 characters. The text will be clipped if longer.\r\nMust be different from shortDescription.\r\nRequired",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of one or more tags (for example, “dramas”, “korean”, and so on). Each tag is a string and is limited to 20 characters.\r\nTags are used to define what content will be shown within a category and to find content for content curation purposes.\r\nOptional",
            "nullable": true
          },
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RatingModel"
              }
            ],
            "description": "Gets or sets a parental rating for the content.\r\nRequired",
            "nullable": true
          },
          "genres": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of strings describing the genre(s) of the content.\r\nMust be one of the values listed in https://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#genres\r\nOptional",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a live linear stream."
      },
      "LiveInputEditModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "sourceCidr": {
            "type": "string",
            "nullable": true
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: URL_PULL, MP4_FILE",
            "nullable": true
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: RTMP_PULL",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveInputModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "sourceCidr": {
            "type": "string",
            "nullable": true
          },
          "resourceName": {
            "type": "string",
            "nullable": true
          },
          "inputId": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "thumbnailUrl": {
            "type": "string",
            "nullable": true
          },
          "videoAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "nullable": true
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveInputModelLiveResultModel": {
        "type": "object",
        "properties": {
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveInputModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveInputNewModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "sourceCidr": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "isStandard": {
            "type": "boolean"
          },
          "videoAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: RTMP_PUSH, URL_PULL, MP4_FILE",
            "nullable": true
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: RTMP_PULL",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "NOTE: MediaConnect input creation not supported"
      },
      "LiveOutputProfileGroupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the output profile group.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the output profile group.",
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether we are enabled."
          },
          "manifestType": {
            "type": "string",
            "description": "Gets or sets acceptable values:\r\n- HLS\r\n- DASH\r\n- BOTH (assumes HLS and DASH",
            "nullable": true
          },
          "isDefaultGroup": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether if this is the default group,\r\nonly one default group is allowed at a time."
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output type for the assetgroup.",
            "nullable": true
          },
          "archiveOutputProfile": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the optional profile to use for archival operations.",
            "nullable": true
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the required Live Output Profiles to use for this group.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a group of live output profiles with shared configuration."
      },
      "LiveOutputProfileModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the output profile.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the output profile.",
            "nullable": true
          },
          "videoCodec": {
            "type": "string",
            "description": "Gets or sets acceptable values:\r\n- {leave null/empty }\r\n- H264\r\n- H265",
            "nullable": true
          },
          "videoWidth": {
            "type": "integer",
            "description": "Gets or sets video output width. For example 1920.",
            "format": "int32",
            "nullable": true
          },
          "videoHeight": {
            "type": "integer",
            "description": "Gets or sets video output height. For example 1080.",
            "format": "int32",
            "nullable": true
          },
          "videoBitRateMode": {
            "type": "string",
            "description": "Gets or sets acceptable values:\r\n- {leave null/empty }\r\n- CBR\r\n- VBR",
            "nullable": true
          },
          "videoBitRate": {
            "type": "integer",
            "description": "Gets or sets the video bitrate in bytes. For example, 2mbps = 2048000.",
            "format": "int32",
            "nullable": true
          },
          "videoFramesPerSecond": {
            "type": "number",
            "description": "Gets or sets the video frames per second in decimal format. 29.97, 60.0 are some examples.",
            "format": "float",
            "nullable": true
          },
          "audioBitRate": {
            "type": "integer",
            "description": "Gets or sets the audio bitrate in bytes. For example, 128KB = 128000.",
            "format": "int32",
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output type from MediaLiveOutputTypes.",
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether we are enabled."
          },
          "outputUrl": {
            "type": "string",
            "description": "Gets or sets the primary output destination url for our MediaLive single output rendition only.",
            "nullable": true
          },
          "outputStreamKey": {
            "type": "string",
            "description": "Gets or sets the primary streamkey for our MediaLive output destination single output rendition only.",
            "nullable": true
          },
          "secondaryOutputUrl": {
            "type": "string",
            "description": "Gets or sets the secondary output destination url for our MediaLive single output rendition only.",
            "nullable": true
          },
          "secondaryOutputStreamKey": {
            "type": "string",
            "description": "Gets or sets the secondary streamkey for our MediaLive output destination single output rendition only.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a live output encoding profile with video and audio settings."
      },
      "LiveOutputProfileModelLiveResultModel": {
        "type": "object",
        "properties": {
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveOutputProfileModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveOutputStatuses": {
        "enum": [
          1,
          2
        ],
        "type": "integer",
        "description": "\n\n1 = Online\n\n2 = Offline",
        "format": "int32",
        "x-enumNames": [
          "Online",
          "Offline"
        ]
      },
      "LiveScheduleCopyModel": {
        "type": "object",
        "properties": {
          "recurringWeeks": {
            "type": "integer",
            "description": "Gets or sets the number of weeks the recurring schedule should repeat.",
            "format": "int32",
            "nullable": true
          },
          "recurringDays": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the days of the week on which the schedule should recur.",
            "nullable": true
          },
          "timeZoneOffsetSeconds": {
            "type": "integer",
            "description": "Gets or sets the time zone offset in seconds from UTC for scheduling.",
            "format": "int32",
            "nullable": true
          },
          "recurringEndDate": {
            "type": "string",
            "description": "Gets or sets the end date for the recurring schedule.",
            "format": "date-time",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for copying a live schedule with recurring options."
      },
      "LiveScheduleEditModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "description": "Gets or sets event reference.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the live schedule.",
            "nullable": true
          },
          "prerollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the pre-roll video asset played before the live stream starts.",
            "nullable": true
          },
          "postrollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the post-roll video asset played after the live stream ends.",
            "nullable": true
          },
          "slateVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the slate video asset displayed when no live content is available.",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the output stream uses secure (signed) URLs."
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the folder asset reference where archived recordings are stored.",
            "nullable": true
          },
          "primaryLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the primary live input source reference.",
            "nullable": true
          },
          "primaryLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the primary live stream input.",
            "nullable": true
          },
          "backupLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the backup live input source reference.",
            "nullable": true
          },
          "backupLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the backup live stream input.",
            "nullable": true
          },
          "liveScheduleStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the live schedule.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "description": "Gets or sets the status message describing the current state of the live schedule.",
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of external output profiles for the live schedule.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference assigned to this schedule.",
            "nullable": true
          },
          "overrideSettings": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to override the default channel settings.",
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output profile group reference for the live schedule.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
      },
      "LiveScheduleEventEditModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "channelId": {
            "type": "string",
            "format": "uuid"
          },
          "thumbnail": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "startOffsetTimeCode": {
            "type": "string",
            "nullable": true
          },
          "fixedOnAirTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "durationTimeCode": {
            "type": "string",
            "nullable": true
          },
          "isLoop": {
            "type": "boolean"
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput2": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "previousId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "channelId": {
            "type": "string",
            "format": "uuid"
          },
          "thumbnailUrl": {
            "type": "string",
            "nullable": true
          },
          "startOffsetTimeCode": {
            "type": "string",
            "nullable": true
          },
          "fixedOnAirTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "durationTimeCode": {
            "type": "string",
            "nullable": true
          },
          "isLoop": {
            "type": "boolean"
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput2": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "nullable": true
          },
          "startTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventMoveModel": {
        "type": "object",
        "properties": {
          "previousScheduleEventId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventNewModel": {
        "type": "object",
        "properties": {
          "previousId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "channelId": {
            "type": "string",
            "format": "uuid"
          },
          "startOffsetTimeCode": {
            "type": "string",
            "nullable": true
          },
          "fixedOnAirTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "durationTimeCode": {
            "type": "string",
            "nullable": true
          },
          "isLoop": {
            "type": "boolean"
          },
          "thumbnail": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput2": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          },
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "description": "Gets or sets event reference.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the live schedule.",
            "nullable": true
          },
          "prerollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the pre-roll video asset played before the live stream starts.",
            "nullable": true
          },
          "postrollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the post-roll video asset played after the live stream ends.",
            "nullable": true
          },
          "slateVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the slate video asset displayed when no live content is available.",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the output stream uses secure (signed) URLs."
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the folder asset reference where archived recordings are stored.",
            "nullable": true
          },
          "primaryLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the primary live input source reference.",
            "nullable": true
          },
          "primaryLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the primary live stream input.",
            "nullable": true
          },
          "backupLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the backup live input source reference.",
            "nullable": true
          },
          "backupLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the backup live stream input.",
            "nullable": true
          },
          "liveScheduleStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the live schedule.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "description": "Gets or sets the status message describing the current state of the live schedule.",
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of external output profiles for the live schedule.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference assigned to this schedule.",
            "nullable": true
          },
          "overrideSettings": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to override the default channel settings.",
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output profile group reference for the live schedule.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a live schedule with input sources, output configuration, and channel assignment."
      },
      "LocalRestoreModel": {
        "type": "object",
        "properties": {
          "sourceAssetIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the array of asset identifiers to restore from archive.",
            "nullable": true
          },
          "restoreProfileNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the array of restore profile names defining the target storage locations.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to restore assets from archive storage to a local storage profile."
      },
      "LoginCookieModel": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Gets or sets the URL path scope for the cookie.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the cookie.",
            "nullable": true
          },
          "expires": {
            "type": "string",
            "description": "Gets or sets the expiration date and time of the cookie.",
            "format": "date-time"
          },
          "value": {
            "type": "string",
            "description": "Gets or sets the value of the cookie.",
            "nullable": true
          },
          "domain": {
            "type": "string",
            "description": "Gets or sets the domain scope for the cookie.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a cookie returned from a successful login that the client should set in the browser."
      },
      "LoginRequestModel": {
        "required": [
          "password",
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the user's email address used as the login identifier. Required."
          },
          "password": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the user's current password. Required."
          },
          "token": {
            "type": "string",
            "description": "Gets or sets an authentication token, if available (e.g., for multi-factor authentication flows).",
            "nullable": true
          },
          "newPassword": {
            "type": "string",
            "description": "Gets or sets the new password to set if the account requires a password change on login.",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the application identifier the user is logging in from, used for session tracking.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for authenticating a user and obtaining a JWT access token."
      },
      "LoginResponseStatuses": {
        "enum": [
          "TwoFactorSetupRequired",
          "TwoFactorCodeRequired",
          "IsDisabled",
          "IsPendingEmailConfirmation",
          "IsPendingNewAccountSignup",
          "IsPendingAccountMigrationSignup",
          "IsPendingNewPassword",
          "IsExpired",
          "IsPendingInvitation"
        ],
        "type": "string",
        "description": "Indicates the result status of a login or account-related operation.\r\nReturned in the LoginStatus field of login and account response models.\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
        "x-enumNames": [
          "TwoFactorSetupRequired",
          "TwoFactorCodeRequired",
          "IsDisabled",
          "IsPendingEmailConfirmation",
          "IsPendingNewAccountSignup",
          "IsPendingAccountMigrationSignup",
          "IsPendingNewPassword",
          "IsExpired",
          "IsPendingInvitation"
        ]
      },
      "LogoutRequestModel": {
        "type": "object",
        "properties": {
          "userSessionId": {
            "type": "string",
            "description": "Gets or sets the identifier of the session to terminate.",
            "format": "uuid",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the application identifier associated with the session.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for logging out a user and ending their session."
      },
      "LookupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets primary key associated with model instance.",
            "format": "uuid"
          },
          "enumValue": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "lookupTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "masterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "rankSeq": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "description2": {
            "type": "string",
            "nullable": true
          },
          "description3": {
            "type": "string",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LookupModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "LookupTypes": {
        "enum": [
          "PageTemplates",
          "Fields",
          "LookupTypes",
          "ContentTemplates",
          "ContentDefinitions",
          "ContentTypes",
          "ContentDefinitionGroups",
          "WorkflowStatuses",
          "DataSelectorContentDefinitions",
          "Content",
          "TemplatePacks",
          "PopularTags",
          "AllTags",
          "PropertyValues",
          "MediaTypes",
          "AssetTypes",
          "ContentFields",
          "FormSelectorContentDefinitions",
          "CustomRenderers",
          "ConstantContactCampaigns",
          "Languages",
          "SecurityGroups",
          "Collections",
          "SecurityPermissions",
          "CustomLabelerTypes",
          "CustomLabelerStatuses",
          "Labels",
          "Users",
          "MeetingSources",
          "LiveScheduleEventStatuses",
          "LiveExternalOutputProfiles",
          "LiveScheduleEventTypes",
          "LiveChannelStatuses",
          "LiveInputCodecs",
          "LiveInputMaximumBitrates",
          "LiveInputResolutions",
          "LiveInputStatuses",
          "LiveInputTypes",
          "NodeTypes",
          "LiveChannelTypes",
          "LiveOutputTypes",
          "Roles",
          "NewsSystems",
          "NprProfileTypes",
          "PaymentStatuses",
          "PingStatuses",
          "PropertyValueTypes",
          "ScheduleItemSearchTypes",
          "ScheduleItemSourceTypes",
          "ScheduleItemTypes",
          "ScheduleStatuses",
          "ScheduleTypes",
          "StorageClasses",
          "SubtitleTypes",
          "SubtitleValueTypes",
          "TextEntityTypes",
          "UploadOverwriteOptions",
          "UserSessionStatuses",
          "VideoSegmentTypes",
          "VideoTrackingEvents",
          "BatchActionProcessorExecutionTypes",
          "VideoTrackingAttributes",
          "TemplatePackTypes",
          "AdServerTypes",
          "AdSlotTypes",
          "AssetRestoreTiers",
          "AssetStatuses",
          "BatchActions",
          "BucketTypes",
          "CloudFrontDistributions",
          "ContentAttributes",
          "ContentLanguageStatuses",
          "ContentTextTypes",
          "ContentUnitOfWorkActions",
          "DataFilterFieldOperators",
          "DataIndexTypes",
          "DataJoinFilterFieldClauses",
          "DataPatchTypes",
          "DataSortHeading",
          "EmailTypes",
          "EndPointSystems",
          "FaceMatchTypes",
          "FeaturedContentTypes",
          "ImageTypes",
          "IvsChannelTypes",
          "IvsLatencyTypes",
          "JobProcessorActions",
          "LiveRequestActions",
          "LiveRequestTargets",
          "LoginResponseStatuses",
          "MediaConvertTypes",
          "MessageInfoTypes",
          "MetadataTypes",
          "ModelContainerModes",
          "DayOfWeek",
          "VideoTrackingActions",
          "FrameIngestActions",
          "ArchivePrefixTypes",
          "LiveRecordingStatuses",
          "LiveContentStatuses",
          "LiveScheduleStatuses",
          "ContentActionTypes",
          "LiveChannelRealtimeTypes",
          "MediaLiveOutputTypes",
          "TextCaptionTypes",
          "LiveStateUpdateModes",
          "MediaBuilderItemSourceTypes",
          "MediaBuilderStatuses",
          "LocalRestoreProfiles",
          "UserSessionTrackingTypes",
          "ShareDurationTypes",
          "Transcoders",
          "BulkIteratorStates",
          "ResourceClass",
          "ContentVersions",
          "ContentFieldClassifications",
          "ContentAttributeFlags",
          "ContentDataIndexTypes",
          "ImportActions",
          "ContentMutatorClassifications",
          "ShareTypes",
          "SharePermissions",
          "ShareStatuses",
          "SearchTextFields",
          "PropertyChangeTypes",
          "UploadReplaceOptions",
          "AdvanceSearchFields",
          "RollupMeasurementSourceTypes",
          "StatMeasurementAggregationOperationTypes",
          "Transcribers",
          "EmbeddingTypes",
          "AssetTransferStatuses",
          "VideoTrackingStatuses",
          "VideoTrackingAlertStatuses",
          "FrameStateFlags",
          "NewsRoomFailureTypes"
        ],
        "type": "string",
        "description": "\n\nPageTemplates\n\nFields\n\nLookupTypes\n\nContentTemplates\n\nContentDefinitions\n\nContentTypes\n\nContentDefinitionGroups\n\nWorkflowStatuses\n\nDataSelectorContentDefinitions\n\nContent\n\nTemplatePacks\n\nPopularTags\n\nAllTags\n\nPropertyValues\n\nMediaTypes\n\nAssetTypes\n\nContentFields\n\nFormSelectorContentDefinitions\n\nCustomRenderers\n\nConstantContactCampaigns\n\nLanguages\n\nSecurityGroups\n\nCollections\n\nSecurityPermissions\n\nCustomLabelerTypes\n\nCustomLabelerStatuses\n\nLabels\n\nUsers\n\nMeetingSources\n\nLiveScheduleEventStatuses\n\nLiveExternalOutputProfiles\n\nLiveScheduleEventTypes\n\nLiveChannelStatuses\n\nLiveInputCodecs\n\nLiveInputMaximumBitrates\n\nLiveInputResolutions\n\nLiveInputStatuses\n\nLiveInputTypes\n\nNodeTypes\n\nLiveChannelTypes\n\nLiveOutputTypes\n\nRoles\n\nNewsSystems\n\nNprProfileTypes\n\nPaymentStatuses\n\nPingStatuses\n\nPropertyValueTypes\n\nScheduleItemSearchTypes\n\nScheduleItemSourceTypes\n\nScheduleItemTypes\n\nScheduleStatuses\n\nScheduleTypes\n\nStorageClasses\n\nSubtitleTypes\n\nSubtitleValueTypes\n\nTextEntityTypes\n\nUploadOverwriteOptions\n\nUserSessionStatuses\n\nVideoSegmentTypes\n\nVideoTrackingEvents\n\nBatchActionProcessorExecutionTypes\n\nVideoTrackingAttributes\n\nTemplatePackTypes\n\nAdServerTypes\n\nAdSlotTypes\n\nAssetRestoreTiers\n\nAssetStatuses\n\nBatchActions\n\nBucketTypes\n\nCloudFrontDistributions\n\nContentAttributes\n\nContentLanguageStatuses\n\nContentTextTypes\n\nContentUnitOfWorkActions\n\nDataFilterFieldOperators\n\nDataIndexTypes\n\nDataJoinFilterFieldClauses\n\nDataPatchTypes\n\nDataSortHeading\n\nEmailTypes\n\nEndPointSystems\n\nFaceMatchTypes\n\nFeaturedContentTypes\n\nImageTypes\n\nIvsChannelTypes\n\nIvsLatencyTypes\n\nJobProcessorActions\n\nLiveRequestActions\n\nLiveRequestTargets\n\nLoginResponseStatuses\n\nMediaConvertTypes\n\nMessageInfoTypes\n\nMetadataTypes\n\nModelContainerModes\n\nDayOfWeek\n\nVideoTrackingActions\n\nFrameIngestActions\n\nArchivePrefixTypes\n\nLiveRecordingStatuses\n\nLiveContentStatuses\n\nLiveScheduleStatuses\n\nContentActionTypes\n\nLiveChannelRealtimeTypes\n\nMediaLiveOutputTypes\n\nTextCaptionTypes\n\nLiveStateUpdateModes\n\nMediaBuilderItemSourceTypes\n\nMediaBuilderStatuses\n\nLocalRestoreProfiles\n\nUserSessionTrackingTypes\n\nShareDurationTypes\n\nTranscoders\n\nBulkIteratorStates\n\nResourceClass\n\nContentVersions\n\nContentFieldClassifications\n\nContentAttributeFlags\n\nContentDataIndexTypes\n\nImportActions\n\nContentMutatorClassifications\n\nShareTypes\n\nSharePermissions\n\nShareStatuses\n\nSearchTextFields\n\nPropertyChangeTypes\n\nUploadReplaceOptions\n\nAdvanceSearchFields\n\nRollupMeasurementSourceTypes\n\nStatMeasurementAggregationOperationTypes\n\nTranscribers\n\nEmbeddingTypes\n\nAssetTransferStatuses\n\nVideoTrackingStatuses\n\nVideoTrackingAlertStatuses\n\nFrameStateFlags\n\nNewsRoomFailureTypes",
        "x-enumNames": [
          "PageTemplates",
          "Fields",
          "LookupTypes",
          "ContentTemplates",
          "ContentDefinitions",
          "ContentTypes",
          "ContentDefinitionGroups",
          "WorkflowStatuses",
          "DataSelectorContentDefinitions",
          "Content",
          "TemplatePacks",
          "PopularTags",
          "AllTags",
          "PropertyValues",
          "MediaTypes",
          "AssetTypes",
          "ContentFields",
          "FormSelectorContentDefinitions",
          "CustomRenderers",
          "ConstantContactCampaigns",
          "Languages",
          "SecurityGroups",
          "Collections",
          "SecurityPermissions",
          "CustomLabelerTypes",
          "CustomLabelerStatuses",
          "Labels",
          "Users",
          "MeetingSources",
          "LiveScheduleEventStatuses",
          "LiveExternalOutputProfiles",
          "LiveScheduleEventTypes",
          "LiveChannelStatuses",
          "LiveInputCodecs",
          "LiveInputMaximumBitrates",
          "LiveInputResolutions",
          "LiveInputStatuses",
          "LiveInputTypes",
          "NodeTypes",
          "LiveChannelTypes",
          "LiveOutputTypes",
          "Roles",
          "NewsSystems",
          "NprProfileTypes",
          "PaymentStatuses",
          "PingStatuses",
          "PropertyValueTypes",
          "ScheduleItemSearchTypes",
          "ScheduleItemSourceTypes",
          "ScheduleItemTypes",
          "ScheduleStatuses",
          "ScheduleTypes",
          "StorageClasses",
          "SubtitleTypes",
          "SubtitleValueTypes",
          "TextEntityTypes",
          "UploadOverwriteOptions",
          "UserSessionStatuses",
          "VideoSegmentTypes",
          "VideoTrackingEvents",
          "BatchActionProcessorExecutionTypes",
          "VideoTrackingAttributes",
          "TemplatePackTypes",
          "AdServerTypes",
          "AdSlotTypes",
          "AssetRestoreTiers",
          "AssetStatuses",
          "BatchActions",
          "BucketTypes",
          "CloudFrontDistributions",
          "ContentAttributes",
          "ContentLanguageStatuses",
          "ContentTextTypes",
          "ContentUnitOfWorkActions",
          "DataFilterFieldOperators",
          "DataIndexTypes",
          "DataJoinFilterFieldClauses",
          "DataPatchTypes",
          "DataSortHeading",
          "EmailTypes",
          "EndPointSystems",
          "FaceMatchTypes",
          "FeaturedContentTypes",
          "ImageTypes",
          "IvsChannelTypes",
          "IvsLatencyTypes",
          "JobProcessorActions",
          "LiveRequestActions",
          "LiveRequestTargets",
          "LoginResponseStatuses",
          "MediaConvertTypes",
          "MessageInfoTypes",
          "MetadataTypes",
          "ModelContainerModes",
          "DayOfWeek",
          "VideoTrackingActions",
          "FrameIngestActions",
          "ArchivePrefixTypes",
          "LiveRecordingStatuses",
          "LiveContentStatuses",
          "LiveScheduleStatuses",
          "ContentActionTypes",
          "LiveChannelRealtimeTypes",
          "MediaLiveOutputTypes",
          "TextCaptionTypes",
          "LiveStateUpdateModes",
          "MediaBuilderItemSourceTypes",
          "MediaBuilderStatuses",
          "LocalRestoreProfiles",
          "UserSessionTrackingTypes",
          "ShareDurationTypes",
          "Transcoders",
          "BulkIteratorStates",
          "ResourceClass",
          "ContentVersions",
          "ContentFieldClassifications",
          "ContentAttributeFlags",
          "ContentDataIndexTypes",
          "ImportActions",
          "ContentMutatorClassifications",
          "ShareTypes",
          "SharePermissions",
          "ShareStatuses",
          "SearchTextFields",
          "PropertyChangeTypes",
          "UploadReplaceOptions",
          "AdvanceSearchFields",
          "RollupMeasurementSourceTypes",
          "StatMeasurementAggregationOperationTypes",
          "Transcribers",
          "EmbeddingTypes",
          "AssetTransferStatuses",
          "VideoTrackingStatuses",
          "VideoTrackingAlertStatuses",
          "FrameStateFlags",
          "NewsRoomFailureTypes"
        ]
      },
      "MeasurementInfo": {
        "type": "object",
        "properties": {
          "domain": {
            "type": "string",
            "description": "Gets or sets the domain or category that this measurement belongs to.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the measurement.",
            "nullable": true
          },
          "groupingFieldNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of field names available for grouping results.",
            "nullable": true
          },
          "predefinedStackMemberships": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of predefined stack membership names available for this measurement.",
            "nullable": true
          },
          "scaleFactors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScaleFactor"
            },
            "description": "Gets or sets the list of scale factors available for this measurement.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents metadata about a single measurement, including its domain, grouping fields, and scale factors."
      },
      "MeasurementRequest": {
        "type": "object",
        "properties": {
          "measurementName": {
            "type": "string",
            "description": "Gets or sets the name of the measurement to retrieve.",
            "nullable": true
          },
          "groupingFields": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of field names to group the measurement results by.",
            "nullable": true
          },
          "stackName": {
            "type": "string",
            "description": "Gets or sets the stack name for grouping datasets in stacked chart visualizations.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a single measurement request within a statistics query, specifying the metric name, grouping, and stacking."
      },
      "MediaAttributeModel": {
        "type": "object",
        "properties": {
          "mediaAttributeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "nullable": true
          },
          "mediaAttributeType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "netflixVideoQuality": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaBuilderAddModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name for the new media builder project.",
            "nullable": true
          },
          "destinationFolderId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the destination folder where the built media will be placed.",
            "format": "uuid",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of tags to apply to the new media builder project.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of related content items to associate with the new project.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of content collections the new project will belong to.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to create a new media builder project with a name, destination folder, and initial metadata."
      },
      "MediaBuilderDuplicateModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name for the duplicated media builder project.",
            "nullable": true
          },
          "destinationFolderId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the destination folder for the duplicated project.",
            "format": "uuid",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of tags to apply to the duplicated media builder project.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of related content items to associate with the duplicated project.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of content collections the duplicated project will belong to.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to duplicate an existing media builder project with a new name, destination, and metadata."
      },
      "MediaBuilderItemAddModel": {
        "type": "object",
        "properties": {
          "mediaBuilderId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the media builder project to add the item to.",
            "format": "uuid"
          },
          "sourceAssetId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the source asset to extract the clip from.",
            "format": "uuid",
            "nullable": true
          },
          "sourceAnnotationId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the source annotation that defines the clip boundaries.",
            "format": "uuid",
            "nullable": true
          },
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the start time code position within the source asset for the new clip.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the end time code position within the source asset for the new clip.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to add a new clip item to an existing media builder project from a source asset or annotation."
      },
      "MediaBuilderItemChangeModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the media builder project containing the items to change.",
            "format": "uuid"
          },
          "changedList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaBuilderItemModel"
            },
            "description": "Gets or sets the collection of media builder items with their updated values.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to apply changes to multiple items within a media builder project in a single batch operation."
      },
      "MediaBuilderItemModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the media builder item.",
            "format": "uuid"
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the display title of the media builder item.",
            "nullable": true
          },
          "mediaBuilder": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the parent media builder project this item belongs to.",
            "nullable": true
          },
          "source": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the source asset reference from which this clip is derived.",
            "nullable": true
          },
          "sourceAnnotationId": {
            "type": "string",
            "description": "Gets or sets the identifier of the source annotation used to define this clip.",
            "format": "uuid",
            "nullable": true
          },
          "sourceType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of the source asset (e.g., video, audio).",
            "nullable": true
          },
          "sourceThumbnail": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the thumbnail asset reference for the source media.",
            "nullable": true
          },
          "sourceVideoDuration": {
            "type": "string",
            "description": "Gets or sets the total video duration of the source asset as a formatted time code string.",
            "nullable": true
          },
          "sourceAudioDuration": {
            "type": "string",
            "description": "Gets or sets the total audio duration of the source asset as a formatted time code string.",
            "nullable": true
          },
          "previousItemId": {
            "type": "string",
            "description": "Gets or sets the identifier of the preceding item in the build sequence, used for ordering.",
            "format": "uuid",
            "nullable": true
          },
          "duration": {
            "type": "string",
            "description": "Gets or sets the duration of this clip as a formatted time code string.",
            "nullable": true
          },
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the start time code position within the source asset for this clip.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the end time code position within the source asset for this clip.",
            "nullable": true
          },
          "annotation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the annotation associated with this media builder item.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an individual clip or segment within a media builder project, referencing a source asset with time code boundaries."
      },
      "MediaBuilderItemMoveModel": {
        "type": "object",
        "properties": {
          "previousItemId": {
            "type": "string",
            "description": "Gets or sets the identifier of the item that should precede this item in the sequence, or null to move to the first position.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to reorder a media builder item by specifying its new position relative to another item."
      },
      "MediaBuilderModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the media builder project.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the media builder project.",
            "nullable": true
          },
          "destination": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the destination asset reference where the built media will be stored.",
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the media builder project was last modified.",
            "format": "date-time"
          },
          "jobId": {
            "type": "string",
            "description": "Gets or sets the identifier of the background processing job associated with this media builder project.",
            "nullable": true
          },
          "mediaBuilderStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current build status of the media builder project.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "description": "Gets or sets a message describing the current status or any errors encountered during building.",
            "nullable": true
          },
          "destinationFolder": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the destination folder asset reference where the built media will be placed.",
            "nullable": true
          },
          "destinationThumbnail": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the asset reference for the thumbnail image of the built media.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of tags to apply to the built media asset.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of content collections the built media will belong to.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of related content items to associate with the built media.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a media builder project used to compose new media assets from existing source clips, with destination and metadata configuration."
      },
      "MediaBuilderRenderModel": {
        "type": "object",
        "properties": {
          "mediaBuilderId": {
            "type": "string",
            "description": "Gets or sets the identifier of the media builder template to use for rendering.",
            "format": "uuid"
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaBuilderSourceModel"
            },
            "description": "Gets or sets the array of source assets to include in the rendered output.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the rendered output asset.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags to apply to the rendered output asset.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of collections to assign the rendered output asset to.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content items to link to the rendered output asset.",
            "nullable": true
          },
          "destinationFolderId": {
            "type": "string",
            "description": "Gets or sets the identifier of the destination folder where the rendered output will be placed.",
            "format": "uuid"
          },
          "videoBitrate": {
            "type": "integer",
            "description": "Gets or sets the optional video bitrate in bits per second for the rendered output.",
            "format": "int32",
            "nullable": true
          },
          "audioTracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AudioTrackModel"
            },
            "description": "Gets or sets the array of audio track configurations for the rendered output.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
      },
      "MediaBuilderSourceModel": {
        "type": "object",
        "properties": {
          "sourceAssetId": {
            "type": "string",
            "format": "uuid"
          },
          "startTimeCode": {
            "type": "string",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaBuilderUpdateModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the media builder project to update.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the updated name for the media builder project.",
            "nullable": true
          },
          "destinationFolderId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the destination folder where the built media will be placed.",
            "format": "uuid",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of tags to apply to the media builder project.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of related content items to associate with the project.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of content collections the project will belong to.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to update an existing media builder project with revised name, destination, and metadata."
      },
      "MediaGroupMenuItemModel": {
        "type": "object",
        "properties": {
          "itemId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "location": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "sortOrder": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "url": {
            "type": "string",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "nullable": true
          },
          "featuredGroupType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "maxResults": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaGroupModel": {
        "type": "object",
        "properties": {
          "itemId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the media group.",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the content definition that describes the type of content in this media group.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the display title of the media group.",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "description": "Gets or sets the URL-friendly slug for the media group.",
            "nullable": true
          },
          "heroes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HeroModel"
            },
            "description": "Gets or sets the collection of hero banners associated with this media group.",
            "nullable": true
          },
          "featuredGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeaturedGroupModel"
            },
            "description": "Gets or sets the collection of featured content groups within this media group.",
            "nullable": true
          },
          "mediaGroupMenuItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaGroupMenuItemModel"
            },
            "description": "Gets or sets the collection of navigation menu items for this media group.",
            "nullable": true
          },
          "dynamicContents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DynamicContentModel"
            },
            "description": "Gets or sets the collection of dynamic content sections within this media group.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs via JSON extension data.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a media group, which is a logical grouping of media content including heroes, featured groups, menu items, and dynamic content sections."
      },
      "MediaImageAssetModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "fullUrl": {
            "type": "string",
            "nullable": true
          },
          "fullPreviewUrl": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaImageModel": {
        "type": "object",
        "properties": {
          "imageId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "nullable": true
          },
          "imageType": {
            "type": "string",
            "nullable": true
          },
          "height": {
            "type": "number",
            "description": "Gets or sets this is to be used mostly for thumbnails",
            "format": "double",
            "nullable": true
          },
          "width": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaItemModel": {
        "type": "object",
        "properties": {
          "itemId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the media item.",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the content definition that describes the type of this media item.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the display title of the media item.",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "description": "Gets or sets the URL-friendly slug for the media item.",
            "nullable": true
          },
          "shortDescription": {
            "type": "string",
            "description": "Gets or sets a brief description of the media item.",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "description": "Gets or sets a detailed description of the media item.",
            "nullable": true
          },
          "duration": {
            "type": "integer",
            "description": "Gets or sets the duration of the media item in seconds.",
            "format": "int32",
            "nullable": true
          },
          "images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaImageModel"
            },
            "description": "Gets or sets the collection of images associated with this media item.",
            "nullable": true
          },
          "eventDate": {
            "type": "string",
            "description": "Gets or sets the date of the event associated with this media item.",
            "format": "date-time",
            "nullable": true
          },
          "video": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VideoReferenceModel"
              }
            ],
            "description": "Gets or sets the video reference containing playback URLs and video metadata.",
            "nullable": true
          },
          "rating": {
            "type": "integer",
            "description": "Gets or sets the user rating for the media item.",
            "format": "int32",
            "nullable": true
          },
          "primaryPerformer": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the primary performer or artist for this media item.",
            "nullable": true
          },
          "performers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PerformerModel"
            },
            "description": "Gets or sets the collection of performers associated with this media item.",
            "nullable": true
          },
          "genres": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of genres assigned to this media item.",
            "nullable": true
          },
          "contentRatings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of content ratings (e.g., age ratings) for this media item.",
            "nullable": true
          },
          "mediaAttributes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaAttributeModel"
            },
            "description": "Gets or sets the collection of custom media attributes for this media item.",
            "nullable": true
          },
          "mediaTags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaTagModel"
            },
            "description": "Gets or sets the collection of tags applied to this media item.",
            "nullable": true
          },
          "relatedMediaItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelatedMediaItemModel"
            },
            "description": "Gets or sets the collection of related media items linked to this item.",
            "nullable": true
          },
          "similarMediaItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelatedMediaItemModel"
            },
            "description": "Gets or sets the collection of similar media items recommended based on this item.",
            "nullable": true
          },
          "languages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of available languages for this media item.",
            "nullable": true
          },
          "originalLanguage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the original language of the media item.",
            "nullable": true
          },
          "products": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of products associated with this media item.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of classification tags for this media item.",
            "nullable": true
          },
          "number": {
            "type": "integer",
            "description": "Gets or sets the item number, typically the episode number within a season.",
            "format": "int32",
            "nullable": true
          },
          "sortNumber": {
            "type": "integer",
            "description": "Gets or sets the sort order number used for custom ordering of media items.",
            "format": "int32",
            "nullable": true
          },
          "episodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaItemModel"
            },
            "description": "Gets or sets the collection of episodes belonging to this media item (when it represents a season or series).",
            "nullable": true
          },
          "seasons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaItemModel"
            },
            "description": "Gets or sets the collection of seasons belonging to this media item (when it represents a series).",
            "nullable": true
          },
          "season": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the season this media item belongs to.",
            "nullable": true
          },
          "series": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the series this media item belongs to.",
            "nullable": true
          },
          "venue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the venue associated with this media item.",
            "nullable": true
          },
          "image": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MediaImageAssetModel"
              }
            ],
            "description": "Gets or sets the primary image asset for this media item.",
            "nullable": true
          },
          "subtitles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EmbeddedTranscriptModel"
            },
            "description": "Gets or sets the collection of subtitle tracks available for this media item.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties as key-value pairs via JSON extension data.",
            "nullable": true
          },
          "seasonCount": {
            "type": "integer",
            "description": "Gets or sets the total number of seasons when this item represents a series.",
            "format": "int32",
            "nullable": true
          },
          "episodeCount": {
            "type": "integer",
            "description": "Gets or sets the total number of episodes when this item represents a season or series.",
            "format": "int32",
            "nullable": true
          },
          "dateAdded": {
            "type": "string",
            "description": "Gets or sets the date the item was added to our library\r\nShould default to Created Date",
            "format": "date-time"
          },
          "releaseDate": {
            "type": "string",
            "description": "Gets or sets the date the item was released or first aired",
            "format": "date-time",
            "nullable": true
          },
          "videoType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets when item is video, indicates if it is a Movie, a Short, or a TV Special\r\nDefault should be Movie",
            "nullable": true
          },
          "videoQuality": {
            "type": "string",
            "description": "Gets or sets sD, HD, FHD, UHD",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a media item with full detail including metadata, performers, genres, related items, and video references used in portal content display."
      },
      "MediaSearchModel": {
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "description": "Gets or sets the size of the page (the number of items returned for this page)",
            "format": "int32"
          },
          "pageOffset": {
            "type": "integer",
            "description": "Gets or sets the offset of the page (zero based).",
            "format": "int32"
          },
          "searchQuery": {
            "type": "string",
            "description": "Gets or sets a text string to search within all of the text fields to match",
            "nullable": true
          },
          "sortFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchSort"
            },
            "description": "Gets or sets the fields to sort by",
            "nullable": true
          },
          "ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the uuidSearchField values to limit the search by.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a search request for media items with pagination, text query, sorting, and identifier filtering."
      },
      "MediaTagModel": {
        "type": "object",
        "properties": {
          "mediaTagId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaTypes": {
        "enum": [
          "Image",
          "Video",
          "Document",
          "Text",
          "Audio",
          "Other",
          "MediaManifest"
        ],
        "type": "string",
        "description": "\n\nImage\n\nVideo\n\nDocument\n\nText\n\nAudio\n\nOther\n\nMediaManifest",
        "x-enumNames": [
          "Image",
          "Video",
          "Document",
          "Text",
          "Audio",
          "Other",
          "MediaManifest"
        ]
      },
      "MetadataTypes": {
        "enum": [
          "DocumentContent",
          "ComprehendKeyPhrases",
          "ComprehendEntities",
          "RekognitionImageIndexFaces",
          "RekognitionImageSearchFaces",
          "RekognitionImageLabels",
          "RekognitionImageCelebrityRecognition",
          "RekognitionVideoLabels",
          "TextractAnalyzeDocument",
          "Transcribe",
          "TranscribeVtt",
          "TranscribeTranslation",
          "TranscribeVttTranslation",
          "RekognitionVideoCelebrityRecognition",
          "RekognitionVideoPersonTracking",
          "RekognitionVideoFaceDetection",
          "ImageInfo",
          "Transcode",
          "Clip",
          "MediaInfo",
          "RekognitionImageDetectText",
          "RekognitionImageUnsafeContent",
          "RekognitionVideoUnsafeContent",
          "Screenshot",
          "SageMakerGroundTruthLabelResults",
          "ThumbnailSheet",
          "ThumbnailImage",
          "SageMakerInvokeEndpointResults",
          "SageMakerModelLabels",
          "RekognitionImageCustomLabels",
          "SageMakerManifest",
          "PreviewImage",
          "RekognitionVideoTextDetection",
          "RekognitionVideoSegmentDetection",
          "NomadVideoSegmentDetection",
          "TranscribeMedical",
          "PreviewAudio",
          "Text",
          "AssetManifest",
          "IntervalSegments",
          "TranscribeMedicalText",
          "TranscribeMedicalTranslation",
          "AdobeMetadata",
          "AdobeMetadataText",
          "ImageExif",
          "TextractImageDetectText",
          "AdSegments",
          "Vmap",
          "Vast",
          "MediaTailorVideo",
          "TranscribeSrt",
          "TranscribeRaw",
          "Subtitles",
          "VizRtMetadata",
          "ProcessorJobs",
          "OfficeDocument",
          "TranscriptionContainer",
          "ComprehendSentiment",
          "ComprehendLanguage",
          "OriginalSourceVideo",
          "ImportManifest",
          "TranscribeScc",
          "TranscribeTtml",
          "TranscribeDfxp",
          "TranscribeSmptett",
          "TranscribeXml",
          "TranscribeQt",
          "TranscribeRt",
          "TranscribeSsa",
          "TranscribeAss",
          "TranscribeSbv",
          "TranscribeSmi",
          "TranscribeSami",
          "TranscribeStl",
          "TranscribeSub",
          "AssociatedAsset",
          "MobiusLabsImageLabels",
          "MobiusLabsVideoAnalysis",
          "ContactSheetVTT",
          "ContactSheetTimecodes",
          "ContactSheetImage",
          "RenderedImage",
          "RokuBif",
          "MobiusLabsVideoExtractFeatures",
          "AzureImageAnalysis",
          "AzureImageVectorize",
          "AzureTextVectorize",
          "ContentVectors",
          "SceneXDescribe",
          "MobiusLabsLabelsExtractFeatures",
          "SportLogiqVideoAnalysis",
          "OciImageCaption",
          "OciTextVectorizer",
          "AnimatedGif",
          "OciTextSummary",
          "NomadMediaTasks",
          "GooglePhotosMetadata",
          "SageMakerImageToText",
          "TwelveLabsVideoAnalysis",
          "AccurateRegister",
          "BedrockImageAnalysis",
          "BedrockTextVectorizer",
          "BedrockImageVectorize",
          "BedrockTextSummary",
          "GeneratedImage",
          "TranscodeIvsRecording",
          "DolbyRaspRegister",
          "MobiusLabsLlmVideoAnalysis",
          "MobiusLabsLlmImageAnalysis",
          "TranscriptSummary",
          "SearchCache",
          "WhisperTranscription",
          "BitmovinSceneDetection",
          "BedrockDataAutomation",
          "BedrockSceneDetection",
          "MobiusLabsLlmSegmentContent",
          "AudioWaveform",
          "CustomType"
        ],
        "type": "string",
        "description": "Note that this is a PARTIAL list of types that we need to know about\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
        "x-enumNames": [
          "DocumentContent",
          "ComprehendKeyPhrases",
          "ComprehendEntities",
          "RekognitionImageIndexFaces",
          "RekognitionImageSearchFaces",
          "RekognitionImageLabels",
          "RekognitionImageCelebrityRecognition",
          "RekognitionVideoLabels",
          "TextractAnalyzeDocument",
          "Transcribe",
          "TranscribeVtt",
          "TranscribeTranslation",
          "TranscribeVttTranslation",
          "RekognitionVideoCelebrityRecognition",
          "RekognitionVideoPersonTracking",
          "RekognitionVideoFaceDetection",
          "ImageInfo",
          "Transcode",
          "Clip",
          "MediaInfo",
          "RekognitionImageDetectText",
          "RekognitionImageUnsafeContent",
          "RekognitionVideoUnsafeContent",
          "Screenshot",
          "SageMakerGroundTruthLabelResults",
          "ThumbnailSheet",
          "ThumbnailImage",
          "SageMakerInvokeEndpointResults",
          "SageMakerModelLabels",
          "RekognitionImageCustomLabels",
          "SageMakerManifest",
          "PreviewImage",
          "RekognitionVideoTextDetection",
          "RekognitionVideoSegmentDetection",
          "NomadVideoSegmentDetection",
          "TranscribeMedical",
          "PreviewAudio",
          "Text",
          "AssetManifest",
          "IntervalSegments",
          "TranscribeMedicalText",
          "TranscribeMedicalTranslation",
          "AdobeMetadata",
          "AdobeMetadataText",
          "ImageExif",
          "TextractImageDetectText",
          "AdSegments",
          "Vmap",
          "Vast",
          "MediaTailorVideo",
          "TranscribeSrt",
          "TranscribeRaw",
          "Subtitles",
          "VizRtMetadata",
          "ProcessorJobs",
          "OfficeDocument",
          "TranscriptionContainer",
          "ComprehendSentiment",
          "ComprehendLanguage",
          "OriginalSourceVideo",
          "ImportManifest",
          "TranscribeScc",
          "TranscribeTtml",
          "TranscribeDfxp",
          "TranscribeSmptett",
          "TranscribeXml",
          "TranscribeQt",
          "TranscribeRt",
          "TranscribeSsa",
          "TranscribeAss",
          "TranscribeSbv",
          "TranscribeSmi",
          "TranscribeSami",
          "TranscribeStl",
          "TranscribeSub",
          "AssociatedAsset",
          "MobiusLabsImageLabels",
          "MobiusLabsVideoAnalysis",
          "ContactSheetVTT",
          "ContactSheetTimecodes",
          "ContactSheetImage",
          "RenderedImage",
          "RokuBif",
          "MobiusLabsVideoExtractFeatures",
          "AzureImageAnalysis",
          "AzureImageVectorize",
          "AzureTextVectorize",
          "ContentVectors",
          "SceneXDescribe",
          "MobiusLabsLabelsExtractFeatures",
          "SportLogiqVideoAnalysis",
          "OciImageCaption",
          "OciTextVectorizer",
          "AnimatedGif",
          "OciTextSummary",
          "NomadMediaTasks",
          "GooglePhotosMetadata",
          "SageMakerImageToText",
          "TwelveLabsVideoAnalysis",
          "AccurateRegister",
          "BedrockImageAnalysis",
          "BedrockTextVectorizer",
          "BedrockImageVectorize",
          "BedrockTextSummary",
          "GeneratedImage",
          "TranscodeIvsRecording",
          "DolbyRaspRegister",
          "MobiusLabsLlmVideoAnalysis",
          "MobiusLabsLlmImageAnalysis",
          "TranscriptSummary",
          "SearchCache",
          "WhisperTranscription",
          "BitmovinSceneDetection",
          "BedrockDataAutomation",
          "BedrockSceneDetection",
          "MobiusLabsLlmSegmentContent",
          "AudioWaveform",
          "CustomType"
        ]
      },
      "MovieModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets an immutable string reference ID for the movie that does not exceed 50 characters.\r\nThis should serve as a unique identifier for the movie across different locales.\r\nOnce created, the ID for the content item may not be changed.\r\nRequired",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the movie title in plain text. This field is used for matching in Roku Search.\r\nDo not include extra information such as year, version label, and so on.\r\nRequired",
            "nullable": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentModel"
              }
            ],
            "description": "Gets or sets the video content, such as the URL of the video file, subtitles, and so on.\r\nRequired",
            "nullable": true
          },
          "genres": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of strings describing the genre(s) of the movie.\r\nMust be one of the values listed in https://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#genres\r\nRequired",
            "nullable": true
          },
          "thumbnail": {
            "type": "string",
            "description": "Gets or sets the URL of the thumbnail for the movie. This is used within the channel and in search results.\r\nImage dimensions must be at least 800x450 (width x height, 16x9 aspect ratio).\r\nRequired",
            "nullable": true
          },
          "releaseDate": {
            "type": "string",
            "description": "Gets or sets the date the movie was initially released or first aired.\r\nThis field is used to sort programs chronologically and group related content in Roku Search.\r\nConforms to the ISO 8601 format: {YYYY}-{MM}-{DD}. For example, 2020-11-11\r\nRequired",
            "nullable": true
          },
          "shortDescription": {
            "type": "string",
            "description": "Gets or sets a movie description that does not exceed 200 characters.\r\nThe text will be clipped if longer.\r\nRequired",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "description": "Gets or sets a longer movie description that does not exceed 500 characters.\r\nThe text will be clipped if longer.\r\nMust be different from shortDescription.\r\nRequired",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of one or more tags (for example, “dramas”, “korean”, and so on).\r\nEach tag is a string and is limited to 20 characters.\r\nTags are used to define what content will be shown within a category.\r\nOptional",
            "nullable": true
          },
          "credits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreditModel"
            },
            "description": "Gets or sets one or more credits. The cast and crew of the movie.\r\nOptional",
            "nullable": true
          },
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RatingModel"
              }
            ],
            "description": "Gets or sets a parental rating for the content.\r\nhttps://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#parental-ratings\r\nRequired",
            "nullable": true
          },
          "externalIds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            },
            "description": "Gets or sets one or more third-party metadata provider IDs.\r\nOptional",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a movie object."
      },
      "MyContentModel": {
        "type": "object",
        "properties": {
          "watchlist": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets list of ids of the media items in the user's watchlist (Favorites)",
            "nullable": true
          },
          "watching": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets list of ids of the media items the user is not done watching (Continue Watching)",
            "nullable": true
          },
          "likedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the media content the user liked",
            "nullable": true
          },
          "dislikedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the media content the user disliked",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a user's personalized content collections including watchlist, continue watching, liked, and disliked content."
      },
      "PerformerModel": {
        "type": "object",
        "properties": {
          "performerId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "nullable": true
          },
          "performerType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "dateOfBirth": {
            "type": "string",
            "format": "date-time"
          }
        },
        "additionalProperties": false
      },
      "PersonFaceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of this face detection result.",
            "format": "uuid"
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the asset (image) containing this face.",
            "format": "uuid"
          },
          "segmentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the video segment where this face was detected, if applicable.",
            "format": "uuid",
            "nullable": true
          },
          "videoAssetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the source video asset, if the face was detected in a video.",
            "format": "uuid",
            "nullable": true
          },
          "similarity": {
            "type": "number",
            "description": "Gets or sets the similarity score (0.0 to 100.0) indicating how closely this face matches the person.",
            "format": "double"
          },
          "boundingBox": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BoundingBoxModel"
              }
            ],
            "description": "Gets or sets the bounding box coordinates of the detected face within the image.",
            "nullable": true
          },
          "rotationCorrection": {
            "type": "integer",
            "description": "Gets or sets the rotation correction in degrees applied to normalize the face orientation.",
            "format": "int32",
            "nullable": true
          },
          "previewImageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the cropped preview image of the detected face.",
            "nullable": true
          },
          "previewImageHeight": {
            "type": "integer",
            "description": "Gets or sets the height in pixels of the preview image.",
            "format": "int32"
          },
          "previewImageWidth": {
            "type": "integer",
            "description": "Gets or sets the width in pixels of the preview image.",
            "format": "int32"
          },
          "displayName": {
            "type": "string",
            "description": "Gets or sets the display name associated with this face detection.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PersonFaceModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PersonFaceModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PersonFaceModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "PersonModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the person.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the person",
            "nullable": true
          },
          "automatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that are automatched for this person",
            "format": "int32",
            "nullable": true
          },
          "probableMatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that have been identified as probable matches for this person",
            "format": "int32",
            "nullable": true
          },
          "confirmedMatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that have been marked as confirmed for this person",
            "format": "int32",
            "nullable": true
          },
          "notMatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that have been marked as not a match for this person",
            "format": "int32",
            "nullable": true
          },
          "celebrityConfidence": {
            "type": "number",
            "description": "Gets or sets the % confidence of the celebrity name that was automatically detected through AI",
            "format": "float",
            "nullable": true
          },
          "celebrityExternalId": {
            "type": "string",
            "description": "Gets or sets the external (usually IMDB) ID of the celebrity that was identified",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PersonReferenceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "confidence": {
            "type": "number",
            "format": "double"
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PersonSubmitModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the person. Must be unique. Required.",
            "nullable": true
          },
          "matchedFaces": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of face IDs that match this person. This list contains only changed faces that have become matched.",
            "nullable": true
          },
          "unmatchedFaces": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of face IDs that do not match this person. This list contains only changed faces that have become not matched.",
            "nullable": true
          },
          "blurryFaces": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of face IDs that are blurry. This list contains only changed faces that are marked as blurry.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PingRequestModel": {
        "type": "object",
        "properties": {
          "userSessionId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the active user session to keep alive.",
            "format": "uuid"
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the optional application identifier associated with the session.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for the session ping/keep-alive endpoint."
      },
      "PingResponseModel": {
        "type": "object",
        "properties": {
          "redirectUrl": {
            "type": "string",
            "description": "Gets or sets a URL the client should redirect to, if applicable (e.g., when the session has expired or been replaced).",
            "nullable": true
          },
          "pingStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PingStatuses"
              }
            ],
            "description": "Gets or sets the status of the session ping. Normal indicates the session is active.\r\nAccountExpired or SessionReplaced indicate the client should terminate the session.\n\nNormal\n\nChatDisabled\n\nAccountExpired\n\nSessionDeactivated",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Response model for the session ping/keep-alive endpoint."
      },
      "PingStatuses": {
        "enum": [
          "Normal",
          "ChatDisabled",
          "AccountExpired",
          "SessionDeactivated"
        ],
        "type": "string",
        "description": "Indicates the status returned from a session ping/keep-alive request.\n\nNormal\n\nChatDisabled\n\nAccountExpired\n\nSessionDeactivated",
        "x-enumNames": [
          "Normal",
          "ChatDisabled",
          "AccountExpired",
          "SessionDeactivated"
        ]
      },
      "PlaylistModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the playlist. The name is limited to 20 characters.\r\nRequired",
            "nullable": true
          },
          "itemIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets an ordered list of one or more item IDs. An item ID is the ID of a movie/series/short-form video/TV special.\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "A playlist is an ordered list of videos that may contain a mix of Movies, Series, Short-form videos, and TV Specials.\r\nIt references a list of video IDs that are defined elsewhere in the feed. The same video can be referenced in multiple playlists.\r\nPlaylists are similar to tags: they help define the content that a channel's categories will display.\r\nThe main difference is that playlists enable the order of the content to be manually specified; therefore,\r\nplaylists are ideal for creating a \"Featured\" category in a channel, for example."
      },
      "PortalContentRequestModel": {
        "type": "object",
        "properties": {
          "returnedGroupNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of group names to include in the response. If null, all groups are returned.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for retrieving portal content groups."
      },
      "PortalModel": {
        "type": "object",
        "properties": {
          "featuredContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeaturedContentModel"
            },
            "description": "List of featured content items displayed prominently on the portal.",
            "nullable": true
          },
          "savedSearches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeaturedContentModel"
            },
            "description": "List of the user's saved searches.",
            "nullable": true
          },
          "contentGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeaturedContentModel"
            },
            "description": "List of content groups created by the user.",
            "nullable": true
          },
          "sharedContentGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeaturedContentModel"
            },
            "description": "List of content groups shared with the user by other users.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Response model containing portal navigation data including featured content, saved searches, and content groups."
      },
      "ProblemDetails": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "detail": {
            "type": "string",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": { }
      },
      "RatingModel": {
        "type": "object",
        "properties": {
          "rating": {
            "type": "string",
            "description": "Gets or sets must be a value listed in https://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#parental-ratings\r\nDo not include any content targeted specifically to children.\r\nIf you specify UNRATED, you do not need to provide the \"ratingSource\" field.\r\nRequired",
            "nullable": true
          },
          "ratingSource": {
            "type": "string",
            "description": "Gets or sets must be one of the following:\r\n    BBFC\r\n    CHVRS\r\n    CLASSIND\r\n    CPR\r\n    FSF\r\n    FSK\r\n    MPAA\r\n    UK_CP\r\n    USA_PR\r\nSee https://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#rating-sources for more information.\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents the rating for the video content.\r\nThe parental rating, as well as the source must be defined (for example, USA Parental Rating, UK Content Provider, and so on)."
      },
      "RecommendationActions": {
        "enum": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "type": "integer",
        "description": "\n\n0 = Click\n\n1 = Play\n\n2 = Watch\n\n3 = Bookmark\n\n4 = Preview\n\n5 = Purchase\n\n6 = Like\n\n7 = Dislike",
        "format": "int32",
        "x-enumNames": [
          "Click",
          "Play",
          "Watch",
          "Bookmark",
          "Preview",
          "Purchase",
          "Like",
          "Dislike"
        ]
      },
      "RefreshTokenRequestModel": {
        "required": [
          "refreshToken"
        ],
        "type": "object",
        "properties": {
          "refreshToken": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the refresh token obtained from a previous login or token refresh response. Required."
          }
        },
        "additionalProperties": false,
        "description": "Request model for exchanging a refresh token for a new JWT access token."
      },
      "RelatedAssetUploadStartRequestModel": {
        "type": "object",
        "properties": {
          "existingAssetId": {
            "type": "string",
            "description": "Gets or sets the Existing AssetId (file) that should be overwritten with this upload.\r\nNote that by specifying this attribute then the parentId, relativePath and displayName are all ignored.",
            "format": "uuid",
            "nullable": true
          },
          "relatedAssetId": {
            "type": "string",
            "description": "Gets or sets the related asset ID of the existingAsset that we're replacing. If this is used, most of the other properties are not needed.",
            "format": "uuid",
            "nullable": true
          },
          "newRelatedAssetMetadataType": {
            "type": "string",
            "description": "Gets or sets the type of the related asset metadata to be created for a given ExistingAssetId.\r\nIf specified, ExistingAssetId has to have a value defined.",
            "format": "uuid",
            "nullable": true
          },
          "relativePath": {
            "type": "string",
            "description": "Gets or sets the filename to upload - or a full path with the filename at the end.\r\nThis is ignored if the ExistingAssetId or if the RelatedContentId has a value",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "description": "Gets or sets the language of the asset to upload. If this is left blank then the default system language is used.",
            "format": "uuid",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "description": "Gets or sets the size of the asset to upload. This is used to calculate the upload parts.",
            "format": "int64"
          },
          "chunkSize": {
            "type": "integer",
            "description": "Gets or sets the size of the upload chunks. This should be adjusted to optimize the upload size based on the user's internet connection.",
            "format": "int64"
          },
          "uploadOverwriteOption": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UploadOverwriteOptions"
              }
            ],
            "description": "Gets or sets if the file already exists on the server, this decides how to handle the situation\n\nCancel\n\nContinue\n\nReplace\n\nAssetReplace",
            "x-enumNames": [
              "Cancel",
              "Continue",
              "Replace",
              "AssetReplace"
            ]
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties for the uploaded file",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
      },
      "RelatedContentModel": {
        "type": "object",
        "properties": {
          "contentDefinition": {
            "type": "string",
            "description": "Gets or sets the content definition string name of the content records that should be affected\r\nLike asset, video, etc",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the ID of the content record to apply the new or removed attributes",
            "format": "uuid"
          },
          "createNew": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether defaults to False. If true, then the attribute will be added if it doesn't already exist with a matching name"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the collection that should be added or removed. If the name and the collectionId are both specified, the name is ignored.",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets the id of the metadata content defintion, i.e. tags, collections",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "relatedContentId": {
            "type": "string",
            "description": "Gets or sets the related content ID that should be added or removed",
            "format": "uuid"
          },
          "childId": {
            "type": "string",
            "description": "Gets the child identifier, which is the related content identifier.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "childPropertyName": {
            "type": "string",
            "description": "Gets the name of the child property used for serialization.",
            "nullable": true,
            "readOnly": true
          },
          "indexPropertyName": {
            "type": "string",
            "description": "Gets the name of the index property used in search indexing.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the association between a content item and a related content item, used for linking or unlinking related content."
      },
      "RelatedContentModelListModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelatedContentModel"
            },
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "RelatedMediaItemModel": {
        "type": "object",
        "properties": {
          "relatedMediaItemId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "nullable": true
          },
          "previewUrl": {
            "type": "string",
            "nullable": true
          },
          "duration": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "rating": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "nullable": true
          },
          "shortDescription": {
            "type": "string",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "RenderSubtitlesModel": {
        "type": "object",
        "properties": {
          "showTimestamps": {
            "type": "boolean"
          },
          "showSpeakers": {
            "type": "boolean"
          },
          "useActualTime": {
            "type": "boolean"
          },
          "exportFormat": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TranscriptionContainerOutputTypes"
              }
            ],
            "description": "\n\n0 = DocX\n\n1 = Text\n\n2 = SRT\n\n3 = VTT",
            "x-enumNames": [
              "DocX",
              "Text",
              "SRT",
              "VTT"
            ]
          },
          "textTimePrefix": {
            "type": "string",
            "nullable": true
          },
          "textTimeSuffix": {
            "type": "string",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "format": "uuid"
          }
        },
        "additionalProperties": false
      },
      "ResendConfirmationCodeRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to re-send the verification code to. Required."
          }
        },
        "additionalProperties": false,
        "description": "Request model for re-sending the email verification confirmation code."
      },
      "ResetPasswordRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to reset. Required."
          },
          "token": {
            "type": "string",
            "description": "Gets or sets the verification code received via the forgot-password email.",
            "nullable": true
          },
          "newPassword": {
            "type": "string",
            "description": "Gets or sets the new password to set for the account.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for completing a password reset using a verification code."
      },
      "ResponseCookieWrapper": {
        "type": "object",
        "properties": {
          "internalCookies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets the list of cookie strings intended for internal processing and not included in serialized output.",
            "nullable": true,
            "readOnly": true
          },
          "responseCookies": {
            "description": "Gets the response body object that will be serialized and returned to the caller.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Wraps a response object along with associated cookies to be set on the HTTP response."
      },
      "ResponseHtmlWrapper": {
        "type": "object",
        "properties": {
          "html": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "SavedSearchAddModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Optional pre-assigned identifier. If null, a new ID is generated.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Display name of the saved search.",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "description": "Optional display order sequence number.",
            "format": "int32",
            "nullable": true
          },
          "criteria": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchModel"
              }
            ],
            "description": "The underlying search model containing filters, pagination, and query.",
            "nullable": true
          },
          "contentDefinitionIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Optional list of content definition IDs to restrict the search scope.",
            "nullable": true
          },
          "searchSortType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchSortTypes"
              }
            ],
            "description": "The default sort direction for search results.\n\n0 = Ascending\n\n1 = Descending",
            "nullable": true
          },
          "assetTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetTypes"
            },
            "description": "Optional filter to restrict results to specific asset types.",
            "nullable": true
          },
          "mediaTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaTypes"
            },
            "description": "Optional filter to restrict results to specific media types.",
            "nullable": true
          },
          "searchTextFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchTextFields"
            },
            "description": "Optional fields to search within for text queries.",
            "nullable": true
          },
          "advanceSearchFilters": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Key-value pairs of additional filter criteria.",
            "nullable": true
          },
          "sortField": {
            "type": "string",
            "description": "The field name to sort results by.",
            "nullable": true
          },
          "searchKeys": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Optional list of specific content IDs to include.",
            "nullable": true
          },
          "searchTerms": {
            "type": "string",
            "description": "Free-text search query terms.",
            "nullable": true
          },
          "featured": {
            "type": "boolean",
            "description": "Whether this saved search is marked as featured."
          },
          "bookmarked": {
            "type": "boolean",
            "description": "Whether this saved search is bookmarked by the user."
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Additional custom properties as key-value pairs.",
            "nullable": true
          },
          "searchDate": {
            "type": "string",
            "description": "Optional start date for date range filtering.",
            "format": "date-time",
            "nullable": true
          },
          "endSearchDate": {
            "type": "string",
            "description": "Optional end date for date range filtering.",
            "format": "date-time",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Optional list of tag IDs to filter by.",
            "nullable": true
          },
          "includeVideoClips": {
            "type": "boolean",
            "description": "When true, includes video clip assets in results.",
            "nullable": true
          },
          "useLlmSearch": {
            "type": "boolean",
            "description": "When true, uses LLM-powered semantic search.",
            "nullable": true
          },
          "includeFolders": {
            "type": "boolean",
            "description": "When true, includes folder assets in results.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Model for creating a new saved search."
      },
      "SavedSearchModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier of the saved search.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Display name of the saved search.",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "description": "Optional display order sequence number.",
            "format": "int32",
            "nullable": true
          },
          "user": {
            "type": "string",
            "description": "The ID of the user who owns this saved search.",
            "format": "uuid",
            "nullable": true
          },
          "criteria": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchModel"
              }
            ],
            "description": "The underlying search model containing filters, pagination, and query.",
            "nullable": true
          },
          "searchSortType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchSortTypes"
              }
            ],
            "description": "The default sort direction for search results.\n\n0 = Ascending\n\n1 = Descending",
            "nullable": true
          },
          "contentDefinitionIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Optional list of content definition IDs to restrict the search scope.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Optional list of tag IDs to filter by.",
            "nullable": true
          },
          "assetTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetTypes"
            },
            "description": "Optional filter to restrict results to specific asset types.",
            "nullable": true
          },
          "mediaTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaTypes"
            },
            "description": "Optional filter to restrict results to specific media types.",
            "nullable": true
          },
          "searchTextFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchTextFields"
            },
            "description": "Optional fields to search within for text queries.",
            "nullable": true
          },
          "advanceSearchFilters": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Key-value pairs of additional filter criteria.",
            "nullable": true
          },
          "sortField": {
            "type": "string",
            "description": "The field name to sort results by.",
            "nullable": true
          },
          "pageSize": {
            "type": "integer",
            "description": "Number of results to return per page. Defaults to 10.",
            "format": "int32"
          },
          "searchKeys": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Optional list of specific content IDs to include.",
            "nullable": true
          },
          "searchTerms": {
            "type": "string",
            "description": "Free-text search query terms.",
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FeaturedContentTypes"
              }
            ],
            "description": "The featured content type classification.\n\nList\n\nPreviewImage\n\nHeader",
            "x-enumNames": [
              "List",
              "PreviewImage",
              "Header"
            ]
          },
          "featured": {
            "type": "boolean",
            "description": "Whether this saved search is marked as featured."
          },
          "public": {
            "type": "boolean",
            "description": "Whether this saved search is publicly visible."
          },
          "bookmarked": {
            "type": "boolean",
            "description": "Whether this saved search is bookmarked by the user."
          },
          "searchDate": {
            "type": "string",
            "description": "Optional start date for date range filtering.",
            "format": "date-time",
            "nullable": true
          },
          "endSearchDate": {
            "type": "string",
            "description": "Optional end date for date range filtering.",
            "format": "date-time",
            "nullable": true
          },
          "previewAssetId": {
            "type": "string",
            "description": "Optional asset ID used as a preview thumbnail.",
            "format": "uuid",
            "nullable": true
          },
          "includeVideoClips": {
            "type": "boolean",
            "description": "When true, includes video clip assets in results.",
            "nullable": true
          },
          "useLlmSearch": {
            "type": "boolean",
            "description": "When true, uses LLM-powered semantic search.",
            "nullable": true
          },
          "includeFolders": {
            "type": "boolean",
            "description": "When true, includes folder assets in results.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Additional custom properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a persisted saved search with its full configuration."
      },
      "SavedSearchPatchModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "New display name for the saved search.",
            "nullable": true
          },
          "sequence": {
            "type": "integer",
            "description": "New display order sequence number.",
            "format": "int32",
            "nullable": true
          },
          "featured": {
            "type": "boolean",
            "description": "New featured status.",
            "nullable": true
          },
          "bookmarked": {
            "type": "boolean",
            "description": "New bookmarked status.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Model for partially updating a saved search. Only non-null fields are applied."
      },
      "ScaleFactor": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "value": {
            "type": "number",
            "format": "double"
          },
          "rankSeq": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SearchConditionBinders": {
        "enum": [
          0,
          1
        ],
        "type": "integer",
        "description": "\n\n0 = And\n\n1 = Or",
        "format": "int32",
        "x-enumNames": [
          "And",
          "Or"
        ]
      },
      "SearchFieldModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "order": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "loadDetail": {
            "type": "boolean"
          },
          "preventFormatting": {
            "type": "boolean"
          },
          "searchResultFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchFieldModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SearchFilter": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "nullable": true
          },
          "operator": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchFilterOperators"
              }
            ],
            "description": "\n\n0 = Equals\n\n1 = NotEquals\n\n2 = Contains\n\n3 = NotContains\n\n4 = Like\n\n5 = NotLike\n\n6 = LessThan\n\n7 = GreaterThan\n\n8 = LessThanEquals\n\n9 = GreaterThanEquals\n\n10 = Prefix",
            "x-enumNames": [
              "Equals",
              "NotEquals",
              "Contains",
              "NotContains",
              "Like",
              "NotLike",
              "LessThan",
              "GreaterThan",
              "LessThanEquals",
              "GreaterThanEquals",
              "Prefix"
            ]
          },
          "includeNull": {
            "type": "boolean"
          },
          "values": {
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "SearchFilterOperators": {
        "enum": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "type": "integer",
        "description": "\n\n0 = Equals\n\n1 = NotEquals\n\n2 = Contains\n\n3 = NotContains\n\n4 = Like\n\n5 = NotLike\n\n6 = LessThan\n\n7 = GreaterThan\n\n8 = LessThanEquals\n\n9 = GreaterThanEquals\n\n10 = Prefix",
        "format": "int32",
        "x-enumNames": [
          "Equals",
          "NotEquals",
          "Contains",
          "NotContains",
          "Like",
          "NotLike",
          "LessThan",
          "GreaterThan",
          "LessThanEquals",
          "GreaterThanEquals",
          "Prefix"
        ]
      },
      "SearchModel": {
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "description": "Gets or sets the size of the page (the number of items returned for this page)",
            "format": "int32"
          },
          "pageOffset": {
            "description": "Gets or sets the offset of the page (zero based).",
            "nullable": true
          },
          "searchQuery": {
            "type": "string",
            "description": "Gets or sets a text string to search within all of the text fields to match",
            "nullable": true
          },
          "filters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchFilter"
            },
            "description": "Gets or sets a list of the filters to apply for this search",
            "nullable": true
          },
          "searchTextFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchTextFields"
            },
            "description": "Gets or sets a list of the search text fields to apply for this search.",
            "nullable": true
          },
          "filterBinder": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchConditionBinders"
              }
            ],
            "description": "Gets or sets tells the query engine of the Filters should be applied as an And or an Or (the default is And)\n\n0 = And\n\n1 = Or",
            "x-enumNames": [
              "And",
              "Or"
            ]
          },
          "sortFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchSort"
            },
            "description": "Gets or sets the fields to sort by",
            "nullable": true
          },
          "returnedFieldNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "deprecated": true
          },
          "fullUrlFieldNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of fields that should have the FullURL calculated. The calculations are expensive and greatly slow down the query.\r\nUse this field to only return the ones that are actually needed.",
            "nullable": true
          },
          "distinctOnFieldName": {
            "type": "string",
            "description": "Gets or sets optional property that will be used to aggregate results records to distinct occurances of this field's values.",
            "nullable": true
          },
          "includeVideoClips": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether specify if the video search results are grouped by include clips of the videos also."
          },
          "searchResultFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchFieldModel"
            },
            "description": "Gets or sets the list of fields and optionally the sub fields and related records that should be returned as a result",
            "nullable": true
          },
          "similarAssetId": {
            "type": "string",
            "description": "Gets or sets when SimilarAssetId has a value, then the search results are a special type of results and bring back the items that are\r\nthe most similar to the item represented here. This search is only enabled when Vector searching has been enabled.\r\nWhen this has a value, the SearchQuery value and PageOffset values are ignored.",
            "format": "uuid",
            "nullable": true
          },
          "minScore": {
            "type": "number",
            "description": "Gets or sets specifies the minimum score to match when returning results. If omitted, the system default will be used - which is usually .65",
            "format": "double",
            "nullable": true
          },
          "excludeTotalRecordCount": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether normally, the total record count is returned but the query can be made faster if this value is excluded."
          },
          "useLlmSearch": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether gets or Sets a value representing if the search engine should try and use the LLM search instead of the standard search."
          }
        },
        "additionalProperties": false
      },
      "SearchProfileModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier of the search profile.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Display name of the search profile.",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "format": "uuid",
            "nullable": true,
            "deprecated": true
          },
          "dynamicFilterConfiguration": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "deprecated": true
          },
          "searchResultConfiguration": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "deprecated": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Additional custom properties as key-value pairs.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a user's search profile with default search configurations."
      },
      "SearchResultModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "masterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "contentDefinitionTitle": {
            "type": "string",
            "nullable": true
          },
          "keywordSearchField": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "assetDetailSearchField": {
            "type": "string",
            "nullable": true
          },
          "transcriptionSearchField": {
            "type": "string",
            "nullable": true
          },
          "customMetadataSearchField": {
            "type": "string",
            "nullable": true
          },
          "tagSearchField": {
            "type": "string",
            "nullable": true
          },
          "relatedContentSearchField": {
            "type": "string",
            "nullable": true
          },
          "collectionSearchField": {
            "type": "string",
            "nullable": true
          },
          "annotationSearchField": {
            "type": "string",
            "nullable": true
          },
          "aiLabelSearchField": {
            "type": "string",
            "nullable": true
          },
          "aiTextSearchField": {
            "type": "string",
            "nullable": true
          },
          "aiCaptionSearchField": {
            "type": "string",
            "nullable": true
          },
          "exifMetadataSearchField": {
            "type": "string",
            "nullable": true
          },
          "textContentSearchField": {
            "type": "string",
            "nullable": true
          },
          "contentSearchField": {
            "type": "string",
            "nullable": true
          },
          "timeCode": {
            "type": "string",
            "nullable": true
          },
          "previewImageUrl": {
            "type": "string",
            "nullable": true
          },
          "uuidSearchField": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "isRestricted": {
            "type": "boolean",
            "description": "Gets or sets this has the impact of not allowing downloading or clipping in the portal UI",
            "nullable": true
          },
          "isShared": {
            "type": "boolean",
            "description": "Gets or sets this isShared property for a index record, useful for downstream operations.",
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "identifiers": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "securitySearchField": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "inheritSecurity": {
            "type": "boolean"
          },
          "permission": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityPermissions"
              }
            ],
            "description": "\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
            "nullable": true
          },
          "contentLanguageStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentLanguageStatuses"
              }
            ],
            "description": "\n\nOriginal\n\nOverride\n\nAuto",
            "x-enumNames": [
              "Original",
              "Override",
              "Auto"
            ]
          },
          "originalLanguageName": {
            "type": "string",
            "nullable": true
          },
          "assetStats": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetStatsModel"
              }
            ],
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "shares": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "userContentAttributes": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserContentAttributeSummaryModel"
              }
            ],
            "nullable": true
          },
          "embeddings": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              },
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SearchResultModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "SearchSort": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "nullable": true
          },
          "sortType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchSortTypes"
              }
            ],
            "description": "\n\n0 = Ascending\n\n1 = Descending",
            "x-enumNames": [
              "Ascending",
              "Descending"
            ]
          },
          "position": {
            "type": "integer",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "SearchSortTypes": {
        "enum": [
          0,
          1
        ],
        "type": "integer",
        "description": "\n\n0 = Ascending\n\n1 = Descending",
        "format": "int32",
        "x-enumNames": [
          "Ascending",
          "Descending"
        ]
      },
      "SearchTextFields": {
        "enum": [
          "AssetDetails",
          "ExactTitle",
          "TextContents",
          "Transcripts",
          "CustomMetadata",
          "ExifMetadata",
          "Tags",
          "Collections",
          "RelatedContent",
          "Annotations",
          "AI_Labels",
          "AI_Text",
          "AI_Captions"
        ],
        "type": "string",
        "description": "\n\nAssetDetails\n\nExactTitle\n\nTextContents\n\nTranscripts\n\nCustomMetadata\n\nExifMetadata\n\nTags\n\nCollections\n\nRelatedContent\n\nAnnotations\n\nAI_Labels\n\nAI_Text\n\nAI_Captions",
        "x-enumNames": [
          "AssetDetails",
          "ExactTitle",
          "TextContents",
          "Transcripts",
          "CustomMetadata",
          "ExifMetadata",
          "Tags",
          "Collections",
          "RelatedContent",
          "Annotations",
          "AI_Labels",
          "AI_Text",
          "AI_Captions"
        ]
      },
      "SeasonModel": {
        "type": "object",
        "properties": {
          "seasonNumber": {
            "type": "integer",
            "description": "Gets or sets sequential season number (for example, 3 or 2015).\r\nRequired",
            "format": "int32"
          },
          "episodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EpisodeModel"
            },
            "description": "Gets or sets one or more episodes of this particular season.\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a single season of a series."
      },
      "SecurityPermissions": {
        "enum": [
          "Read",
          "FileWrite",
          "FolderWrite",
          "Administrator",
          "Guest"
        ],
        "type": "string",
        "description": "\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
        "x-enumNames": [
          "Read",
          "FileWrite",
          "FolderWrite",
          "Administrator",
          "Guest"
        ]
      },
      "SegmentModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "duration": {
            "type": "integer",
            "format": "int64"
          },
          "timestamp": {
            "type": "integer",
            "format": "int64"
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "SeriesModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets an immutable string reference ID for the series that does not exceed 50 characters.\r\nThis should serve as a unique identifier for the series across different locales.\r\nOnce created, the ID for the content item may not be changed.\r\nRequired",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the series in plain text. This field is used for matching in Roku Search.\r\nDo not include extra information such as year, version label, and so on.\r\nRequired",
            "nullable": true
          },
          "seasons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SeasonModel"
            },
            "description": "Gets or sets one or more seasons of the series. Seasons should be used if episodes are grouped by seasons.\r\nRequired (A series object must have either a seasons or episodes content object)",
            "nullable": true
          },
          "episodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EpisodeModel"
            },
            "description": "Gets or sets one or more episodes of the series. Episodes should be used if they are not grouped by seasons (e.g., a mini-series).\r\nRequired (A series object must have either a seasons or episodes content object)",
            "nullable": true
          },
          "genres": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of strings describing the genre(s) of the series.\r\nMust be one of the values listed in Genres.\r\nRequired",
            "nullable": true
          },
          "thumbnail": {
            "type": "string",
            "description": "Gets or sets the URL of the thumbnail for the series. This is used within the channel and in search results.\r\nImage dimensions must be at least 800x450 (width x height, 16x9 aspect ratio).\r\nRequired",
            "nullable": true
          },
          "releaseDate": {
            "type": "string",
            "description": "Gets or sets the date the series first aired. This field is used to sort programs chronologically and group related content in Roku Search.\r\nConforms to ISO 8601 format: {YYYY}-{MM}-{DD}. For example, 2020-11-11\r\nRequired",
            "nullable": true
          },
          "shortDescription": {
            "type": "string",
            "description": "Gets or sets a description of the series that does not exceed 200 characters. The text will be clipped if longer.\r\nRequired",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "description": "Gets or sets a longer movie description that does not exceed 500 characters. The text will be clipped if longer.\r\nMust be different from shortDescription.\r\nOptional",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of one or more tags (for example, “dramas”, “korean”, and so on).\r\nEach tag is a string and is limited to 20 characters. Tags are used to define what content will be shown within a category.\r\nOptional",
            "nullable": true
          },
          "credits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreditModel"
            },
            "description": "Gets or sets one or more credits. The cast and crew of the movie.\r\nOptional",
            "nullable": true
          },
          "externalIds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            },
            "description": "Gets or sets one or more third-party metadata provider IDs.\r\nOptional",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a series, such as a season of a TV Show or a mini-series."
      },
      "ShareAddModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the share; if null, a new share will be created.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the share.",
            "nullable": true
          },
          "sharedContents": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of content identifiers included in this share.",
            "nullable": true
          },
          "sharedDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the duration setting that controls how long the share remains active.",
            "nullable": true
          },
          "sharedPermissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of permission levels granted to recipients of this share.",
            "nullable": true
          },
          "sharedType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of share (e.g., link-based, user-based).",
            "nullable": true
          },
          "sharedStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the share.",
            "nullable": true
          },
          "sharedDurationInHours": {
            "type": "integer",
            "description": "Gets or sets the duration of the share in hours.",
            "format": "int32",
            "nullable": true
          },
          "sharedLink": {
            "type": "string",
            "description": "Gets or sets the URL link that provides access to the shared content.",
            "nullable": true
          },
          "ownerId": {
            "type": "string",
            "description": "Gets or sets the identifier of the user who owns this share.",
            "format": "uuid",
            "nullable": true
          },
          "expirationDate": {
            "type": "string",
            "description": "Gets or sets the date and time when this share expires and is no longer accessible.",
            "format": "date-time",
            "nullable": true
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the asset identifier for internal user-to-user sharing.",
            "format": "uuid"
          },
          "nomadUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of platform users who have been granted access to the shared content.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for creating a new share."
      },
      "ShareModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the share; if null, a new share will be created.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the share.",
            "nullable": true
          },
          "sharedContents": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of content identifiers included in this share.",
            "nullable": true
          },
          "sharedDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the duration setting that controls how long the share remains active.",
            "nullable": true
          },
          "sharedPermissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of permission levels granted to recipients of this share.",
            "nullable": true
          },
          "sharedType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of share (e.g., link-based, user-based).",
            "nullable": true
          },
          "sharedStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the share.",
            "nullable": true
          },
          "sharedDurationInHours": {
            "type": "integer",
            "description": "Gets or sets the duration of the share in hours.",
            "format": "int32",
            "nullable": true
          },
          "sharedLink": {
            "type": "string",
            "description": "Gets or sets the URL link that provides access to the shared content.",
            "nullable": true
          },
          "ownerId": {
            "type": "string",
            "description": "Gets or sets the identifier of the user who owns this share.",
            "format": "uuid",
            "nullable": true
          },
          "expirationDate": {
            "type": "string",
            "description": "Gets or sets the date and time when this share expires and is no longer accessible.",
            "format": "date-time",
            "nullable": true
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the asset identifier for internal user-to-user sharing.",
            "format": "uuid"
          },
          "nomadUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of platform users who have been granted access to the shared content.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
      },
      "ShareNotificationModel": {
        "type": "object",
        "properties": {
          "shareId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the share to send notifications for.",
            "format": "uuid"
          },
          "nomadUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of platform users to notify about the share.",
            "nullable": true
          },
          "externalUsers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of external email addresses to notify about the share.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for sending a share notification to recipients."
      },
      "ShareUpdateModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the share; if null, a new share will be created.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the share.",
            "nullable": true
          },
          "sharedContents": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of content identifiers included in this share.",
            "nullable": true
          },
          "sharedDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the duration setting that controls how long the share remains active.",
            "nullable": true
          },
          "sharedPermissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of permission levels granted to recipients of this share.",
            "nullable": true
          },
          "sharedType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of share (e.g., link-based, user-based).",
            "nullable": true
          },
          "sharedStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the share.",
            "nullable": true
          },
          "sharedDurationInHours": {
            "type": "integer",
            "description": "Gets or sets the duration of the share in hours.",
            "format": "int32",
            "nullable": true
          },
          "sharedLink": {
            "type": "string",
            "description": "Gets or sets the URL link that provides access to the shared content.",
            "nullable": true
          },
          "ownerId": {
            "type": "string",
            "description": "Gets or sets the identifier of the user who owns this share.",
            "format": "uuid",
            "nullable": true
          },
          "expirationDate": {
            "type": "string",
            "description": "Gets or sets the date and time when this share expires and is no longer accessible.",
            "format": "date-time",
            "nullable": true
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the asset identifier for internal user-to-user sharing.",
            "format": "uuid"
          },
          "nomadUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of platform users who have been granted access to the shared content.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for updating an existing share."
      },
      "ShortFormVideoModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets an immutable string reference ID for the video that does not exceed 50 characters.\r\nThis should serve as a unique identifier for the episode across different locales.\r\nOnce created, the ID for the content item may not be changed.\r\nRequired",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the video in plain text. This field is used for matching in Roku Search.\r\nDo not include extra information such as year, version label, and so on.\r\nRequired",
            "nullable": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentModel"
              }
            ],
            "description": "Gets or sets the video content, such as the URL of the video file, subtitles, and so on.\r\nRequired",
            "nullable": true
          },
          "thumbnail": {
            "type": "string",
            "description": "Gets or sets the URL of the thumbnail for the video. This is used within your channel and in search results.\r\nImage dimensions must be at least 800x450 (width x height, 16x9 aspect ratio).\r\nRequired",
            "nullable": true
          },
          "shortDescription": {
            "type": "string",
            "description": "Gets or sets a description of the video that does not exceed 200 characters. The text will be clipped if longer.\r\nRequired",
            "nullable": true
          },
          "releaseDate": {
            "type": "string",
            "description": "Gets or sets the date the video first became available. This field is used to sort programs chronologically and group related content in Roku Search.\r\nConforms to ISO 8601 format: {YYYY}-{MM}-{DD}. For example, 2020-11-11\r\nRequired",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "description": "Gets or sets a longer description that does not exceed 500 characters. The text will be clipped if longer. Must be different from shortDescription.\r\nRequired",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets one or more tags (e.g., “dramas”, “korean”, etc). Each tag is a string and is limited to 20 characters.\r\nTags are used to define what content will be shown within a category.\r\nOptional",
            "nullable": true
          },
          "genres": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of strings describing the genre(s) of the video.\r\nMust be one of the values listed in https://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#genres.\r\nOptional",
            "nullable": true
          },
          "credits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreditModel"
            },
            "description": "Gets or sets one or more credits. The cast and crew of the movie.\r\nOptional",
            "nullable": true
          },
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RatingModel"
              }
            ],
            "description": "Gets or sets a parental rating for the content.\r\nhttps://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#parental-ratings\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Short-form videos are generally less than 15 minutes long, and are not TV Shows or Movies."
      },
      "SiteConfigModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the site configuration.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the site configuration.",
            "nullable": true
          },
          "headerLogoImage": {
            "type": "string",
            "description": "Gets or sets the URL of the header logo image displayed in the site navigation.",
            "nullable": true
          },
          "loginLogoImage": {
            "type": "string",
            "description": "Gets or sets the URL of the logo image displayed on the login page.",
            "nullable": true
          },
          "backgroundImage": {
            "type": "string",
            "description": "Gets or sets the URL of the background image for the site.",
            "nullable": true
          },
          "favIcon": {
            "type": "string",
            "description": "Gets or sets the URL of the favicon for the site.",
            "nullable": true
          },
          "backgroundImageMobile": {
            "type": "string",
            "description": "Gets or sets the URL of the background image optimized for mobile devices.",
            "nullable": true
          },
          "googleTagManager": {
            "type": "string",
            "description": "Gets or sets the Google Tag Manager container identifier for analytics tracking.",
            "nullable": true
          },
          "postLoginMessage": {
            "type": "string",
            "description": "Gets or sets the message displayed to users after successful login.",
            "nullable": true
          },
          "preUserRegistration": {
            "type": "string",
            "description": "Gets or sets the message or instructions displayed before user registration.",
            "nullable": true
          },
          "downloadAlert": {
            "type": "string",
            "description": "Gets or sets the alert message displayed to users before downloading content.",
            "nullable": true
          },
          "cookieConsent": {
            "type": "string",
            "description": "Gets or sets the cookie consent message or configuration for the site.",
            "nullable": true
          },
          "showTitleBelowThumbnail": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to display the item title below the thumbnail image."
          },
          "bitmovinLicenseKey": {
            "type": "string",
            "description": "Gets or sets the Bitmovin video player license key.",
            "nullable": true
          },
          "bitmovinAnalyticsLicenseKey": {
            "type": "string",
            "description": "Gets or sets the Bitmovin analytics license key for video playback tracking.",
            "nullable": true
          },
          "landingPageMediaGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the media group displayed on the landing page before user login.",
            "nullable": true
          },
          "homeMediaGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the media group displayed on the home page after user login.",
            "nullable": true
          },
          "myContentMediaGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the media group used for the My Content section.",
            "nullable": true
          },
          "defaultMediaItemThumbnail": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the default thumbnail image used when a media item has no thumbnail.",
            "nullable": true
          },
          "theme": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the visual theme applied to the portal site.",
            "nullable": true
          },
          "enableFixedHeader": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the header remains fixed at the top during scrolling."
          },
          "allowLike": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether users are allowed to like content."
          },
          "requireLogin": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether login is required to access the portal."
          },
          "allowDislike": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether users are allowed to dislike content."
          },
          "userProperties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserPropertyModel"
            },
            "description": "Gets or sets the collection of configurable user profile properties.",
            "nullable": true
          },
          "lookups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfigLookupModel"
            },
            "description": "Gets or sets the collection of configuration lookup values used by the portal.",
            "nullable": true
          },
          "players": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VideoPlayerProfile"
            },
            "description": "Gets or sets the collection of video player profile configurations.",
            "nullable": true
          },
          "enabledLanguages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of languages enabled for the portal.",
            "nullable": true
          },
          "videoTrackingBeaconIntervalInSeconds": {
            "type": "integer",
            "description": "Gets or sets the interval in seconds between video tracking beacon events sent during playback.",
            "format": "int32",
            "nullable": true
          },
          "authProviders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthProviderModel"
            },
            "description": "Gets or sets the collection of authentication providers available for user login.",
            "nullable": true
          },
          "customItemProperties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IncludeCustomFieldModel"
            },
            "description": "Gets or sets the collection of custom field definitions to include on media item detail views.",
            "nullable": true
          },
          "enableAds": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether advertisement integration is enabled. Not serialized to the client."
          },
          "enableRecommendations": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether content recommendations are enabled. Not serialized to the client."
          }
        },
        "additionalProperties": false,
        "description": "Represents the portal site configuration including branding, theming, authentication providers, video player settings, and feature flags."
      },
      "StageLoginResponseModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the authenticated user.",
            "format": "uuid"
          },
          "userName": {
            "type": "string",
            "description": "Gets or sets the username (email address) of the authenticated user.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the authenticated user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the authenticated user.",
            "nullable": true
          },
          "loginStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LoginResponseStatuses"
              }
            ],
            "description": "Gets or sets the login status indicating the result of the authentication attempt.\r\nA null value typically indicates success. Non-null values indicate a specific condition\r\n(e.g., IsDisabled, RequiresNewPassword, IsPendingEmailConfirmation).\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
            "nullable": true
          },
          "cookies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LoginCookieModel"
            },
            "description": "Gets or sets the list of cookies to be set on the client after a successful login.",
            "nullable": true
          },
          "configUrl": {
            "type": "string",
            "description": "Gets or sets the URL to retrieve the stage configuration from.",
            "nullable": true
          },
          "redirectUrl": {
            "type": "string",
            "description": "Gets or sets the URL to redirect the user to after successful stage login.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response returned after a successful stage login, extending the base login response with configuration and redirect URLs."
      },
      "StagePingResponseModel": {
        "type": "object",
        "properties": {
          "redirectUrl": {
            "type": "string",
            "description": "Gets or sets the URL to redirect the client to if the stage requires relocation.",
            "nullable": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PingStatuses"
              }
            ],
            "description": "Gets or sets the current ping status of the stage.\n\nNormal\n\nChatDisabled\n\nAccountExpired\n\nSessionDeactivated",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response returned from a stage ping health check, indicating the current status and any required redirect."
      },
      "StartTransactionRequestModel": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user initiating the transaction.",
            "format": "uuid",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user making the payment.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user making the payment.",
            "nullable": true
          },
          "email": {
            "type": "string",
            "description": "Gets or sets the email address of the user making the payment.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Gets or sets the monetary amount to charge for the transaction.",
            "format": "float"
          },
          "description": {
            "type": "string",
            "description": "Gets or sets a description of what the payment is for.",
            "nullable": true
          },
          "productId": {
            "type": "string",
            "description": "Gets or sets this represents the DynamoDB Product ID",
            "format": "uuid",
            "nullable": true
          },
          "customerId": {
            "type": "string",
            "description": "Gets or sets tODO: Gabe - Ask Adam",
            "nullable": true
          },
          "priceId": {
            "type": "string",
            "description": "Gets or sets tODO: Gabe - Ask Adam",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to initiate a payment transaction with user details, amount, and product information."
      },
      "StartTransactionResponseModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the payment transaction. This is used in all future API calls about the transaction",
            "format": "uuid"
          },
          "clientSecret": {
            "type": "string",
            "description": "Gets or sets the merchant processor secret key value that is used in communication between the client and the merchant server processor directly",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response returned after initiating a payment transaction, containing the transaction identifier and client secret for merchant communication."
      },
      "StatisiticsData": {
        "type": "object",
        "properties": {
          "dataSets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StatisiticsDataSet"
            },
            "description": "Gets or sets the list of datasets to render in the chart.",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the axis labels for the chart. Not currently used.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the data portion of a chart, containing datasets and axis labels."
      },
      "StatisiticsDataGraph": {
        "type": "object",
        "properties": {
          "data": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsData"
              }
            ],
            "description": "Gets or sets the chart data containing datasets and labels.",
            "nullable": true
          },
          "options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptions"
              }
            ],
            "description": "Gets or sets the chart display options including axis configuration.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a single chart graph containing data and display options for a statistics measurement."
      },
      "StatisiticsDataGraphOptions": {
        "type": "object",
        "properties": {
          "indexAxis": {
            "type": "string",
            "description": "Gets or sets the index axis for the chart. Defaults to \"x\".",
            "nullable": true
          },
          "scales": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptionsScales"
              }
            ],
            "description": "Gets or sets the axis scale configuration for the chart.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents chart display options including axis configuration and scale settings."
      },
      "StatisiticsDataGraphOptionsScales": {
        "type": "object",
        "properties": {
          "xaxis": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptionsScalesAxis"
              }
            ],
            "description": "Gets or sets the X-axis scale configuration.",
            "nullable": true
          },
          "yaxis": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptionsScalesAxis"
              }
            ],
            "description": "Gets or sets the Y-axis scale configuration.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the X and Y axis scale configurations for a statistics chart."
      },
      "StatisiticsDataGraphOptionsScalesAxis": {
        "type": "object",
        "properties": {
          "suggestedMin": {
            "type": "string",
            "description": "Gets or sets the suggested minimum value for the axis.",
            "nullable": true
          },
          "suggestedMax": {
            "type": "string",
            "description": "Gets or sets the suggested maximum value for the axis.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the scale configuration for a single chart axis, including suggested minimum and maximum values."
      },
      "StatisiticsDataSet": {
        "type": "object",
        "properties": {
          "noData": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether this dataset has no data points."
          },
          "unitLabel": {
            "type": "string",
            "description": "Gets or sets the unit label for the dataset values (e.g., \"GB\", \"hours\").",
            "nullable": true
          },
          "unitScaleFactor": {
            "type": "number",
            "description": "Gets or sets the scale factor applied to the dataset unit values. Defaults to 1.0.",
            "format": "double"
          },
          "type": {
            "type": "string",
            "description": "Gets or sets the chart type for this dataset (e.g., \"line\", \"bar\"). Defaults to \"line\".",
            "nullable": true
          },
          "stackName": {
            "type": "string",
            "description": "Gets or sets the stack name for grouping this dataset in stacked chart visualizations.",
            "nullable": true
          },
          "label": {
            "type": "string",
            "description": "Gets or sets the display label for this dataset in the chart legend.",
            "nullable": true
          },
          "measurementName": {
            "type": "string",
            "description": "Gets or sets the name of the measurement this dataset represents.",
            "nullable": true
          },
          "measurementDomainName": {
            "type": "string",
            "description": "Gets or sets the domain name of the measurement this dataset represents.",
            "nullable": true
          },
          "group": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the grouping field values that define this dataset's group.",
            "nullable": true
          },
          "data": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of data values as strings for the chart.",
            "nullable": true
          },
          "minDataValue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BigDecimal"
              }
            ],
            "description": "Gets or sets the minimum data value in the dataset, used for axis scaling.",
            "nullable": true
          },
          "maxDataValue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BigDecimal"
              }
            ],
            "description": "Gets or sets the maximum data value in the dataset, used for axis scaling.",
            "nullable": true
          },
          "groupKey": {
            "type": "string",
            "description": "Gets or sets the computed group key used internally for dataset grouping. Not serialized.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a single dataset within a chart, containing the data series, labels, and rendering configuration."
      },
      "StatisticsConfigResultModel": {
        "type": "object",
        "properties": {
          "measurements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MeasurementInfo"
            },
            "description": "Gets or sets the list of available measurement definitions.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the result of a statistics configuration query, containing available measurement definitions."
      },
      "StatisticsListModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the statistics metric.",
            "nullable": true
          },
          "group": {
            "type": "string",
            "description": "Gets or sets the grouping category for the statistics entry.",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "description": "Gets or sets the aggregated count for this statistics entry.",
            "format": "int64"
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the content item associated with this statistics entry, if applicable.",
            "format": "uuid",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the identifier of the application associated with this statistics entry, if applicable.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an aggregated statistics entry with a count grouped by name, group, content, or application."
      },
      "StatisticsRequestModel": {
        "type": "object",
        "properties": {
          "startDate": {
            "type": "string",
            "description": "Gets or sets the start date of the statistics query period.",
            "format": "date-time",
            "nullable": true
          },
          "endDate": {
            "type": "string",
            "description": "Gets or sets the end date of the statistics query period.",
            "format": "date-time",
            "nullable": true
          },
          "measurements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MeasurementRequest"
            },
            "description": "Gets or sets the list of measurement requests specifying which metrics to retrieve.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
      },
      "StorageClasses": {
        "enum": [
          "Standard",
          "ReducedRedundancy",
          "Glacier",
          "StandardInfrequentAccess",
          "OneZoneInfrequentAccess",
          "IntelligentTiering",
          "DeepArchive",
          "GlacierInstantRetrieval",
          "Outposts"
        ],
        "type": "string",
        "description": "\n\nStandard\n\nReducedRedundancy\n\nGlacier\n\nStandardInfrequentAccess\n\nOneZoneInfrequentAccess\n\nIntelligentTiering\n\nDeepArchive\n\nGlacierInstantRetrieval\n\nOutposts",
        "x-enumNames": [
          "Standard",
          "ReducedRedundancy",
          "Glacier",
          "StandardInfrequentAccess",
          "OneZoneInfrequentAccess",
          "IntelligentTiering",
          "DeepArchive",
          "GlacierInstantRetrieval",
          "Outposts"
        ]
      },
      "StreamsModel": {
        "type": "object",
        "properties": {
          "counties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collection of counties associated with the available streams.",
            "nullable": true
          },
          "streams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the collection of stream asset references available for playback.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a collection of live or recorded streams organized by county for the judicial portal."
      },
      "TagContentModel": {
        "type": "object",
        "properties": {
          "contentDefinition": {
            "type": "string",
            "description": "Gets or sets the content definition string name of the content records that should be affected\r\nLike asset, video, etc",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the ID of the content record to apply the new or removed attributes",
            "format": "uuid"
          },
          "createNew": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether defaults to False. If true, then the attribute will be added if it doesn't already exist with a matching name"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the collection that should be added or removed. If the name and the collectionId are both specified, the name is ignored.",
            "nullable": true
          },
          "tagId": {
            "type": "string",
            "description": "Gets or sets the tag ID that should be added or removed",
            "format": "uuid",
            "nullable": true
          },
          "childId": {
            "type": "string",
            "description": "Gets the child identifier, which is the tag identifier.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "childPropertyName": {
            "type": "string",
            "description": "Gets the name of the child property used for serialization.",
            "nullable": true,
            "readOnly": true
          },
          "indexPropertyName": {
            "type": "string",
            "description": "Gets the name of the index property used in search indexing.",
            "nullable": true,
            "readOnly": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets the content definition identifier for tags.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the association between a content item and a tag, used for adding or removing tags from content."
      },
      "TagContentModelListModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagContentModel"
            },
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "TextCaptionModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "externalId": {
            "type": "string",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "textCaptionType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TextCaptionTypes"
              }
            ],
            "description": "\n\nVerbose\n\nConcise\n\nTranscript",
            "x-enumNames": [
              "Verbose",
              "Concise",
              "Transcript"
            ]
          }
        },
        "additionalProperties": false
      },
      "TextCaptionTypes": {
        "enum": [
          "Verbose",
          "Concise",
          "Transcript"
        ],
        "type": "string",
        "description": "\n\nVerbose\n\nConcise\n\nTranscript",
        "x-enumNames": [
          "Verbose",
          "Concise",
          "Transcript"
        ]
      },
      "TextItemGroupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "contentTextType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentTextTypes"
              }
            ],
            "description": "\n\nLine\n\nWord\n\nPerson\n\nLocation\n\nOrganization\n\nCommercialItem\n\nEvent\n\nDate\n\nQuantity\n\nTitle\n\nEntity\n\nKeyPhrase\n\nMixedSentiment\n\nNegativeSentiment\n\nNeutralSentiment\n\nPositiveSentiment\n\nTranscript\n\nOther",
            "x-enumNames": [
              "Line",
              "Word",
              "Person",
              "Location",
              "Organization",
              "CommercialItem",
              "Event",
              "Date",
              "Quantity",
              "Title",
              "Entity",
              "KeyPhrase",
              "MixedSentiment",
              "NegativeSentiment",
              "NeutralSentiment",
              "PositiveSentiment",
              "Transcript",
              "Other"
            ]
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextItemModel"
            },
            "nullable": true
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "Note that this is a PARTIAL list of types that we need to know about\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "x-enumNames": [
              "DocumentContent",
              "ComprehendKeyPhrases",
              "ComprehendEntities",
              "RekognitionImageIndexFaces",
              "RekognitionImageSearchFaces",
              "RekognitionImageLabels",
              "RekognitionImageCelebrityRecognition",
              "RekognitionVideoLabels",
              "TextractAnalyzeDocument",
              "Transcribe",
              "TranscribeVtt",
              "TranscribeTranslation",
              "TranscribeVttTranslation",
              "RekognitionVideoCelebrityRecognition",
              "RekognitionVideoPersonTracking",
              "RekognitionVideoFaceDetection",
              "ImageInfo",
              "Transcode",
              "Clip",
              "MediaInfo",
              "RekognitionImageDetectText",
              "RekognitionImageUnsafeContent",
              "RekognitionVideoUnsafeContent",
              "Screenshot",
              "SageMakerGroundTruthLabelResults",
              "ThumbnailSheet",
              "ThumbnailImage",
              "SageMakerInvokeEndpointResults",
              "SageMakerModelLabels",
              "RekognitionImageCustomLabels",
              "SageMakerManifest",
              "PreviewImage",
              "RekognitionVideoTextDetection",
              "RekognitionVideoSegmentDetection",
              "NomadVideoSegmentDetection",
              "TranscribeMedical",
              "PreviewAudio",
              "Text",
              "AssetManifest",
              "IntervalSegments",
              "TranscribeMedicalText",
              "TranscribeMedicalTranslation",
              "AdobeMetadata",
              "AdobeMetadataText",
              "ImageExif",
              "TextractImageDetectText",
              "AdSegments",
              "Vmap",
              "Vast",
              "MediaTailorVideo",
              "TranscribeSrt",
              "TranscribeRaw",
              "Subtitles",
              "VizRtMetadata",
              "ProcessorJobs",
              "OfficeDocument",
              "TranscriptionContainer",
              "ComprehendSentiment",
              "ComprehendLanguage",
              "OriginalSourceVideo",
              "ImportManifest",
              "TranscribeScc",
              "TranscribeTtml",
              "TranscribeDfxp",
              "TranscribeSmptett",
              "TranscribeXml",
              "TranscribeQt",
              "TranscribeRt",
              "TranscribeSsa",
              "TranscribeAss",
              "TranscribeSbv",
              "TranscribeSmi",
              "TranscribeSami",
              "TranscribeStl",
              "TranscribeSub",
              "AssociatedAsset",
              "MobiusLabsImageLabels",
              "MobiusLabsVideoAnalysis",
              "ContactSheetVTT",
              "ContactSheetTimecodes",
              "ContactSheetImage",
              "RenderedImage",
              "RokuBif",
              "MobiusLabsVideoExtractFeatures",
              "AzureImageAnalysis",
              "AzureImageVectorize",
              "AzureTextVectorize",
              "ContentVectors",
              "SceneXDescribe",
              "MobiusLabsLabelsExtractFeatures",
              "SportLogiqVideoAnalysis",
              "OciImageCaption",
              "OciTextVectorizer",
              "AnimatedGif",
              "OciTextSummary",
              "NomadMediaTasks",
              "GooglePhotosMetadata",
              "SageMakerImageToText",
              "TwelveLabsVideoAnalysis",
              "AccurateRegister",
              "BedrockImageAnalysis",
              "BedrockTextVectorizer",
              "BedrockImageVectorize",
              "BedrockTextSummary",
              "GeneratedImage",
              "TranscodeIvsRecording",
              "DolbyRaspRegister",
              "MobiusLabsLlmVideoAnalysis",
              "MobiusLabsLlmImageAnalysis",
              "TranscriptSummary",
              "SearchCache",
              "WhisperTranscription",
              "BitmovinSceneDetection",
              "BedrockDataAutomation",
              "BedrockSceneDetection",
              "MobiusLabsLlmSegmentContent",
              "AudioWaveform",
              "CustomType"
            ]
          }
        },
        "additionalProperties": false
      },
      "TextItemModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "value": {
            "type": "string",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "nullable": true
          },
          "contextTextType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentTextTypes"
              }
            ],
            "description": "\n\nLine\n\nWord\n\nPerson\n\nLocation\n\nOrganization\n\nCommercialItem\n\nEvent\n\nDate\n\nQuantity\n\nTitle\n\nEntity\n\nKeyPhrase\n\nMixedSentiment\n\nNegativeSentiment\n\nNeutralSentiment\n\nPositiveSentiment\n\nTranscript\n\nOther",
            "x-enumNames": [
              "Line",
              "Word",
              "Person",
              "Location",
              "Organization",
              "CommercialItem",
              "Event",
              "Date",
              "Quantity",
              "Title",
              "Entity",
              "KeyPhrase",
              "MixedSentiment",
              "NegativeSentiment",
              "NeutralSentiment",
              "PositiveSentiment",
              "Transcript",
              "Other"
            ]
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "Note that this is a PARTIAL list of types that we need to know about\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "x-enumNames": [
              "DocumentContent",
              "ComprehendKeyPhrases",
              "ComprehendEntities",
              "RekognitionImageIndexFaces",
              "RekognitionImageSearchFaces",
              "RekognitionImageLabels",
              "RekognitionImageCelebrityRecognition",
              "RekognitionVideoLabels",
              "TextractAnalyzeDocument",
              "Transcribe",
              "TranscribeVtt",
              "TranscribeTranslation",
              "TranscribeVttTranslation",
              "RekognitionVideoCelebrityRecognition",
              "RekognitionVideoPersonTracking",
              "RekognitionVideoFaceDetection",
              "ImageInfo",
              "Transcode",
              "Clip",
              "MediaInfo",
              "RekognitionImageDetectText",
              "RekognitionImageUnsafeContent",
              "RekognitionVideoUnsafeContent",
              "Screenshot",
              "SageMakerGroundTruthLabelResults",
              "ThumbnailSheet",
              "ThumbnailImage",
              "SageMakerInvokeEndpointResults",
              "SageMakerModelLabels",
              "RekognitionImageCustomLabels",
              "SageMakerManifest",
              "PreviewImage",
              "RekognitionVideoTextDetection",
              "RekognitionVideoSegmentDetection",
              "NomadVideoSegmentDetection",
              "TranscribeMedical",
              "PreviewAudio",
              "Text",
              "AssetManifest",
              "IntervalSegments",
              "TranscribeMedicalText",
              "TranscribeMedicalTranslation",
              "AdobeMetadata",
              "AdobeMetadataText",
              "ImageExif",
              "TextractImageDetectText",
              "AdSegments",
              "Vmap",
              "Vast",
              "MediaTailorVideo",
              "TranscribeSrt",
              "TranscribeRaw",
              "Subtitles",
              "VizRtMetadata",
              "ProcessorJobs",
              "OfficeDocument",
              "TranscriptionContainer",
              "ComprehendSentiment",
              "ComprehendLanguage",
              "OriginalSourceVideo",
              "ImportManifest",
              "TranscribeScc",
              "TranscribeTtml",
              "TranscribeDfxp",
              "TranscribeSmptett",
              "TranscribeXml",
              "TranscribeQt",
              "TranscribeRt",
              "TranscribeSsa",
              "TranscribeAss",
              "TranscribeSbv",
              "TranscribeSmi",
              "TranscribeSami",
              "TranscribeStl",
              "TranscribeSub",
              "AssociatedAsset",
              "MobiusLabsImageLabels",
              "MobiusLabsVideoAnalysis",
              "ContactSheetVTT",
              "ContactSheetTimecodes",
              "ContactSheetImage",
              "RenderedImage",
              "RokuBif",
              "MobiusLabsVideoExtractFeatures",
              "AzureImageAnalysis",
              "AzureImageVectorize",
              "AzureTextVectorize",
              "ContentVectors",
              "SceneXDescribe",
              "MobiusLabsLabelsExtractFeatures",
              "SportLogiqVideoAnalysis",
              "OciImageCaption",
              "OciTextVectorizer",
              "AnimatedGif",
              "OciTextSummary",
              "NomadMediaTasks",
              "GooglePhotosMetadata",
              "SageMakerImageToText",
              "TwelveLabsVideoAnalysis",
              "AccurateRegister",
              "BedrockImageAnalysis",
              "BedrockTextVectorizer",
              "BedrockImageVectorize",
              "BedrockTextSummary",
              "GeneratedImage",
              "TranscodeIvsRecording",
              "DolbyRaspRegister",
              "MobiusLabsLlmVideoAnalysis",
              "MobiusLabsLlmImageAnalysis",
              "TranscriptSummary",
              "SearchCache",
              "WhisperTranscription",
              "BitmovinSceneDetection",
              "BedrockDataAutomation",
              "BedrockSceneDetection",
              "MobiusLabsLlmSegmentContent",
              "AudioWaveform",
              "CustomType"
            ]
          }
        },
        "additionalProperties": false
      },
      "TranscriptionContainerOutputTypes": {
        "enum": [
          0,
          1,
          2,
          3
        ],
        "type": "integer",
        "description": "\n\n0 = DocX\n\n1 = Text\n\n2 = SRT\n\n3 = VTT",
        "format": "int32",
        "x-enumNames": [
          "DocX",
          "Text",
          "SRT",
          "VTT"
        ]
      },
      "TrickPlayFileModel": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Gets or sets the URL to the image representing the trickplay file. The URL must use the secure protocol prefix \"https://\".\r\nRequired",
            "nullable": true
          },
          "quality": {
            "type": "string",
            "description": "Gets or sets must be one of the following:\r\n    HD:  720p\r\n    FHD: 1080p\r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents a single trickplay file.\r\nTrickplay files are the images shown when a user scrubs through a video, either fast-forwarding or rewinding.\r\nThe file must be in the Roku BIF format, as described in https://developer.roku.com/docs/developer-program/media-playback/trick-mode.md"
      },
      "TvSpecialModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets an immutable string reference ID for the TV special that does not exceed 50 characters.\r\nThis should serve as a unique identifier for the TV special across different locales.\r\nOnce created, the ID for the content item may not be changed.\r\nRequired",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the TV special in plain text. This field is used for matching in Roku Search.\r\nDo not include extra information such as year, version label, and so on.\r\nRequired",
            "nullable": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentModel"
              }
            ],
            "description": "Gets or sets the video content, such as the URL of the video file, subtitles, and so on.\r\nRequired",
            "nullable": true
          },
          "thumbnail": {
            "type": "string",
            "description": "Gets or sets the URL of the thumbnail for the TV special. This is used within your channel and in search results.\r\nImage dimensions must be at least 800x450 (width x height, 16x9 aspect ratio).\r\nRequired",
            "nullable": true
          },
          "genres": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets a list of strings describing the genre(s) of the TV special.\r\nMust be one of the values listed in https://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#genres.\r\nRequired",
            "nullable": true
          },
          "releaseDate": {
            "type": "string",
            "description": "Gets or sets the date the TV special first aired. This field is used to sort programs chronologically and group related content in Roku Search.\r\nConforms to ISO 8601 format: {YYYY}-{MM}-{DD}. For example, 2020-11-11\r\nRequired",
            "nullable": true
          },
          "shortDescription": {
            "type": "string",
            "description": "Gets or sets a description of the TV special that does not exceed 200 characters. The text will be clipped if longer.\r\nRequired",
            "nullable": true
          },
          "longDescription": {
            "type": "string",
            "description": "Gets or sets a longer TV special description that does not exceed 500 characters. The text will be clipped if longer.\r\nMust be different from shortDescription.\r\nOptional",
            "nullable": true
          },
          "credits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreditModel"
            },
            "description": "Gets or sets one or more credits. The cast and crew of the TV special.\r\nOptional",
            "nullable": true
          },
          "rating": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RatingModel"
              }
            ],
            "description": "Gets or sets a parental rating for the content.\r\nhttps://developer.roku.com/en-gb/docs/specs/direct-publisher-feed-specs/json-dp-spec.md#parental-ratings\r\nRequired",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets one or more tags (e.g., “dramas”, “korean”, etc). Each tag is a string and is limited to 20 characters.\r\nTags are used to define what content will be shown within a category.\r\nOptional",
            "nullable": true
          },
          "externalIds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            },
            "description": "Gets or sets one or more third-party metadata provider IDs.\r\nOptional",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "TV Specials are one-time TV programs that are not part of a series."
      },
      "UpdateDownloadQueueModel": {
        "type": "object",
        "properties": {
          "assetDownloadQueueId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the download queue item to update.",
            "format": "uuid"
          },
          "transferStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetTransferStatuses"
              }
            ],
            "description": "Gets or sets the current transfer status of the download.\n\nQueued\n\nDownloading\n\nUploading\n\nError\n\nComplete\n\nCancelled",
            "x-enumNames": [
              "Queued",
              "Downloading",
              "Uploading",
              "Error",
              "Complete",
              "Cancelled"
            ]
          },
          "errorMessage": {
            "type": "string",
            "description": "Gets or sets the error message if the download has failed.",
            "nullable": true
          },
          "completePercentage": {
            "type": "number",
            "description": "Gets or sets the completion percentage of the download, expressed as a value between 0 and 100.",
            "format": "float",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to update the status and progress of an item in the download queue."
      },
      "UpdateTranscriptModel": {
        "type": "object",
        "properties": {
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode identifying the transcription entry to update.",
            "nullable": true
          },
          "content": {
            "type": "string",
            "description": "Gets or sets the updated text content for the transcription entry.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to update the text content of a transcription entry at a specific timecode."
      },
      "UploadOverwriteOptions": {
        "enum": [
          "Cancel",
          "Continue",
          "Replace",
          "AssetReplace"
        ],
        "type": "string",
        "description": "\n\nCancel\n\nContinue\n\nReplace\n\nAssetReplace",
        "x-enumNames": [
          "Cancel",
          "Continue",
          "Replace",
          "AssetReplace"
        ]
      },
      "UploadReplaceOptions": {
        "enum": [
          "ReplaceDisplayName",
          "ReplaceDisplayDate",
          "ReplaceLanguage",
          "RecreateThumbnail",
          "RecreatePreview",
          "RecreateSubtitles",
          "RecreateTranscodes"
        ],
        "type": "string",
        "description": "\n\nReplaceDisplayName\n\nReplaceDisplayDate\n\nReplaceLanguage\n\nRecreateThumbnail\n\nRecreatePreview\n\nRecreateSubtitles\n\nRecreateTranscodes",
        "x-enumNames": [
          "ReplaceDisplayName",
          "ReplaceDisplayDate",
          "ReplaceLanguage",
          "RecreateThumbnail",
          "RecreatePreview",
          "RecreateSubtitles",
          "RecreateTranscodes"
        ]
      },
      "UserContentAttributeModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "description": "The unique identifier of the content item.",
            "format": "uuid"
          },
          "contentAttribute": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentAttributes"
              }
            ],
            "description": "The type of attribute to apply (e.g., Favorite, Like, Bookmark).\n\nUndefined\n\nLiked\n\nDisliked\n\nFavorite",
            "x-enumNames": [
              "Undefined",
              "Liked",
              "Disliked",
              "Favorite"
            ]
          },
          "profileId": {
            "type": "string",
            "description": "gets or sets the specific profile to set the attribute for",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Model for adding or removing a user content attribute such as a favorite or bookmark."
      },
      "UserContentAttributeSummaryModel": {
        "type": "object",
        "properties": {
          "likedCount": {
            "type": "integer",
            "format": "int64"
          },
          "dislikedCount": {
            "type": "integer",
            "format": "int64"
          },
          "liked": {
            "type": "boolean",
            "nullable": true
          },
          "disliked": {
            "type": "boolean",
            "nullable": true
          },
          "favorite": {
            "type": "boolean",
            "nullable": true
          },
          "lastSecond": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UserInviteRequestModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the specific content item to grant or revoke access to.",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets or sets the content definition identifier that defines the type of content being shared. Required when inviting users.",
            "format": "uuid",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of a specific user to invite or remove. Provide either UserId or Emails.",
            "format": "uuid",
            "nullable": true
          },
          "emails": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the array of email addresses to invite or remove. Provide either Emails or UserId.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for inviting or removing guest users with content access."
      },
      "UserModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user.",
            "format": "uuid"
          },
          "email": {
            "type": "string",
            "description": "Gets or sets the email address of the user.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user.",
            "nullable": true
          },
          "isAdmin": {
            "type": "boolean",
            "description": "Gets or sets whether the user has system administrator privileges.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties of the user. Any unrecognized JSON properties are captured here.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "UserPropertyModel": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "nullable": true
          },
          "lookupProperty": {
            "type": "string",
            "nullable": true
          },
          "property": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "order": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "lookup": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "defaultLookupId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "isRequired": {
            "type": "boolean",
            "nullable": true
          },
          "width": {
            "type": "string",
            "nullable": true
          },
          "validator": {
            "type": "string",
            "nullable": true
          },
          "forceLinebreak": {
            "type": "boolean",
            "nullable": true
          },
          "newRecordOnly": {
            "type": "boolean",
            "nullable": true
          },
          "parentLookup": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "lookupParentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UserRegistrationRequestModel": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "Gets or sets the email address for the new account. Must be unique.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user.",
            "nullable": true
          },
          "password": {
            "type": "string",
            "description": "Gets or sets the password for the new account.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties for the registration. Any unrecognized JSON properties in the request body are captured here.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "UserResponseModel": {
        "type": "object",
        "properties": {
          "loginStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LoginResponseStatuses"
              }
            ],
            "description": "Gets or sets the login status indicating the result of the operation.\r\nA null value indicates success. Non-null values indicate a specific account state\r\n(e.g., IsDisabled, IsPendingEmailConfirmation) that the client should handle.\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UserSessionModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the session.",
            "format": "uuid"
          },
          "userId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user who owns this session.",
            "format": "uuid",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user.",
            "nullable": true
          },
          "email": {
            "type": "string",
            "description": "Gets or sets the email address of the user.",
            "nullable": true
          },
          "browserType": {
            "type": "string",
            "description": "Gets or sets the browser type used for this session (e.g., Chrome, Firefox).",
            "nullable": true
          },
          "userAgent": {
            "type": "string",
            "description": "Gets or sets the full user agent string from the client's browser.",
            "nullable": true
          },
          "ipAddress": {
            "type": "string",
            "description": "Gets or sets the IP address of the client.",
            "nullable": true
          },
          "origin": {
            "type": "string",
            "description": "Gets or sets the origin URL of the request that created this session.",
            "nullable": true
          },
          "environmentName": {
            "type": "string",
            "description": "Gets or sets the environment name where this session is active.",
            "nullable": true
          },
          "startDate": {
            "type": "string",
            "description": "Gets or sets the date and time (UTC) when the session was started.",
            "format": "date-time"
          },
          "lastActivityDate": {
            "type": "string",
            "description": "Gets or sets the date and time (UTC) of the user's last activity in this session.",
            "format": "date-time"
          },
          "userSessionStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserSessionStatuses"
              }
            ],
            "description": "Gets or sets the current status of the session (e.g., Normal, Kicked, ChatRestricted, Expired).\n\nNormal\n\nChatDisabled\n\nSessionReplaced\n\nDeactivated\n\nSharedAccess\n\nPendingInvite\n\nExpired\n\nDeletedInvite",
            "x-enumNames": [
              "Normal",
              "ChatDisabled",
              "SessionReplaced",
              "Deactivated",
              "SharedAccess",
              "PendingInvite",
              "Expired",
              "DeletedInvite"
            ]
          },
          "userSessionStatusName": {
            "type": "string",
            "description": "Gets or sets the display name of the session status.",
            "nullable": true
          },
          "externalId": {
            "type": "string",
            "description": "Gets or sets an external identifier associated with this session.",
            "nullable": true
          },
          "chatName": {
            "type": "string",
            "description": "Gets or sets the user's display name for chat functionality.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a user session with metadata about the user's connection, activity, and current status."
      },
      "UserSessionModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserSessionModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserSessionModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "UserSessionStatuses": {
        "enum": [
          "Normal",
          "ChatDisabled",
          "SessionReplaced",
          "Deactivated",
          "SharedAccess",
          "PendingInvite",
          "Expired",
          "DeletedInvite"
        ],
        "type": "string",
        "description": "Indicates the current status of a user session.\n\nNormal\n\nChatDisabled\n\nSessionReplaced\n\nDeactivated\n\nSharedAccess\n\nPendingInvite\n\nExpired\n\nDeletedInvite",
        "x-enumNames": [
          "Normal",
          "ChatDisabled",
          "SessionReplaced",
          "Deactivated",
          "SharedAccess",
          "PendingInvite",
          "Expired",
          "DeletedInvite"
        ]
      },
      "VerifyEmailRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to verify. Required."
          },
          "token": {
            "type": "string",
            "description": "Gets or sets the verification code received via the registration confirmation email.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for verifying a user's email address using a confirmation code."
      },
      "VideoHighlightModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "duration": {
            "type": "integer",
            "format": "int64"
          },
          "timestamp": {
            "type": "integer",
            "format": "int64"
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "format": "int32"
          },
          "screenshotUrl": {
            "type": "string",
            "nullable": true
          },
          "animatedGifUrl": {
            "type": "string",
            "nullable": true
          },
          "originalTimeCode": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "segment": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "relatedAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "summary": {
            "type": "string",
            "nullable": true
          },
          "number": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "captions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextCaptionModel"
            },
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LabelModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "VideoModel": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Gets or sets the URL of the video itself. The URL must use the secure protocol prefix \"https://\".\r\nAll videos must play across multiple devices.\r\nThe video should be served from a CDN (Content Distribution Network).\r\nSupported formats are described in https://developer.roku.com/docs/specs/media/streaming-specifications.md\r\nRequired",
            "nullable": true
          },
          "quality": {
            "type": "string",
            "description": "Gets or sets must be one of the following display types:\r\n    SD:  Anything under 720p\r\n    HD:  720p\r\n    FHD: 1080p\r\n    UHD: 4K\r\nRequired",
            "nullable": true
          },
          "videoType": {
            "type": "string",
            "description": "Gets or sets must be one of the following:\r\n    HLS\r\n    SMOOTH\r\n    DASH\r\n    MP4\r\n    MOV\r\n    M4V\r\n            \r\nProvided videos must be unencrypted because there is no encryption support:\r\n            \r\nAudio should be as follows:\r\n    Minimum: first track of Stereo\r\n    Preferred: second track of Dolby(optional)\r\n            \r\nRequired",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "This object represents the details of a single video file.\r\nThe preferred videoType format is HLS (at minimum, DASH should be used)."
      },
      "VideoPlayerProfile": {
        "type": "object",
        "properties": {
          "format": {
            "type": "string",
            "description": "Gets or sets format of the video",
            "nullable": true
          },
          "player": {
            "type": "string",
            "description": "Gets or sets video Player name",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "VideoReferenceModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "isSecure": {
            "type": "boolean",
            "nullable": true
          },
          "fullUrl": {
            "type": "string",
            "nullable": true
          },
          "fullHlsUrl": {
            "type": "string",
            "nullable": true
          },
          "fullDashUrl": {
            "type": "string",
            "nullable": true
          },
          "slug": {
            "type": "string",
            "nullable": true
          },
          "videoBitRate": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "liveOutputStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LiveOutputStatuses"
              }
            ],
            "description": "\n\n1 = Online\n\n2 = Offline",
            "nullable": true
          },
          "secureCookies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LoginCookieModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "VideoTrackingEvents": {
        "enum": [
          "Progress",
          "FirstQuartile",
          "Midpoint",
          "ThirdQuartile",
          "Complete",
          "Hide",
          "LiveStream"
        ],
        "type": "string",
        "description": "\n\nProgress\n\nFirstQuartile\n\nMidpoint\n\nThirdQuartile\n\nComplete\n\nHide\n\nLiveStream",
        "x-enumNames": [
          "Progress",
          "FirstQuartile",
          "Midpoint",
          "ThirdQuartile",
          "Complete",
          "Hide",
          "LiveStream"
        ]
      }
    },
    "securitySchemes": {
      "Bearer": {
        "type": "http",
        "description": "JWT Authorization header using the Bearer scheme. Example: 'Bearer {token}'",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    }
  }
}