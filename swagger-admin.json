{
  "openapi": "3.0.4",
  "info": {
    "title": "Nomad Admin API",
    "description": "Nomad Admin API Documentation",
    "termsOfService": "https://www.nomad.media",
    "contact": {
      "url": "https://www.nomad.media"
    },
    "license": {
      "name": "Proprietary"
    },
    "version": "2026-03"
  },
  "servers": [
    {
      "url": "https://your-service-url/api",
      "description": "Set this to your Nomad Media service API base URL"
    }
  ],
  "paths": {
    "/account/login": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Authenticate a user and obtain a JWT access token.",
        "description": "\r\n<b>Behavior:</b> Validates the user's credentials and, if successful, creates a new session and returns\r\n            a JWT access token with a refresh token. Accounts that are disabled, expired, pending invitation, or pending\r\n            approval will be rejected. Guest users must have a valid profile and permitted application access.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Creates a new user session. The login event is recorded for auditing purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns 404 if authentication fails or the user cannot be found.\r\n            Returns 403 if the user account is Disabled, Expired, PendingInvitation, or PendingApproval.\r\n            LoginStatus on the response indicates the specific failure reason (e.g., IsDisabled, IsPendingEmailConfirmation, RequiresNewPassword).",
        "requestBody": {
          "description": "A Nomad.Common.Models.Security.LoginRequestModel containing the user's email (UserName), password, and optional ApplicationId for session tracking.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LoginRequestModel"
                  }
                ],
                "description": "Request model for authenticating a user and obtaining a JWT access token."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Authentication succeeded. Returns the JWT token, refresh token, user profile, and session information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountLoginResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is null or missing required fields (UserName, Password).",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Authentication failed — invalid credentials or user not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/logout": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Log out the currently authenticated user and end their session.",
        "description": "\r\n<b>Behavior:</b> Ends the user's active session and invalidates the authentication token.\r\n            If a UserSessionId is provided, that specific session is terminated.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Terminates the user session. The logout event is recorded for auditing purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Security.LogoutRequestModel containing the optional UserSessionId to delete and optional ApplicationId.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LogoutRequestModel"
                  }
                ],
                "description": "Request model for logging out a user and ending their session."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user was successfully logged out and the session was deleted."
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/ping": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Check if the user session is still valid and update the session activity timestamp.",
        "description": "\r\n<b>Behavior:</b> Validates that the specified session is still active and keeps it alive by updating its\r\n            last activity timestamp. If single-session enforcement is enabled, detects whether the session has been replaced\r\n            by a newer login. Also checks whether the user's account has expired.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Updates the session's last activity timestamp. May mark the session as expired if the user account is no longer valid.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns PingStatus.AccountExpired if the user or session is expired.\r\n            Returns PingStatus.SessionReplaced if single-session enforcement detected a newer session.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.PingRequestModel containing the UserSessionId and optional ApplicationId.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PingRequestModel"
                  }
                ],
                "description": "Request model for the session ping/keep-alive endpoint."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The session is valid. PingStatus will be Normal for active sessions, or AccountExpired/SessionReplaced if the session should be terminated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PingResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is null or UserSessionId is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/refresh-token": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Retrieve a new JWT access token using a refresh token.",
        "description": "\r\n<b>Behavior:</b> Exchanges a valid refresh token for a new JWT access token. The response includes\r\n            the new token, a new refresh token, and the expiration duration in seconds.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required. The refresh token itself serves as the credential.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns 404 if the refresh token is invalid or expired.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.RefreshTokenRequestModel containing the RefreshToken obtained from a previous login or token refresh.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RefreshTokenRequestModel"
                  }
                ],
                "description": "Request model for exchanging a refresh token for a new JWT access token."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Token refresh succeeded. Returns a new JWT token and refresh token.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountLoginResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is null or RefreshToken is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The refresh token is invalid or has expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/change-email": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Change the email address of the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Updates the authenticated user's email address to the new value provided.\r\n            The current password must be supplied for verification. After a successful change,\r\n            the user must re-authenticate with the new email address.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Changes the user's email address. The user must re-authenticate after the change.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or the authenticated user's email cannot be determined. Throws if the user account is disabled.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ChangeEmailRequestModel containing the current Password for verification and the NewEmail to set.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeEmailRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The email was successfully changed. The user must re-authenticate with the new email."
          },
          "400": {
            "description": "The request is null, the CognitoEmail claim is missing, or the user account is disabled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/change-password": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Change the password of the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Updates the authenticated user's password. The current password must be supplied\r\n            for verification along with the new password. The existing access token remains valid until expiration.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> Updates the user's password. The existing token remains valid until expiration.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or the authenticated user's email cannot be determined. Throws if the user account is disabled or the current password is incorrect.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ChangePasswordRequestModel containing the current Password for verification and the NewPassword to set.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangePasswordRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The password was successfully changed."
          },
          "400": {
            "description": "The request is null, the CognitoEmail claim is missing, the current password is incorrect, or the user is disabled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/forgot-password": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Trigger a password reset code to be sent to the user's email address.",
        "description": "\r\n<b>Behavior:</b> Initiates the password reset flow for the specified user account. If the account is active,\r\n            a 6-digit verification code is sent to the user's email address. The code should then be submitted to the\r\n            reset-password endpoint along with the new password. If the account requires email verification first,\r\n            the response LoginStatus will indicate this.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Sends a password reset email with a 6-digit verification code to the user.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. The response LoginStatus indicates\r\n            IsPendingEmailConfirmation (4) if the account needs email verification first, IsPendingNewAccountSignup (5) if the account\r\n            is not fully registered, or IsDisabled if the account is disabled.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ForgotPasswordRequestModel containing the UserName (email address) of the account.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ForgotPasswordRequestModel"
                  }
                ],
                "description": "Request model for initiating a password reset flow."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The password reset code was sent, or the response indicates a pending account state that must be resolved first.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null or UserName is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/register": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Register a new user account with a unique email address.",
        "description": "\r\n<b>Behavior:</b> Creates a new user account with the specified email, name, and password. The email must be unique.\r\n            Depending on the tenant configuration, the account may be auto-approved (Normal status) or require admin approval\r\n            (PendingApproval status). A verification email is sent to the user to confirm their email address.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Creates a new user account. Sends a verification email to the user.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or Email is empty. Throws if a user with the same email already exists.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.UserRegistrationRequestModel containing Email, FirstName, LastName, Password, and optional custom Properties.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The account was successfully created. The user must verify their email before logging in.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, Email is empty, or a user with this email already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/register-guest": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Complete registration for a guest user who was invited via the invite-user endpoint.",
        "description": "\r\n<b>Behavior:</b> Completes the registration process for a user who received a guest invitation.\r\n            The user must have a pending invitation that has not expired. Sets the user's password, verifies their\r\n            email address, and activates their account so they can log in.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required. The invitation itself serves as authorization.\r\n\r\n<b>Side Effects:</b> Activates the guest user account and marks their email as verified.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null. Throws if the user does not exist, is not in PendingInvitation status,\r\n            the invitation has expired, no security records exist, or no guest profile is configured.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.UserRegistrationRequestModel containing Email, Password, FirstName, and LastName for the guest user.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserRegistrationRequestModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The guest account was successfully activated. The user can now log in.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, the user is not in PendingInvitation status, the invitation has expired, or guest profile is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/resend-code": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Re-send the email verification confirmation code to the user.",
        "description": "\r\n<b>Behavior:</b> Re-sends the email verification confirmation code to the specified user's email address.\r\n            Use this when the original verification email was not received or the code has expired.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Sends a verification email to the user with a new confirmation code.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. Throws if the user does not exist.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ResendConfirmationCodeRequestModel containing the UserName (email address) to re-send the code to.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResendConfirmationCodeRequestModel"
                  }
                ],
                "description": "Request model for re-sending the email verification confirmation code."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The confirmation code was re-sent to the user's email address."
          },
          "400": {
            "description": "The request is null or UserName is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/reset-password": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Reset the user's password using a verification code from the forgot-password email.",
        "description": "\r\n<b>Behavior:</b> Completes the password reset flow by validating the verification code from the forgot-password email\r\n            and setting the new password. For accounts pending approval, this also completes the email verification step.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required. The reset token serves as the credential.\r\n\r\n<b>Side Effects:</b> Updates the user's password. For pending-approval accounts, also verifies the email address.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. Throws if the user is disabled or the reset token is invalid/expired.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.ResetPasswordRequestModel containing UserName (email), the Token from the reset email, and the NewPassword to set.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ResetPasswordRequestModel"
                  }
                ],
                "description": "Request model for completing a password reset using a verification code."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The password was successfully reset. The user can now log in with the new password."
          },
          "400": {
            "description": "The request is null, UserName is missing, the reset token is invalid or expired, or the user is disabled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/account/user": {
      "get": {
        "tags": [
          "Account"
        ],
        "summary": "Get the profile of the currently authenticated user.",
        "description": "\r\n<b>Behavior:</b> Retrieves the profile information for the currently authenticated user based on their access token.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the user profile cannot be found. Returns 401 if the caller is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the authenticated user's profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel"
                }
              }
            }
          },
          "404": {
            "description": "The user entity was not found for the authenticated user's ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/account/verify": {
      "post": {
        "tags": [
          "Account"
        ],
        "summary": "Verify a user's email address using a confirmation code.",
        "description": "\r\n<b>Behavior:</b> Confirms the user's email address using the verification code sent during registration.\r\n            If the account requires admin approval, the response LoginStatus will be IsDisabled to indicate the account\r\n            is verified but not yet approved for use.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> Marks the user's email address as verified.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or UserName is missing. Throws if the verification token is invalid or expired.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Account.VerifyEmailRequestModel containing the UserName (email) and the Token from the verification email.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/VerifyEmailRequestModel"
                  }
                ],
                "description": "Request model for verifying a user's email address using a confirmation code."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The email was verified. Check LoginStatus — null means active, IsDisabled means pending approval.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, UserName is missing, or the verification token is invalid/expired.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/ads/vmap/{assetId}": {
      "get": {
        "tags": [
          "Ad"
        ],
        "summary": "Retrieves the VMAP (Video Multiple Ad Playlist) XML for an asset.",
        "description": "\r\n<b>Behavior:</b> Generates and returns the VMAP XML document that defines all ad break\r\n            positions and their associated VAST ad tag URLs for the specified asset. Video players use\r\n            this to schedule ad insertions during playback.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no VMAP data exists for the asset.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve VMAP data for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The VMAP XML was generated successfully.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "404": {
            "description": "No VMAP data found for the asset.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/ads/vast": {
      "get": {
        "tags": [
          "Ad"
        ],
        "summary": "Retrieves a VAST (Video Ad Serving Template) XML response for ad playback.",
        "description": "\r\n<b>Behavior:</b> Returns a VAST XML document containing the ad creative details for playback\r\n            at the specified timecode position. The response can be filtered by content categories and\r\n            ad position type (pre-roll, mid-roll, post-roll).\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no VAST ad is available for the given parameters.",
        "parameters": [
          {
            "name": "timeCode",
            "in": "query",
            "description": "The timecode position in the video where the ad will be inserted.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "categories",
            "in": "query",
            "description": "Optional content category filters for ad targeting.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "vpos",
            "in": "query",
            "description": "The ad position type (e.g., \"preroll\", \"midroll\", \"postroll\").",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The VAST XML was generated successfully.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "404": {
            "description": "No VAST ad available for the given parameters.",
            "content": {
              "text/xml": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/ads/impression": {
      "get": {
        "tags": [
          "Ad"
        ],
        "summary": "Records an ad impression tracking beacon.",
        "description": "\r\n<b>Behavior:</b> Accepts an impression beacon request triggered when an ad is displayed\r\n            to a viewer. Returns a minimal HTML response suitable for use as a tracking pixel.\r\n            Currently acts as a placeholder for future impression analytics.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None currently. Reserved for future impression tracking analytics.\r\n\r\n<b>Error Scenarios:</b> None — always returns a successful response.",
        "parameters": [
          {
            "name": "assetId",
            "in": "query",
            "description": "The unique identifier of the ad asset that was displayed.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The impression was recorded.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          }
        }
      },
      "head": {
        "tags": [
          "Ad"
        ],
        "summary": "Records an ad impression tracking beacon.",
        "description": "\r\n<b>Behavior:</b> Accepts an impression beacon request triggered when an ad is displayed\r\n            to a viewer. Returns a minimal HTML response suitable for use as a tracking pixel.\r\n            Currently acts as a placeholder for future impression analytics.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None currently. Reserved for future impression tracking analytics.\r\n\r\n<b>Error Scenarios:</b> None — always returns a successful response.",
        "parameters": [
          {
            "name": "assetId",
            "in": "query",
            "description": "The unique identifier of the ad asset that was displayed.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The impression was recorded.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          }
        }
      }
    },
    "/admin/asset/{id}/getAssetChildNodes": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves child folder nodes for a given parent folder in the asset tree.",
        "description": "\r\n<b>Behavior:</b> Returns a paginated, sortable list of child folders under the specified parent.\r\n            If the parent is the root (empty GUID), all top-level storage bucket folders are returned.\r\n            Results include folder metadata such as media type, content length, and modification date.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "folderId",
            "in": "query",
            "description": "The ID of the parent folder. Use an empty GUID to retrieve top-level folders.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "sortColumn",
            "in": "query",
            "description": "The column to sort by (e.g., \"name\", \"contentLength\", \"mediaType\"). Defaults to \"name\".",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "isDesc",
            "in": "query",
            "description": "Whether to sort in descending order. Defaults to false (ascending).",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "pageIndex",
            "in": "query",
            "description": "Zero-based page index for pagination. Defaults to 0.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "Number of items per page. Defaults to 200.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 200
            }
          },
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The child folders were retrieved successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "deprecated": true,
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/transcription-words": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the word-level transcription data for an asset.",
        "description": "\r\n<b>Behavior:</b> Returns the detailed transcription with individual word timings and confidence scores\r\n            for the specified asset. The asset must have been previously transcribed.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset has no transcription data.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the asset to retrieve transcription words for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The transcription words were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranscriptionV2Model"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No transcription data found for the asset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{name}": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Executes a batch action on one or more assets.",
        "description": "\r\n<b>Behavior:</b> Performs the specified batch action (e.g., delete, archive, restore, reprocess)\r\n            on the assets identified in the request payload. The action name is specified in the URL path and must\r\n            correspond to a valid batch action. Results include the status of each affected asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Varies by action — may delete assets, start processing jobs, move files,\r\n            or trigger other asynchronous operations.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the action name is not valid or the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The batch action to perform (e.g., \"delete\", \"archive\", \"restore\", \"reprocess\"). Case-insensitive.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The batch payload containing target asset IDs and optional action arguments.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The batch action was executed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The action name is invalid or the request body is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/register": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Registers an existing storage object as a managed asset.",
        "description": "\r\n<b>Behavior:</b> Looks up an object in storage by its bucket name and object key, then creates\r\n            a managed asset record for it. The asset will be indexed and made available for browsing, searching,\r\n            and media operations. Both the bucket name and object key are required.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a new asset record and triggers indexing.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if bucket name or object key is missing.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if no object exists at the specified bucket/key location.",
        "requestBody": {
          "description": "The registration details including bucket name and object key.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RegisterAssetModel"
                  }
                ],
                "description": "Represents a request to register a new asset or update an existing asset in the system."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RegisterAssetModel"
                  }
                ],
                "description": "Represents a request to register a new asset or update an existing asset in the system."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RegisterAssetModel"
                  }
                ],
                "description": "Represents a request to register a new asset or update an existing asset in the system."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RegisterAssetModel"
                  }
                ],
                "description": "Represents a request to register a new asset or update an existing asset in the system."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RegisterAssetModel"
                  }
                ],
                "description": "Represents a request to register a new asset or update an existing asset in the system."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RegisterAssetModel"
                  }
                ],
                "description": "Represents a request to register a new asset or update an existing asset in the system."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RegisterAssetModel"
                  }
                ],
                "description": "Represents a request to register a new asset or update an existing asset in the system."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The asset was registered successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "Bucket name or object key is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No object found at the specified storage location.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves an asset by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the asset metadata for the specified ID, including properties\r\n            such as name, type, status, and storage location.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if no asset exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No asset found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Asset"
        ],
        "summary": "Deletes an asset by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the specified asset. If the asset is a folder,\r\n            all child assets within the folder are also deleted. The asset is removed from storage\r\n            and the search index.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset and its associated files are permanently removed.\r\n            For folders, all child assets are recursively deleted.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if no asset exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No asset found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "patch": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates specific properties of an asset such as its display name or custom metadata.",
        "description": "\r\n<b>Behavior:</b> Updates the specified properties on the asset without affecting other\r\n            attributes. Use this for lightweight property changes. For more complex operations (e.g., clipping,\r\n            language change, archiving), use the dedicated endpoints.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset's search index entry is updated with the new properties.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The properties to update on the asset.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The asset properties were updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves an asset by its storage bucket name and object key.",
        "description": "\r\n<b>Behavior:</b> Looks up the asset using the storage bucket name and object key combination\r\n            and returns its metadata. Both parameters are required.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if bucket name or object key is missing.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if no asset exists at the specified storage location.",
        "parameters": [
          {
            "name": "bucketName",
            "in": "query",
            "description": "The name of the storage bucket containing the asset. Required.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "objectKey",
            "in": "query",
            "description": "The object key (path) of the asset within the bucket. Required.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetModel"
                }
              }
            }
          },
          "400": {
            "description": "Bucket name or object key is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No asset found at the specified storage location.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/language": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Changes the language of an asset and triggers AI reprocessing.",
        "description": "\r\n<b>Behavior:</b> Updates the language setting for the asset. This triggers reprocessing\r\n            of AI-powered features such as transcription, subtitle generation, and text detection\r\n            to use the new language.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Triggers asynchronous reprocessing of AI data (transcription, subtitles, etc.)\r\n            for the new language.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The new language setting for the asset.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetLanguageModel"
                  }
                ],
                "description": "Represents a request to change the language assigned to an asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetLanguageModel"
                  }
                ],
                "description": "Represents a request to change the language assigned to an asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetLanguageModel"
                  }
                ],
                "description": "Represents a request to change the language assigned to an asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetLanguageModel"
                  }
                ],
                "description": "Represents a request to change the language assigned to an asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetLanguageModel"
                  }
                ],
                "description": "Represents a request to change the language assigned to an asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetLanguageModel"
                  }
                ],
                "description": "Represents a request to change the language assigned to an asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetLanguageModel"
                  }
                ],
                "description": "Represents a request to change the language assigned to an asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The asset language was updated and reprocessing was triggered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{parentId}/create-folder": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a new folder asset under the specified parent folder.",
        "description": "\r\n<b>Behavior:</b> Creates a new folder within the specified parent folder. The folder display name\r\n            is required and must be provided in the request body. The new folder is immediately available\r\n            for browsing and uploading assets into.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new folder is created in storage and indexed for search.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the display name is missing or the request body is invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "parentId",
            "in": "path",
            "description": "The ID of the parent folder where the new folder will be created.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The new folder details including the display name.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateFolderModel"
                  }
                ],
                "description": "Represents a request to create a new folder within the asset hierarchy."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateFolderModel"
                  }
                ],
                "description": "Represents a request to create a new folder within the asset hierarchy."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateFolderModel"
                  }
                ],
                "description": "Represents a request to create a new folder within the asset hierarchy."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateFolderModel"
                  }
                ],
                "description": "Represents a request to create a new folder within the asset hierarchy."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateFolderModel"
                  }
                ],
                "description": "Represents a request to create a new folder within the asset hierarchy."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateFolderModel"
                  }
                ],
                "description": "Represents a request to create a new folder within the asset hierarchy."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateFolderModel"
                  }
                ],
                "description": "Represents a request to create a new folder within the asset hierarchy."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The folder was successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The folder was not created — display name is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{parentId}/create-placeholder": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a placeholder asset under the specified parent folder.",
        "description": "\r\n<b>Behavior:</b> Creates a new placeholder asset within the specified parent folder. A placeholder\r\n            reserves a spot in the asset tree before actual media content is uploaded. The asset name is required.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new placeholder asset record is created and indexed.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the asset name is missing or the request body is invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "parentId",
            "in": "path",
            "description": "The ID of the parent folder where the placeholder will be created.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The placeholder details including the asset name.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatePlaceholderModel"
                  }
                ],
                "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatePlaceholderModel"
                  }
                ],
                "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatePlaceholderModel"
                  }
                ],
                "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatePlaceholderModel"
                  }
                ],
                "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatePlaceholderModel"
                  }
                ],
                "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatePlaceholderModel"
                  }
                ],
                "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatePlaceholderModel"
                  }
                ],
                "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The placeholder was successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The placeholder was not created — asset name is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/duplicate": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a duplicate copy of the specified asset.",
        "description": "\r\n<b>Behavior:</b> Creates a full copy of the asset including its metadata and media files.\r\n            The duplicated asset is placed in the same folder as the original.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new asset is created with copied files and metadata.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if no asset exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to duplicate.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset was duplicated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No asset found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/copy": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Copies an asset to a different location.",
        "description": "\r\n<b>Behavior:</b> Creates a copy of the specified asset in the target location provided\r\n            in the batch model. The original asset remains unchanged. The batch model should include\r\n            the destination folder ID in the action arguments.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new asset copy is created at the target location.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if no asset exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to copy.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The batch payload containing the target destination and optional arguments.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The asset was copied successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No asset found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/archive": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Archives an asset to long-term storage.",
        "description": "\r\n<b>Behavior:</b> Moves the asset to archival storage, reducing storage costs while preserving\r\n            the asset for future retrieval. Archived assets are not immediately accessible for streaming or\r\n            download — they must first be restored using the restore endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token with file write permissions on the asset.\r\n\r\n<b>Side Effects:</b> The asset's storage class is changed to archival. The asset will become\r\n            unavailable for direct access until restored.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 403 if the caller does not have write permissions on the asset.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to archive.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset was archived successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Caller does not have write permissions on the asset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/index": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Triggers re-indexing of an asset in the search index.",
        "description": "\r\n<b>Behavior:</b> Queues the asset for re-indexing, which refreshes its metadata in the\r\n            search index. Use this after external changes to an asset that may not have been automatically detected.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset is queued for asynchronous re-indexing. The search index\r\n            will be updated once processing completes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to re-index.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset was queued for re-indexing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/move": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Moves an asset to a different folder.",
        "description": "\r\n<b>Behavior:</b> Moves the specified asset to the target folder provided in the batch model.\r\n            The asset retains its identity and metadata but is relocated in the folder hierarchy.\r\n            The batch model should include the destination folder ID in the action arguments.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset is relocated to the new folder. The search index is updated\r\n            to reflect the new location.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to move.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The batch payload containing the destination folder and optional arguments.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The asset was moved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/parent-folders": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the full parent folder hierarchy for an asset.",
        "description": "\r\n<b>Behavior:</b> Returns all ancestor folders for the specified asset, from the root down to\r\n            the immediate parent. Results are structured hierarchically — each folder's identifiers object includes\r\n            a children attribute pointing to the next sub-folder in the chain. The specified asset itself is\r\n            not included in the results. Works for both file and folder assets.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the asset to retrieve parent folders for. Can be either a file or folder.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "The number of folders to retrieve per level of the tree. Defaults to 100.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The parent folder hierarchy was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/upload": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the list of uploads for the current user.",
        "description": "\r\n<b>Behavior:</b> Returns all uploads initiated by the current user. By default, only\r\n            in-progress uploads are returned. Set includeCompletedUploads to true\r\n            to also include completed uploads.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "includeCompletedUploads",
            "in": "query",
            "description": "If true, includes completed uploads in the results. If false, only in-progress uploads are returned.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upload list was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AssetUploadModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/upload/{id}": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the individual upload parts for a multipart upload.",
        "description": "\r\n<b>Behavior:</b> Returns all parts associated with the specified upload, including both\r\n            completed and pending parts. Each part includes its upload URL, part number, and completion status.\r\n            Use this to track the progress of a multipart upload or to resume a partially completed upload.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the asset upload to retrieve parts for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upload parts were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AssetPartUploadModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/{segmentId}/detail": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves detailed information for a specific segment of an asset.",
        "description": "\r\n<b>Behavior:</b> Returns the full detail model for the specified segment, including\r\n            media properties, URLs, metadata, and processing status. Segments represent individual\r\n            clips or sections within a parent asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset or segment is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segmentId",
            "in": "path",
            "description": "The unique identifier of the segment within the asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The segment detail was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetDetailModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset or segment was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/{segmentId}/{screenshotId}/detail": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves detailed information for a specific screenshot within an asset segment.",
        "description": "\r\n<b>Behavior:</b> Returns the full detail model for the specified screenshot, including\r\n            image properties, URLs, and metadata. Screenshots are images captured at specific timecodes\r\n            within a video asset segment.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset, segment, or screenshot is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "segmentId",
            "in": "path",
            "description": "The unique identifier of the segment within the asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "screenshotId",
            "in": "path",
            "description": "The unique identifier of the screenshot.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The screenshot detail was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetDetailModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset, segment, or screenshot was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/clip": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a clip (sub-segment) from a video asset.",
        "description": "\r\n<b>Behavior:</b> Extracts a segment from the specified video asset based on the provided\r\n            timecode range. The clip is created as a new related asset linked to the original.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new clip asset is created asynchronously. The clip will appear\r\n            as a related asset once processing completes.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the video asset to clip.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The clip parameters including start and end timecodes.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The clip operation was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/screenshot": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Captures a screenshot from a video asset at a specific timecode.",
        "description": "\r\n<b>Behavior:</b> Generates a still image from the video at the timecode specified in the\r\n            request. The screenshot is saved as a related asset linked to the original video.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new screenshot image asset is created asynchronously.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the video asset to capture a screenshot from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The screenshot parameters including the timecode.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScreenshotModel"
                  }
                ],
                "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScreenshotModel"
                  }
                ],
                "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScreenshotModel"
                  }
                ],
                "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScreenshotModel"
                  }
                ],
                "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScreenshotModel"
                  }
                ],
                "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScreenshotModel"
                  }
                ],
                "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScreenshotModel"
                  }
                ],
                "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The screenshot operation was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{assetId}/set-cookies/{id}": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves secure streaming cookies for an asset's related media.",
        "description": "\r\n<b>Behavior:</b> Generates signed cookies required for secure streaming of a related asset\r\n            (e.g., proxy video, preview). The response includes cookies both in the response headers\r\n            (for browser-based playback) and in the response body (for programmatic access).\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Signed streaming cookies are set in the HTTP response headers.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset or related asset is not found.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the related asset to generate streaming cookies for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The streaming cookies were generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseCookieWrapper"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset or related asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/metadata-summary": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the metadata summary (labels) for an asset or folder.",
        "description": "\r\n<b>Behavior:</b> Returns a summary of AI-detected labels and metadata associated with the\r\n            specified asset. When the ID is a folder, the summary aggregates label data across all assets\r\n            within that folder.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset or folder is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset or folder. Typically a folder ID for aggregated results.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The metadata summary was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LabelModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset or folder was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{assetId}/adbreak": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves all ad breaks configured for an asset.",
        "description": "\r\n<b>Behavior:</b> Returns the list of ad break cue points defined for the specified asset.\r\n            Each ad break specifies a timecode position where an advertisement should be inserted during playback.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found or has no ad breaks.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve ad breaks for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The ad breaks were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AdBreakModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found or has no ad breaks.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a new ad break cue point for an asset.",
        "description": "\r\n<b>Behavior:</b> Adds a new ad break at the specified timecode position within the asset.\r\n            The ad break will be included in VMAP/VAST responses when the asset is played back with advertising enabled.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The ad break is persisted and will affect future playback sessions.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to create the ad break for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The ad break details including timecode and ad configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The ad break was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdBreakModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{assetId}/adbreak/{id}": {
      "put": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates an existing ad break for an asset.",
        "description": "\r\n<b>Behavior:</b> Updates the specified ad break's properties such as timecode position and ad\r\n            configuration. The ad break ID in the URL must match an existing ad break for the specified asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The updated ad break will affect future playback sessions.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset or ad break is not found.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the ad break.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the ad break to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The updated ad break details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdBreakSubmitModel"
                  }
                ],
                "description": "Represents a request to create or update an ad break marker within a media asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The ad break was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdBreakModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset or ad break was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Asset"
        ],
        "summary": "Deletes an ad break from an asset.",
        "description": "\r\n<b>Behavior:</b> Permanently removes the specified ad break cue point from the asset.\r\n            The ad break will no longer appear in VMAP/VAST responses for future playback sessions.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The ad break is permanently deleted.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the ad break.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the ad break to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The ad break was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/related-asset/{relatedAssetId}": {
      "delete": {
        "tags": [
          "Asset"
        ],
        "summary": "Deletes a related asset from a parent asset.",
        "description": "\r\n<b>Behavior:</b> Removes the association between the parent asset and the specified related asset\r\n            (e.g., proxy video, subtitle file, thumbnail). The related asset is permanently deleted.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The related asset is permanently deleted and disassociated from the parent.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "relatedAssetId",
            "in": "path",
            "description": "The unique identifier of the related asset to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The related asset was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/import-google-photos-metadata": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Imports Google Photos metadata from JSON sidecar files to associated media assets.",
        "description": "\r\n<b>Behavior:</b> Scans the specified folder for Google Photos JSON metadata files and applies\r\n            the metadata (dates, locations, descriptions) to the corresponding media assets. This is useful\r\n            after bulk-importing a Google Photos export.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Asset metadata is updated with information from the JSON sidecar files.\r\n            Processing occurs asynchronously as a batch job.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the folder containing Google Photos exports with JSON metadata files.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The import job was queued successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{assetId}/job-history": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the processing job history for an asset.",
        "description": "\r\n<b>Behavior:</b> Returns a chronological list of all processing jobs that have been executed\r\n            for the specified asset, including transcoding, transcription, AI analysis, and other operations.\r\n            Each entry includes the job type, status, start/end times, and any error details.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve job history for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The job history was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/JobHistoryModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{assetId}/resolve-full-url": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Resolves a relative asset URL to its full, signed URL for direct access.",
        "description": "\r\n<b>Behavior:</b> Takes a relative or partial URL associated with the asset and resolves it\r\n            to a fully qualified, signed URL that can be used for direct access or download.\r\n            This is useful for converting stored URL references into accessible links.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the URL cannot be resolved for the asset.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "url",
            "in": "query",
            "description": "The relative or partial URL to resolve.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The URL was resolved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The URL could not be resolved for the asset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/detail": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the full detail model for an asset, including all media properties and related assets.",
        "description": "\r\n<b>Behavior:</b> Returns comprehensive asset details including media properties (dimensions,\r\n            duration, codec), URLs for streaming and preview, related assets (proxies, thumbnails, subtitles),\r\n            AI-generated metadata, and processing status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve details for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset details were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetDetailModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/{id}/restore": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Restores an archived asset back to active storage.",
        "description": "\r\n<b>Behavior:</b> Initiates restoration of a previously archived asset, making it accessible\r\n            for streaming and download again. The restore process may take time depending on the archive\r\n            storage tier. Use the job history endpoint to monitor restoration progress.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token with file write permissions on the asset.\r\n\r\n<b>Side Effects:</b> The asset is queued for restoration from archival storage.\r\n            The asset will become accessible once restoration completes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 403 if the caller does not have write permissions on the asset.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the archived asset to restore.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset restoration was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "Caller does not have write permissions on the asset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/asset/download-archive": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a downloadable ZIP archive containing multiple assets.",
        "description": "\r\n<b>Behavior:</b> Packages the specified assets into a single ZIP archive for download.\r\n            You can optionally specify a custom filename and a download proxy URL. The request must include\r\n            at least one asset ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A ZIP archive is created asynchronously. The batch result contains\r\n            the download URL once processing completes.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or contains no asset IDs.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the request model is null or invalid.",
        "requestBody": {
          "description": "The download request containing asset IDs, optional filename, and download proxy settings.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The archive creation was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or contains no asset IDs.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The request model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/subtitle/{relatedAssetId}/export": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Exports subtitles for an asset in the specified format (DOCX, SRT, VTT, or TXT).",
        "description": "\r\n<b>Behavior:</b> Converts the transcription data for the specified related asset (subtitle track)\r\n            into the requested export format and returns the file as a downloadable binary response.\r\n            Supported formats: DOCX (Word document), SRT (SubRip), VTT (WebVTT), and TXT (plain text).\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 204 if the export format is invalid.\r\n            Returns 400 if the subtitle data is empty or the asset needs reprocessing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "relatedAssetId",
            "in": "path",
            "description": "The unique identifier of the subtitle-related asset to export.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The export options including the desired output format.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RenderSubtitlesModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The subtitle file was exported successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "204": {
            "description": "The export format is not supported."
          },
          "400": {
            "description": "The subtitle data is empty or the asset needs reprocessing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/clip": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a clip (sub-segment) from a video asset.",
        "description": "\r\n<b>Behavior:</b> Extracts a segment from the specified video asset based on the provided\r\n            timecode range. The clip is created as a new related asset linked to the original.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new clip asset is created asynchronously.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the video asset to clip.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The clip parameters including start and end timecodes.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The clip operation was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/build-media": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Renders a media builder composition into a final output file.",
        "description": "\r\n<b>Behavior:</b> Submits a media builder render job that combines multiple assets, overlays,\r\n            and effects into a single output media file. The rendering occurs asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A media rendering job is created and processed asynchronously.\r\n            The resulting output file will be created as a new asset upon completion.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the input model is null.",
        "requestBody": {
          "description": "The media builder render configuration including source assets and output settings.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/MediaBuilderRenderModel"
                  }
                ],
                "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The media render job was submitted successfully."
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The input model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/set-cookies/{id}": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves secure streaming cookies for an asset's related media.",
        "description": "\r\n<b>Behavior:</b> Generates signed cookies required for secure streaming of a related asset\r\n            (e.g., proxy video, preview). The response includes cookies both in the response headers\r\n            (for browser-based playback) and in the response body (for programmatic access).\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Signed streaming cookies are set in the HTTP response headers.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset or related asset is not found.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the related asset to generate streaming cookies for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The streaming cookies were generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseCookieWrapper"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset or related asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/detail": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves the full detail model for an asset, including all media properties and related assets.",
        "description": "\r\n<b>Behavior:</b> Returns comprehensive asset details including media properties (dimensions,\r\n            duration, codec), URLs for streaming and preview, related assets (proxies, thumbnails, subtitles),\r\n            AI-generated metadata, and processing status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the asset is not found.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve details for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset details were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetDetailModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The asset was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/restore": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Restores an archived asset back to active storage.",
        "description": "\r\n<b>Behavior:</b> Initiates restoration of a previously archived asset, making it accessible\r\n            for streaming and download again. The restore process may take time depending on the archive\r\n            storage tier.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset is queued for restoration from archival storage.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the archived asset to restore.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The asset restoration was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/local-restore": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Restores multiple assets from archive using specified restore profiles.",
        "description": "\r\n<b>Behavior:</b> Initiates a batch restore operation for multiple archived assets using the\r\n            specified restore profile names. Assets are queued for restoration asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The specified assets are queued for restoration from archival storage.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The restore parameters including source asset IDs and restore profile names.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The batch restore was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uuid"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}/localRestore": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Restores a single asset from archive using specified restore profiles.",
        "description": "\r\n<b>Behavior:</b> Initiates a restore operation for the specified archived asset using the\r\n            given restore profile names. The asset is queued for restoration asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset is queued for restoration from archival storage.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the archived asset to restore.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The restore parameters including restore profile names.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LocalRestoreModel"
                  }
                ],
                "description": "Represents a request to restore assets from archive storage to a local storage profile."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The restore was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/annotation": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a new annotation on an asset.",
        "description": "\r\n<b>Behavior:</b> Adds a new annotation (marker, comment, or note) to the specified asset.\r\n            Annotations can include timecodes for video assets, spatial coordinates for images,\r\n            and descriptive text. The created annotation is returned with its generated ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new annotation record is created for the asset.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to annotate.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The annotation details including text, timecode, and position.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The annotation was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotationModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Retrieves all annotations for an asset.",
        "description": "\r\n<b>Behavior:</b> Returns all annotations associated with the specified asset, including\r\n            timecodes, positions, and descriptive text. The caller must have access permissions on the asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token with access permissions on the asset.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the caller does not have permission on the asset.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to retrieve annotations for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The annotations were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AnnotationModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The caller does not have permission on the asset.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/share": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a shareable link for an asset.",
        "description": "\r\n<b>Behavior:</b> Generates a shareable URL for the specified asset based on the sharing\r\n            configuration provided. Options include expiration time, password protection, and access permissions.\r\n            The generated link can be distributed to external recipients.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A share record is created. Depending on configuration, notification emails\r\n            may be sent to specified recipients.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to share.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The sharing configuration including recipients, expiration, and permissions.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ShareModel"
                  }
                ],
                "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The share link was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/generate-image": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Generates an AI image for an asset using a text prompt.",
        "description": "\r\n<b>Behavior:</b> Uses AI image generation to create a new image based on the provided text prompt.\r\n            The generated image is saved as a new asset. A prompt is required in the request body.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new image asset is created from the AI-generated content.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the prompt is empty or the request body is missing.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the input model is null.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset context for the image generation.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The image generation parameters including the text prompt.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GenerateImageModel"
                  }
                ],
                "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The image was generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateImageModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "The prompt is empty or the request body is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The input model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/annotation/import": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Bulk imports multiple annotations for an asset in a single request.",
        "description": "\r\n<b>Behavior:</b> Creates multiple annotations on the specified asset at once. Each annotation\r\n            in the list is created individually. All annotations are associated with the specified asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Multiple annotation records are created for the asset.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset to import annotations for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The list of annotations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AddAnnotationModel"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The annotations were imported successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AnnotationModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/annotation/{annonationId}": {
      "delete": {
        "tags": [
          "Asset"
        ],
        "summary": "Deletes an annotation from an asset.",
        "description": "\r\n<b>Behavior:</b> Permanently removes the specified annotation from the asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The annotation is permanently deleted.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "annonationId",
            "in": "path",
            "description": "The unique identifier of the annotation to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "assetId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The annotation was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates an existing annotation on an asset.",
        "description": "\r\n<b>Behavior:</b> Updates the specified annotation's properties including text, timecode,\r\n            and position. The annotation must exist for the specified asset.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The annotation record is updated.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the annotation is not found.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the annotation.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "annonationId",
            "in": "path",
            "description": "The unique identifier of the annotation to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The updated annotation details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddAnnotationModel"
                  }
                ],
                "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The annotation was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AnnotationModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The annotation was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/related-asset/{relatedAssetId}": {
      "delete": {
        "tags": [
          "Asset"
        ],
        "summary": "Deletes a related asset from a parent asset.",
        "description": "\r\n<b>Behavior:</b> Removes the association between the parent asset and the specified related asset\r\n            (e.g., proxy video, subtitle file, thumbnail). The related asset is permanently deleted.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The related asset is permanently deleted and disassociated from the parent.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the parent asset.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "relatedAssetId",
            "in": "path",
            "description": "The unique identifier of the related asset to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The related asset was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/transcript/{transcriptId}": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates the transcription content for an asset.",
        "description": "\r\n<b>Behavior:</b> Replaces or updates specific segments of the transcription associated with\r\n            the specified asset and transcript ID. Use this to correct auto-generated transcription text\r\n            or adjust word timings.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The transcription data is updated and re-indexed.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the transcription.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "transcriptId",
            "in": "path",
            "description": "The unique identifier of the transcription to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The list of transcription updates to apply.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UpdateTranscriptModel"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The transcription was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/tracking": {
      "get": {
        "tags": [
          "Asset"
        ],
        "summary": "Records a video or ad tracking beacon event.",
        "description": "\r\n<b>Behavior:</b> Records a playback tracking event (e.g., play, pause, quartile, complete) for\r\n            analytics and reporting. Supports both asset-level and live channel tracking. Responds with\r\n            an HTML \"OK\" suitable for use as a tracking pixel/beacon endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A tracking record is created for analytics purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            No tracking is recorded if neither assetId nor livechannelId is provided.",
        "parameters": [
          {
            "name": "trackingEvent",
            "in": "query",
            "description": "The type of tracking event (e.g., play, pause, complete).\n\nProgress\n\nFirstQuartile\n\nMidpoint\n\nThirdQuartile\n\nComplete\n\nHide\n\nLiveStream",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/VideoTrackingEvents"
                }
              ],
              "x-enumNames": [
                "Progress",
                "FirstQuartile",
                "Midpoint",
                "ThirdQuartile",
                "Complete",
                "Hide",
                "LiveStream"
              ]
            },
            "x-enumNames": [
              "Progress",
              "FirstQuartile",
              "Midpoint",
              "ThirdQuartile",
              "Complete",
              "Hide",
              "LiveStream"
            ]
          },
          {
            "name": "assetId",
            "in": "query",
            "description": "The ID of the asset being tracked. Required if not tracking a live channel.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "livechannelId",
            "in": "query",
            "description": "The ID of the live channel being tracked. Required if not tracking an asset.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "query",
            "description": "Optional content ID to associate with the tracking event.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "second",
            "in": "query",
            "description": "The second mark into the video or ad when the event occurred.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "profileId",
            "in": "query",
            "description": "Optional profile ID to associate the tracking data with a specific viewer.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tracking event was recorded successfully.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "head": {
        "tags": [
          "Asset"
        ],
        "summary": "Records a video or ad tracking beacon event.",
        "description": "\r\n<b>Behavior:</b> Records a playback tracking event (e.g., play, pause, quartile, complete) for\r\n            analytics and reporting. Supports both asset-level and live channel tracking. Responds with\r\n            an HTML \"OK\" suitable for use as a tracking pixel/beacon endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A tracking record is created for analytics purposes.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.\r\n            No tracking is recorded if neither assetId nor livechannelId is provided.",
        "parameters": [
          {
            "name": "trackingEvent",
            "in": "query",
            "description": "The type of tracking event (e.g., play, pause, complete).\n\nProgress\n\nFirstQuartile\n\nMidpoint\n\nThirdQuartile\n\nComplete\n\nHide\n\nLiveStream",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/VideoTrackingEvents"
                }
              ],
              "x-enumNames": [
                "Progress",
                "FirstQuartile",
                "Midpoint",
                "ThirdQuartile",
                "Complete",
                "Hide",
                "LiveStream"
              ]
            },
            "x-enumNames": [
              "Progress",
              "FirstQuartile",
              "Midpoint",
              "ThirdQuartile",
              "Complete",
              "Hide",
              "LiveStream"
            ]
          },
          {
            "name": "assetId",
            "in": "query",
            "description": "The ID of the asset being tracked. Required if not tracking a live channel.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "livechannelId",
            "in": "query",
            "description": "The ID of the live channel being tracked. Required if not tracking an asset.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "query",
            "description": "Optional content ID to associate with the tracking event.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "second",
            "in": "query",
            "description": "The second mark into the video or ad when the event occurred.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "profileId",
            "in": "query",
            "description": "Optional profile ID to associate the tracking data with a specific viewer.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tracking event was recorded successfully.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResult"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "text/html": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/download-archive": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Creates a downloadable ZIP archive containing multiple assets.",
        "description": "\r\n<b>Behavior:</b> Packages the specified assets into a single ZIP archive for download.\r\n            You can optionally specify a custom filename and a download proxy URL. The request must include\r\n            at least one asset ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A ZIP archive is created asynchronously.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or contains no asset IDs.\r\n            Returns 401 if the caller is not authenticated.\r\n            Returns 404 if the request model is null or invalid.",
        "requestBody": {
          "description": "The download request containing asset IDs, optional filename, and download proxy settings.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetDownloadModel"
                  }
                ],
                "description": "Represents a request to download one or more assets, optionally packaged into a single file."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The archive creation was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or contains no asset IDs.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The request model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{id}": {
      "patch": {
        "tags": [
          "Asset"
        ],
        "summary": "Updates specific properties of an asset such as its display name or custom metadata.",
        "description": "\r\n<b>Behavior:</b> Updates the specified properties on the asset without affecting other\r\n            attributes. Use this for lightweight property changes. For more complex operations (e.g., clipping,\r\n            language change, archiving), use the dedicated endpoints.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The asset's search index entry is updated with the new properties.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The properties to update on the asset.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeAssetPropertiesModel"
                  }
                ],
                "description": "Represents a request to modify the display properties and custom attributes of an asset."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The asset properties were updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/assign-person/{faceId}/{personId}": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Associates a detected face in an asset with a known person.",
        "description": "\r\n<b>Behavior:</b> Links the specified detected face (identified by its external face ID) to\r\n            a person record. This is used to confirm or assign facial recognition matches, updating the\r\n            face's match status from probable to confirmed.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The face record is updated with the person association.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the detected face.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "faceId",
            "in": "path",
            "description": "The external face identifier from the facial recognition analysis.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "personId",
            "in": "path",
            "description": "The unique identifier of the person to associate with the face.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The person was assigned to the face successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/{assetId}/remove-person/{faceId}": {
      "post": {
        "tags": [
          "Asset"
        ],
        "summary": "Removes the person association from a detected face in an asset.",
        "description": "\r\n<b>Behavior:</b> Removes the link between a detected face and its assigned person. The face\r\n            detection data is retained, but it will no longer be associated with a specific person record.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The face record's person association is removed.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset containing the detected face.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "faceId",
            "in": "path",
            "description": "The external face identifier to remove the person association from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The person association was removed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset-queue": {
      "post": {
        "tags": [
          "AssetQueue"
        ],
        "summary": "Adds assets to the download queue for batch downloading.",
        "description": "\r\n<b>Behavior:</b> Adds the specified assets to the user's download queue. Queued assets can be\r\n            processed for bulk download at a later time. This is useful for collecting multiple assets\r\n            before initiating a single download operation.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> New entries are created in the download queue.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The assets to add to the download queue.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The items were added to the download queue."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "patch": {
        "tags": [
          "AssetQueue"
        ],
        "summary": "Updates the properties of a download queue item.",
        "description": "\r\n<b>Behavior:</b> Updates an existing entry in the download queue, such as changing its\r\n            priority or status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The download queue entry is updated.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The updated download queue item properties.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateDownloadQueueModel"
                  }
                ],
                "description": "Represents a request to update the status and progress of an item in the download queue."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The queue item was updated."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "AssetQueue"
        ],
        "summary": "Removes entries from the download queue.",
        "description": "\r\n<b>Behavior:</b> Deletes the specified entries from the download queue. The entries are\r\n            identified by their unique download queue IDs.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The specified queue entries are permanently removed.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The list of download queue entry IDs to delete.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The queue entries were deleted."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/start": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Initiates a new multipart upload for a single asset.",
        "description": "\r\n<b>Behavior:</b> Prepares a new asset upload by creating the upload record and generating\r\n            pre-signed URLs for each upload part. The client should upload each part directly to the provided\r\n            URLs, then call the complete endpoint when all parts are uploaded. The file is split into parts\r\n            based on the total file size.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> An upload record is created. Pre-signed upload URLs are generated\r\n            with limited validity.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The upload parameters including file name, size, parent folder, and MIME type.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The upload was initiated and part URLs were generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetUploadModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/start-related-asset": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Initiates a new multipart upload for a related asset (e.g., subtitle, proxy, thumbnail).",
        "description": "\r\n<b>Behavior:</b> Prepares an upload for a file that will be associated with an existing parent\r\n            asset as a related asset. Generates pre-signed URLs for each upload part. Use this for uploading\r\n            supplementary files such as subtitle tracks, proxy videos, or custom thumbnails.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> An upload record is created. Pre-signed upload URLs are generated.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is missing or invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The upload parameters including parent asset ID, file name, size, and relationship type.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedAssetUploadStartRequestModel"
                  }
                ],
                "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The related asset upload was initiated and part URLs were generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetUploadModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/{id}/complete": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Completes a multipart upload after all parts have been transferred.",
        "description": "\r\n<b>Behavior:</b> Finalizes the multipart upload by combining all uploaded parts into the\r\n            final asset file. This triggers post-upload processing including media analysis, transcoding,\r\n            AI detection, and search indexing. Call this only after all parts have been uploaded and\r\n            confirmed via the complete-part endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The uploaded parts are assembled into the final file. Asynchronous\r\n            processing jobs (transcoding, AI analysis, indexing) are triggered.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the asset upload to complete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upload was completed and processing was initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/{id}/cancel": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Cancels an in-progress upload and deletes all uploaded parts.",
        "description": "\r\n<b>Behavior:</b> Aborts the multipart upload and cleans up all partially uploaded data.\r\n            An optional message can be provided to record the reason for cancellation.\r\n            Use this to abandon an upload that will not be completed.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> All uploaded parts are deleted from storage. The upload record\r\n            is marked as cancelled.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the asset upload to cancel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "message",
            "in": "query",
            "description": "Optional reason for cancelling the upload.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upload was cancelled and partial data was cleaned up."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/asset/upload/part/{id}/complete": {
      "post": {
        "tags": [
          "AssetUpload"
        ],
        "summary": "Confirms that an individual upload part was transferred successfully.",
        "description": "\r\n<b>Behavior:</b> Records that the specified upload part has been successfully uploaded to the\r\n            pre-signed URL. The ETag returned by the storage service after uploading the part data must be\r\n            provided to verify integrity. Call this for each part after uploading it, before calling\r\n            the complete-upload endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The part is marked as completed in the upload record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the ETag is missing or the request body is invalid.\r\n            Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The ID of the upload part to mark as complete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The completion details including the ETag from the storage upload response.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetUploadCompletePartRequestModel"
                  }
                ],
                "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The upload part was confirmed successfully."
          },
          "400": {
            "description": "The ETag is missing or the request body is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/audit/{contentId}": {
      "get": {
        "tags": [
          "Audit"
        ],
        "summary": "Retrieves the audit history for a content item.",
        "description": "\r\n<b>Behavior:</b> Returns the chronological list of audit events recorded for the specified content item.\r\n            Audit events include actions such as creation, updates, security changes, and other modifications\r\n            performed on the content item.\r\n\r\n<b>Authorization:</b> No authorization required (controller does not have [Authorize] attribute).\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The content item identifier to retrieve audit history for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The audit history was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/HistoryEntityResponseModel"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/bitmovin/webhook/{status}/{id}/{eId}": {
      "post": {
        "tags": [
          "Bitmovin"
        ],
        "summary": "Receives a Bitmovin encoding webhook callback.",
        "description": "\r\n<b>Behavior:</b> Processes a webhook callback from the Bitmovin encoding service. Packages the status, asset ID, encoding ID, and model data into a batch action message for asynchronous processing via the BitmovinUnitOfWork.\r\n\r\n<b>Authorization:</b> No authorization required. Validated by webhook filter.\r\n\r\n<b>Side Effects:</b> A batch action message is sent to trigger asynchronous processing of the encoding result.\r\n\r\n<b>Error Scenarios:</b> Returns 200 OK even on errors to acknowledge receipt. Errors are logged but swallowed to prevent webhook retry storms. Returns 200 OK with no processing if the model is null.",
        "parameters": [
          {
            "name": "status",
            "in": "path",
            "description": "The status of the encoding callback (e.g., finished, error).",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset being encoded.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "eId",
            "in": "path",
            "description": "The Bitmovin encoding identifier.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The webhook payload containing encoding details.",
          "content": {
            "application/json-patch+json": {
              "schema": { }
            },
            "application/json": {
              "schema": { }
            },
            "text/json": {
              "schema": { }
            },
            "application/*+json": {
              "schema": { }
            },
            "application/xml": {
              "schema": { }
            },
            "text/xml": {
              "schema": { }
            },
            "application/*+xml": {
              "schema": { }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook callback was received and acknowledged."
          }
        }
      }
    },
    "/admin/blueforce/upload-image": {
      "post": {
        "tags": [
          "Blueforce"
        ],
        "summary": "Uploads an image from Blueforce and creates a new asset.",
        "description": "\r\n<b>Behavior:</b> Receives a base64-encoded image from a Blueforce device, uploads it to storage via the Blueforce unit of work, and returns the newly created asset identifier.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new asset is created in the system from the uploaded image.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the image body is null or empty. Returns 401 Unauthorized if the caller is not authenticated.",
        "parameters": [
          {
            "name": "endpointId",
            "in": "query",
            "description": "The Endpoint ID to use when calling back to the Blueforce server.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "imageId",
            "in": "query",
            "description": "The Blueforce ID of the image being uploaded.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "alertUnknownFaces",
            "in": "query",
            "description": "Tells the API if unknown faces should trigger an alert.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "fileName",
            "in": "query",
            "description": "The name of the image file being uploaded.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The incoming bytes of the image.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "string",
                "format": "byte"
              }
            },
            "application/json": {
              "schema": {
                "type": "string",
                "format": "byte"
              }
            },
            "text/json": {
              "schema": {
                "type": "string",
                "format": "byte"
              }
            },
            "application/*+json": {
              "schema": {
                "type": "string",
                "format": "byte"
              }
            },
            "application/xml": {
              "schema": {
                "type": "string",
                "format": "byte"
              }
            },
            "text/xml": {
              "schema": {
                "type": "string",
                "format": "byte"
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "string",
                "format": "byte"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Image was uploaded and an asset was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The image body was null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/brightcove/import": {
      "post": {
        "tags": [
          "Brightcove"
        ],
        "summary": "Imports Brightcove videos by their IDs.",
        "description": "\r\n<b>Behavior:</b> Imports the specified Brightcove videos into the system. When background mode is enabled (default), a batch action message is queued for asynchronous processing. When background mode is disabled, videos are archived synchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> In background mode, a batch action message is created and sent for asynchronous import. In foreground mode, videos are archived directly.\r\n\r\n<b>Error Scenarios:</b> Returns 204 No Content if the list of Brightcove IDs is null or empty. Returns 401 Unauthorized if the caller is not authenticated.",
        "parameters": [
          {
            "name": "background",
            "in": "query",
            "description": "Whether to process the import asynchronously in the background. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "description": "A list of Brightcove video IDs to import.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Videos were imported or queued for import successfully."
          },
          "204": {
            "description": "No Brightcove IDs were provided."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/brightcove/import-masters": {
      "post": {
        "tags": [
          "Brightcove"
        ],
        "summary": "Imports Brightcove master videos with pagination support.",
        "description": "\r\n<b>Behavior:</b> Imports Brightcove master videos starting from the specified page number. When background mode is enabled (default), a batch action message is queued for asynchronous processing. When background mode is disabled, masters are imported synchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> In background mode, a batch action message is created and sent for asynchronous import. In foreground mode, master videos are imported directly.\r\n\r\n<b>Error Scenarios:</b> Returns 401 Unauthorized if the caller is not authenticated.",
        "parameters": [
          {
            "name": "pageNumber",
            "in": "query",
            "description": "The page number to start importing from. Defaults to 0 if not specified.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "background",
            "in": "query",
            "description": "Whether to process the import asynchronously in the background. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Master videos were imported or queued for import successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/canto/import": {
      "post": {
        "tags": [
          "Canto"
        ],
        "summary": "Imports Canto assets by their IDs.",
        "description": "\r\n<b>Behavior:</b> Imports the specified Canto assets into the system. When background mode is enabled (default), a batch action message is queued for asynchronous processing. When background mode is disabled, assets are archived synchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> In background mode, a batch action message is created and sent for asynchronous import. In foreground mode, assets are archived directly via the Canto unit of work.\r\n\r\n<b>Error Scenarios:</b> Returns 204 No Content if the list of Canto IDs is null or empty. Returns 401 Unauthorized if the caller is not authenticated.",
        "parameters": [
          {
            "name": "background",
            "in": "query",
            "description": "Whether to process the import asynchronously in the background. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "description": "A list of Canto asset IDs to import.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Assets were imported or queued for import successfully."
          },
          "204": {
            "description": "No Canto IDs were provided."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/collection/{id}": {
      "get": {
        "tags": [
          "Collection"
        ],
        "summary": "Gets a specific collection by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Retrieves a single collection record matching the specified ID. Returns the full collection model if found.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is malformed. Returns 404 if no collection exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the collection to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The collection was found and returned successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is malformed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No collection exists with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Collection"
        ],
        "summary": "Deletes a specific collection by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the collection with the specified ID and returns the ID of the deleted collection.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Permanently removes the collection record from the database. Content items previously associated with this collection will lose that association.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the deletion fails or the collection ID is invalid.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the collection to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The collection was successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The deletion failed or the collection ID is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/collection/content/delete": {
      "post": {
        "tags": [
          "Collection"
        ],
        "summary": "Removes collection associations from the specified content items.",
        "description": "\r\n<b>Behavior:</b> Removes the collection-to-content associations for each content item in the provided list. Note that this does NOT delete the collections themselves, only the associations between collections and content items.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Removes metadata associations between content items and collections. The collections and content items themselves remain intact.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty. Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of collection-content associations to remove, containing the record and collection identifiers.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The collection-content associations were successfully removed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The items list is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/collection": {
      "post": {
        "tags": [
          "Collection"
        ],
        "summary": "Creates a new collection or updates an existing one.",
        "description": "\r\n<b>Behavior:</b> If the input model has no ID, creates a new collection with the provided name. If an ID is present, updates the existing collection. This design intentionally avoids the need for a separate PUT operation.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates a new collection record in the database or updates an existing one.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the name is null.",
        "requestBody": {
          "description": "The collection model containing the name and optional ID. If ID is null, a new collection is created; otherwise the existing collection is updated.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionModel"
                  }
                ],
                "description": "Represents a content collection with its identifier and display name."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionModel"
                  }
                ],
                "description": "Represents a content collection with its identifier and display name."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionModel"
                  }
                ],
                "description": "Represents a content collection with its identifier and display name."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionModel"
                  }
                ],
                "description": "Represents a content collection with its identifier and display name."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionModel"
                  }
                ],
                "description": "Represents a content collection with its identifier and display name."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionModel"
                  }
                ],
                "description": "Represents a content collection with its identifier and display name."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionModel"
                  }
                ],
                "description": "Represents a content collection with its identifier and display name."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The collection was successfully created or updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the collection name is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/collection/content": {
      "post": {
        "tags": [
          "Collection"
        ],
        "summary": "Adds collection associations to the specified content items.",
        "description": "\r\n<b>Behavior:</b> Creates collection-to-content associations for each content item in the provided list. If a referenced collection does not exist, the createNew flag in the model determines whether the collection should be automatically created.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates metadata associations between content items and collections. May also create new collection records if the createNew flag is set.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty. Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of collection-content associations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CollectionContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The collection-content associations were successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The items list is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/config/serverTime": {
      "get": {
        "tags": [
          "Config"
        ],
        "summary": "Retrieves the current UTC server time.",
        "description": "\r\n<b>Behavior:</b> Returns the current server time in UTC. This endpoint is useful for client-server time synchronization.\r\n\r\n<b>Authorization:</b> No authorization required. This is a public endpoint.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> None expected under normal operation.",
        "operationId": "getServerTime",
        "responses": {
          "200": {
            "description": "Returns the current server time in UTC."
          }
        }
      }
    },
    "/config": {
      "get": {
        "tags": [
          "Config"
        ],
        "summary": "Retrieves the system configuration model for the specified configuration type.",
        "description": "\r\n<b>Behavior:</b> Returns the configuration model matching the requested type. For `Admin`, returns the full admin configuration model.\r\n            For `Lambda`, currently returns an empty OK response (Lambda config is commented out).\r\n\r\n<b>Authorization:</b> Authorization is currently disabled (TODO) pending legacy admin app updates.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Throws an exception if the specified config type is not handled by any switch case.",
        "parameters": [
          {
            "name": "configType",
            "in": "query",
            "description": "The type of configuration to retrieve. Defaults to `Admin`.\n\n1 = Admin\n\n2 = Lambda\n\n3 = Groundtruth",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ConfigTypes"
                }
              ],
              "default": 1,
              "x-enumNames": [
                "Admin",
                "Lambda",
                "Groundtruth"
              ]
            },
            "x-enumNames": [
              "Admin",
              "Lambda",
              "Groundtruth"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the configuration model for the specified type.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigAdminModel"
                }
              }
            }
          },
          "500": {
            "description": "The specified config type is not handled."
          }
        }
      }
    },
    "/config/ClearServerCache": {
      "post": {
        "tags": [
          "Config"
        ],
        "summary": "Clears all server-side caches and invalidates the CloudFront Public API distribution.",
        "description": "\r\n<b>Behavior:</b> Removes all entries from the cache repository, reinitializes the configuration service,\r\n            invalidates the CloudFront Public API distribution with a wildcard path, and clears the in-memory ListManager.\r\n\r\n<b>Authorization:</b> Requires an authenticated user with admin privileges. Returns an error if the user is not an admin.\r\n\r\n<b>Side Effects:</b> Clears all cached data across the system, invalidates the CloudFront CDN distribution,\r\n            and reinitializes the configuration service. This operation affects all users of the system.\r\n\r\n<b>Error Scenarios:</b> Throws a VibrantException if the current user does not have admin permissions.",
        "responses": {
          "200": {
            "description": "Server cache was successfully cleared and CloudFront distribution invalidated."
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "403": {
            "description": "The user does not have admin permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/content/{name}": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Executes a batch action on content items by action name.",
        "description": "\r\n<b>Behavior:</b> Performs the specified batch action on the content items identified in the request body.\r\n            The action name is provided in the route and is matched (case-insensitive) against the BatchActions enum.\r\n            Common actions include Delete, Archive, Restore, Duplicate, Move, Copy, Index, Reprocess, AddTag,\r\n            RemoveTag, AddCollection, and RemoveCollection. The \"Asset Metadata\" content definition is reserved\r\n            and cannot be targeted by batch actions.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Modifies the targeted content items according to the specified action.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the action name is not a valid BatchActions value,\r\n            the request body is null, or the content definition is the reserved Asset Metadata definition.",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The batch action to perform (case-insensitive, e.g., \"delete\", \"archive\", \"addTag\").",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The batch model containing target content IDs and action arguments.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BatchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The batch action completed and results are returned.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The action name is invalid, the body is null, or the content definition is reserved.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/content/bulk-metadata-update": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Performs bulk metadata updates (collections, tags, related content, custom metadata) across multiple content items.",
        "description": "\r\n<b>Behavior:</b> Applies the specified property changes to all targeted content items.\r\n            If the number of content items exceeds the configured MaxBulkMetadataInlineUpdateSize threshold,\r\n            or if the background flag is set, the operation is queued as a batch action\r\n            for asynchronous processing. Otherwise, the updates are applied inline.\r\n            The \"Asset Metadata\" content definition is reserved and cannot be targeted.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Modifies metadata on all targeted content items. When processed in background mode,\r\n            creates a batch job for asynchronous execution.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the content definition is reserved, content IDs are missing,\r\n            or property changes are missing.",
        "parameters": [
          {
            "name": "background",
            "in": "query",
            "description": "When true, forces background batch processing regardless of item count. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "The payload containing the content IDs and property changes to apply.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentBulkMetadataUpdateModel"
                  }
                ],
                "description": "Request model for applying bulk metadata updates across multiple content items."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentBulkMetadataUpdateModel"
                  }
                ],
                "description": "Request model for applying bulk metadata updates across multiple content items."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentBulkMetadataUpdateModel"
                  }
                ],
                "description": "Request model for applying bulk metadata updates across multiple content items."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentBulkMetadataUpdateModel"
                  }
                ],
                "description": "Request model for applying bulk metadata updates across multiple content items."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentBulkMetadataUpdateModel"
                  }
                ],
                "description": "Request model for applying bulk metadata updates across multiple content items."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentBulkMetadataUpdateModel"
                  }
                ],
                "description": "Request model for applying bulk metadata updates across multiple content items."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentBulkMetadataUpdateModel"
                  }
                ],
                "description": "Request model for applying bulk metadata updates across multiple content items."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The bulk metadata update completed or was queued successfully."
          },
          "400": {
            "description": "The content definition is reserved, content IDs are empty, or property changes are empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content": {
      "get": {
        "tags": [
          "Content"
        ],
        "summary": "Retrieves all content records for a given content definition with pagination and sorting support.",
        "description": "\r\n<b>Behavior:</b> Returns a paginated, sorted list of content records belonging to the specified content definition.\r\n            Excludes asset metadata and asset content definitions, which must be accessed through the Asset endpoint.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have permission to the specified content definition.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the content definition ID is invalid, if the user lacks permission, or if the result is null.",
        "operationId": "GetAll",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "query",
            "description": "The unique identifier of the content definition to retrieve content for.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "sortColumn",
            "in": "query",
            "description": "The column name to sort by. Defaults to the system default sort column.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "isDesc",
            "in": "query",
            "description": "Whether to sort in descending order. Defaults to the system default.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "pageIndex",
            "in": "query",
            "description": "The zero-based page index. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "The number of records per page. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          },
          {
            "name": "language",
            "in": "query",
            "description": "Optional language filter GUID for multilingual content.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the paginated list of content records.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResultsModel"
                }
              }
            }
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, or the user lacks permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{contentDefinitionId}/find": {
      "get": {
        "tags": [
          "Content"
        ],
        "summary": "Finds content records within a content definition by matching a specific property value, with pagination and sorting.",
        "description": "\r\n<b>Behavior:</b> Searches for content records in the specified content definition where the given property name matches the provided value.\r\n            Results are paginated and sorted according to the supplied parameters.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have permission to the specified content definition.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the content definition is invalid, if the user lacks permission, or if the search result is null.",
        "operationId": "Find",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "path",
            "description": "The unique identifier of the content definition to search within.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "propertyName",
            "in": "query",
            "description": "The name of the property to match against.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "value",
            "in": "query",
            "description": "The value to search for in the specified property.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortColumn",
            "in": "query",
            "description": "The column name to sort by. Defaults to the system default sort column.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "isDesc",
            "in": "query",
            "description": "Whether to sort in descending order. Defaults to the system default.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "pageIndex",
            "in": "query",
            "description": "The zero-based page index. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "The number of records per page. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          },
          {
            "name": "language",
            "in": "query",
            "description": "Optional language filter GUID for multilingual content.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the matching content records.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentResultsModel"
                }
              }
            }
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, or the user lacks permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{id}": {
      "get": {
        "tags": [
          "Content"
        ],
        "summary": "Retrieves a single content record by its ID within a given content definition.",
        "description": "\r\n<b>Behavior:</b> Loads the content record matching the specified ID from the given content definition.\r\n            Can optionally load a revision instead of the current version.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have permission to the specified content definition.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the content definition is invalid, or if the user lacks permission. Returns 404 Not Found if the content record does not exist.",
        "operationId": "GetContent",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content record to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentDefinitionId",
            "in": "query",
            "description": "The unique identifier of the content definition the record belongs to.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "isRevision",
            "in": "query",
            "description": "If true, retrieves the revision version of the content record. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested content record.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentModel"
                }
              }
            }
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, or the user lacks permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content record was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Creates a new content record within a content definition.",
        "description": "\r\n<b>Behavior:</b> Persists a new content record using the provided content update model. On success, returns a 201 Created\r\n            response with a location header pointing to the newly created content record.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have write or higher permission to the content definition.\r\n            Read-only and Guest permissions are insufficient.\r\n\r\n<b>Side Effects:</b> Creates a new content record in the database. May trigger notifications depending on content definition configuration.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the content definition is invalid, if the user lacks sufficient write permissions, or if the save operation fails.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The content update model containing the data for the new content record.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "The content record was successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, the user lacks write permission, or save failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Content"
        ],
        "summary": "Updates an existing content record within a content definition.",
        "description": "\r\n<b>Behavior:</b> Replaces the content record data with the provided content update model. On success, returns a 201 Created\r\n            response with a location header pointing to the updated content record.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have write or higher permission to the content definition.\r\n            Read-only and Guest permissions are insufficient.\r\n\r\n<b>Side Effects:</b> Updates the content record in the database. May trigger notifications depending on content definition configuration.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the content definition is invalid, if the user lacks sufficient write permissions, or if the save operation fails.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content record to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The content update model containing the updated data.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentUpdateModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "The content record was successfully updated.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, the user lacks write permission, or save failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Content"
        ],
        "summary": "Deletes a content record from the specified content definition.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the specified content record from the given content definition.\r\n            This operation cannot be undone.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have delete-level permission to the content definition.\r\n            Read, Guest, and FileWrite permissions are insufficient.\r\n\r\n<b>Side Effects:</b> Permanently removes the content record from the database.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the content definition is invalid, or if the user lacks sufficient delete permissions.\r\n            Returns 404 Not Found if the content record does not exist or could not be deleted.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content record to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentDefinitionId",
            "in": "query",
            "description": "The unique identifier of the content definition the record belongs to.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "The content record was successfully deleted."
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, or the user lacks delete permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content record was not found or could not be deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{id}/history": {
      "get": {
        "tags": [
          "Content"
        ],
        "summary": "Retrieves the revision history list for a specific content record.",
        "description": "\r\n<b>Behavior:</b> Returns a list of all revision entries for the specified content record within the given content definition.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have permission to the specified content definition.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata,\r\n            if the content definition is invalid, if the user lacks permission, or if the history list is null.",
        "operationId": "GetHistoryById",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content record to retrieve history for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentDefinitionId",
            "in": "query",
            "description": "The unique identifier of the content definition the record belongs to.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the revision history list.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ContentRevisionModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, or the user lacks permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/New": {
      "get": {
        "tags": [
          "Content"
        ],
        "summary": "Creates a new empty content model template for a given content definition, ready for user input.",
        "description": "\r\n<b>Behavior:</b> Generates a new, unpopulated content model with default field values for the specified content definition.\r\n            This does not persist the content; it only creates the template structure for the client to fill in.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have write or higher permission to the content definition.\r\n            Read-only and Guest permissions are insufficient.\r\n\r\n<b>Side Effects:</b> None. The content is not saved until a subsequent POST/PUT call.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the content definition is invalid, or if the user lacks sufficient write permissions.",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "query",
            "description": "The unique identifier of the content definition to create a new content template for.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "language",
            "in": "query",
            "description": "Optional language GUID for multilingual content creation.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the new content model template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentModel"
                }
              }
            }
          },
          "400": {
            "description": "The content definition ID is invalid, reserved, or the user lacks write permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{contentDefinitionId}/duplicate/{contentId}": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Duplicates an existing content record within a content definition, creating a new in-memory copy with fresh identifiers.",
        "description": "\r\n<b>Behavior:</b> Loads the specified content record and creates a duplicate copy with a new ID, new MasterId,\r\n            fresh timestamps, and cleared modification user fields. The duplicate is returned but not yet persisted;\r\n            the client must submit it via a create/save endpoint to persist the copy.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have write or higher permission to the content definition.\r\n            Read-only and Guest permissions are insufficient.\r\n\r\n<b>Side Effects:</b> None. The duplicated content is not persisted until a subsequent save call.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata or assets,\r\n            if the original content record does not exist, if the content definition is invalid, or if the user lacks sufficient write permissions.",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "path",
            "description": "The unique identifier of the content definition containing the record to duplicate.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content record to duplicate.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the duplicated content model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentModel"
                }
              }
            }
          },
          "400": {
            "description": "The content record or definition is invalid, reserved, or the user lacks write permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{contentDefinitionId}/{id}": {
      "patch": {
        "tags": [
          "Content"
        ],
        "summary": "Partially updates specific properties of an existing content record using a property dictionary.",
        "description": "\r\n<b>Behavior:</b> Merges the supplied properties into the existing content record. Only fields defined in the content definition's\r\n            field list are updated; hard-coded system properties (e.g., security, timestamps) are skipped. If no changes are detected,\r\n            the save operation is skipped but the endpoint still returns success.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have write or higher permission to the content definition.\r\n            Read-only and Guest permissions are insufficient.\r\n\r\n<b>Side Effects:</b> Updates the specified properties in the content record. Notifications can be suppressed via the query parameter.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the content definition ID refers to asset metadata,\r\n            if required IDs are empty, if properties are null or empty, if the content definition is invalid,\r\n            if the user lacks write permissions, or if the content record does not exist.",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "path",
            "description": "The unique identifier of the content definition containing the record.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content record to patch.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "suppressNotifications",
            "in": "query",
            "description": "If true, suppresses any notifications that would normally be triggered by the update. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "A case-insensitive dictionary of property names and their new values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "object",
                "additionalProperties": { },
                "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later"
              }
            },
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": { },
                "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later"
              }
            },
            "text/json": {
              "schema": {
                "type": "object",
                "additionalProperties": { },
                "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later"
              }
            },
            "application/*+json": {
              "schema": {
                "type": "object",
                "additionalProperties": { },
                "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later"
              }
            },
            "application/xml": {
              "schema": {
                "type": "object",
                "additionalProperties": { },
                "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later"
              }
            },
            "text/xml": {
              "schema": {
                "type": "object",
                "additionalProperties": { },
                "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later"
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "object",
                "additionalProperties": { },
                "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "The content record properties were successfully patched.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "400": {
            "description": "The parameters are invalid, the content definition or record does not exist, or the user lacks write permission.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{contentDefinitionId}/user-track/{contentId}/touch": {
      "get": {
        "tags": [
          "Content"
        ],
        "summary": "Records or updates a user session touch event for tracking content viewing activity.",
        "description": "\r\n<b>Behavior:</b> Creates a new user session record or updates the last activity date on an existing session\r\n            for the specified content record. Captures browser type, OS, device type, and user email. This endpoint\r\n            is used as a heartbeat mechanism to track active content viewers.\r\n\r\n<b>Authorization:</b> Requires authentication with a valid user ID.\r\n\r\n<b>Side Effects:</b> Creates or updates a content user session record in the database.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the authenticated user does not have a valid user ID.",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "path",
            "description": "The unique identifier of the content definition containing the tracked content.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content record being tracked.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "The user session was successfully created or updated."
          },
          "400": {
            "description": "The user does not have a valid user ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{contentDefinitionId}/user-track/{contentId}/{sessionId}/{deactivate}": {
      "post": {
        "tags": [
          "Content"
        ],
        "summary": "Updates the deactivation status of a content user tracking session.",
        "description": "\r\n<b>Behavior:</b> Sets the deactivated flag on the specified user session record. This is typically used\r\n            to mark a user as no longer actively viewing content or to reactivate a previously deactivated session.\r\n\r\n<b>Authorization:</b> Requires authentication.\r\n\r\n<b>Side Effects:</b> Updates the deactivation status of the user session record in the database.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the session ID does not correspond to an existing session.",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "path",
            "description": "The unique identifier of the content definition (used for routing).",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content record (used for routing).",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "sessionId",
            "in": "path",
            "description": "The unique identifier of the user session to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "deactivate",
            "in": "path",
            "description": "If true, deactivates the session; if false, reactivates it.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "The user session status was successfully updated."
          },
          "400": {
            "description": "The session ID does not correspond to an existing session.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/content/{contentDefinitionId}/user-track/{contentId}": {
      "get": {
        "tags": [
          "Content"
        ],
        "summary": "Retrieves a paginated list of user tracking sessions for a specific content record.",
        "description": "\r\n<b>Behavior:</b> Returns all user session records associated with the specified content record, including details\r\n            such as browser type, email, IP address, session start date, and last activity date. Results are paginated and sorted.\r\n\r\n<b>Authorization:</b> Requires authentication.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> None expected under normal operation; returns an empty list if no sessions exist.",
        "parameters": [
          {
            "name": "contentDefinitionId",
            "in": "path",
            "description": "The unique identifier of the content definition (used for routing).",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content record to retrieve user sessions for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "sortColumn",
            "in": "query",
            "description": "The column name to sort by. Defaults to the system default sort column.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "isDesc",
            "in": "query",
            "description": "Whether to sort in descending order. Defaults to the system default.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "pageIndex",
            "in": "query",
            "description": "The zero-based page index. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "The number of records per page. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the paginated list of user session records.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentUserSessionModelListResultModel"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition": {
      "get": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Retrieves all content definitions accessible to the current user, with optional filtering by content management type.",
        "description": "\r\n<b>Behavior:</b> Returns a paginated and sorted list of content definitions that the current user has permission to access.\r\n            Excludes the Face content definition from the results. Results are filtered by the user's security permissions.\r\n\r\n<b>Authorization:</b> Requires authentication. Results are filtered to only include definitions the user has permission to access.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> None expected under normal operation; returns an empty list if no accessible definitions exist.",
        "parameters": [
          {
            "name": "contentManagementType",
            "in": "query",
            "description": "Optional filter for the content management type.\n\n1 = None\n\n2 = DataSelector\n\n3 = FormSelector",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ContentManagementTypes"
                }
              ]
            },
            "x-enumNames": [
              "None",
              "DataSelector",
              "FormSelector"
            ]
          },
          {
            "name": "sortColumn",
            "in": "query",
            "description": "The column name to sort by. Defaults to \"title\".",
            "schema": {
              "type": "string",
              "default": "title"
            }
          },
          {
            "name": "isDesc",
            "in": "query",
            "description": "Whether to sort in descending order. Defaults to the system default.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "pageIndex",
            "in": "query",
            "description": "The zero-based page index. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 0
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "The number of records per page. Defaults to the system default.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the filtered list of content definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentDefinitionModelListResultModel"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition/{id}": {
      "get": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Retrieves a single content definition by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Loads the content definition matching the specified ID and verifies the user has permission to access it.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have permission to the specified content definition.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 Not Found if the content definition does not exist.\r\n            Returns 400 Bad Request if the user lacks permission to the content definition.",
        "operationId": "GetContentDefinition",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content definition to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested content definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentDefinitionModel"
                }
              }
            }
          },
          "400": {
            "description": "The user does not have permission to the content definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content definition was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Creates a new content definition by persisting the provided model.",
        "description": "\r\n<b>Behavior:</b> Saves the provided content definition model to the database. On success, returns a 201 Created\r\n            response with a location header pointing to the newly created content definition.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> Creates a new content definition in the database, which may create associated MongoDB collections.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin or if the save operation fails.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The content definition model to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "The content definition was successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "uuid"
                }
              }
            }
          },
          "400": {
            "description": "The user is not an admin or the save operation failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Updates an existing content definition by replacing it with the provided model.",
        "description": "\r\n<b>Behavior:</b> Saves the updated content definition model to the database, replacing the existing definition with the same ID.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> Updates the content definition in the database, which may affect associated content records and editing forms.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin or if the save operation fails.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content definition to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The updated content definition model.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ContentDefinitionModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "The content definition was successfully updated."
          },
          "400": {
            "description": "The user is not an admin or the save operation failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Deletes a content definition by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the specified content definition and its associated configuration.\r\n            This operation cannot be undone.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> Permanently removes the content definition from the database. Associated content records may become orphaned.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin.\r\n            Returns 404 Not Found if the content definition does not exist or could not be deleted.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content definition to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "The content definition was successfully deleted."
          },
          "400": {
            "description": "The user is not an admin.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content definition was not found or could not be deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition/name/{name}": {
      "get": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Retrieves a content definition by its collection name.",
        "description": "\r\n<b>Behavior:</b> Looks up the content definition using the MongoDB collection name and verifies the user has permission to access it.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must have permission to the specified content definition.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 Not Found if no content definition matches the given collection name.\r\n            Returns 400 Bad Request if the user lacks permission to the content definition.",
        "operationId": "GetContentDefinitionByCollectionName",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The collection name of the content definition to retrieve.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested content definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentDefinitionModel"
                }
              }
            }
          },
          "400": {
            "description": "The user does not have permission to the content definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No content definition was found with the specified collection name.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition/EditorTemplate/{id}": {
      "get": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Retrieves the rendered editor template HTML for a specific content definition.",
        "description": "\r\n<b>Behavior:</b> Generates the editor form HTML content for the specified content definition using its transformer configuration.\r\n            This is used by the admin UI to render the content editing form.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin.\r\n            Returns 404 Not Found if the content definition transformer does not exist.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content definition to generate an editor template for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the rendered editor template HTML.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "The user is not an admin.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The content definition transformer was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition/New": {
      "get": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Creates a new empty content definition model template, ready for configuration by the admin.",
        "description": "\r\n<b>Behavior:</b> Generates a new, unpopulated content definition model with default values. This does not persist the definition;\r\n            it only creates the template structure for the admin to configure.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> None. The definition is not saved until a subsequent POST/PUT call.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin or if the new definition model could not be created.",
        "responses": {
          "200": {
            "description": "Returns the new content definition model template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentDefinitionModel"
                }
              }
            }
          },
          "400": {
            "description": "The user is not an admin or the model could not be created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition/NewContentField": {
      "get": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Creates a new empty content field model template for adding to a content definition.",
        "description": "\r\n<b>Behavior:</b> Generates a new, unpopulated content field model with default values. This does not persist the field;\r\n            it only creates the template structure for the admin to configure and then attach to a content definition.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> None. The field is not saved until the parent content definition is saved.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin or if the new field model could not be created.",
        "responses": {
          "200": {
            "description": "Returns the new content field model template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentFieldModel"
                }
              }
            }
          },
          "400": {
            "description": "The user is not an admin or the model could not be created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinition/rebuild-templates": {
      "post": {
        "tags": [
          "ContentDefinition"
        ],
        "summary": "Rebuilds all content definition override templates from their source configurations.",
        "description": "\r\n<b>Behavior:</b> Triggers a full rebuild of all content definition override templates. This is typically used after\r\n            system-level template changes or migrations to ensure all templates are up to date.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be a system admin user (elevated privileges beyond regular admin).\r\n\r\n<b>Side Effects:</b> Rebuilds all override templates in the system, which may temporarily affect content editing forms.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not a system admin.",
        "responses": {
          "204": {
            "description": "All override templates were successfully rebuilt."
          },
          "400": {
            "description": "The user is not a system admin.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentDefinitionGroup": {
      "get": {
        "tags": [
          "ContentDefinitionGroup"
        ],
        "summary": "Retrieves all content definition groups with their associated content definition IDs, ordered alphabetically.",
        "description": "\r\n<b>Behavior:</b> Returns all content definition groups sorted by description, each populated with the IDs of its\r\n            non-system-module content definitions sorted by title. System modules are excluded from the results.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin.",
        "responses": {
          "200": {
            "description": "Returns the list of content definition groups.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentDefinitionGroupModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The user is not an admin.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/contentType": {
      "get": {
        "tags": [
          "ContentType"
        ],
        "summary": "Retrieves all content types in the system, ordered alphabetically by title.",
        "description": "\r\n<b>Behavior:</b> Returns all available content types converted to models and sorted by title.\r\n            The result includes the total item count for client-side pagination awareness.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin.",
        "responses": {
          "200": {
            "description": "Returns the list of all content types.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContentTypeModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The user is not an admin.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/edgecaster": {
      "get": {
        "tags": [
          "EdgeCaster"
        ],
        "summary": "Retrieves EdgeCaster XML control data using the identity key from the request headers.",
        "description": "\r\n<b>Behavior:</b> Extracts the EdgeCaster identity key from the request headers. If a valid key is found, returns the XML control data for the associated channel. Logs the requesting IP address for auditing.\r\n\r\n<b>Authorization:</b> No authorization required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 Not Found if the identity key cannot be determined from the request headers.",
        "responses": {
          "200": {
            "description": "EdgeCaster XML control data returned successfully."
          },
          "404": {
            "description": "The identity key could not be determined from the request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/edgecaster/{id}": {
      "get": {
        "tags": [
          "EdgeCaster"
        ],
        "summary": "Retrieves EdgeCaster XML control data for a specific channel by ID.",
        "description": "\r\n<b>Behavior:</b> Parses the provided ID as a channel GUID and returns the XML control data for that specific live channel.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 Not Found if the ID cannot be parsed as a valid GUID or the channel does not exist.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the EdgeCaster live channel.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "EdgeCaster XML control data returned successfully for the specified channel."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The channel ID is invalid or the channel was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/edgecaster/{identityKey}/clearCache": {
      "post": {
        "tags": [
          "EdgeCaster"
        ],
        "summary": "Clears the EdgeCaster cache for a specific identity key.",
        "description": "\r\n<b>Behavior:</b> Clears the cached EdgeCaster control data associated with the specified identity key, forcing a refresh on the next request.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The EdgeCaster cache for the specified identity key is invalidated.\r\n\r\n<b>Error Scenarios:</b> Returns 401 Unauthorized if the caller is not authenticated. Logs a trace message if the identity key is empty.",
        "parameters": [
          {
            "name": "identityKey",
            "in": "path",
            "description": "The EdgeCaster identity key whose cache should be cleared.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Cache was cleared successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/eluvio/token": {
      "post": {
        "tags": [
          "Eluvio"
        ],
        "summary": "Gets a signed Eluvio security token using the specified mezzanine object ID.",
        "description": "\r\n<b>Behavior:</b> Generates and returns a signed Eluvio security token for the specified mezzanine object, enabling secure content access on the Eluvio Content Fabric.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 Not Found if the token could not be generated for the given request. Returns 401 Unauthorized if the caller is not authenticated.",
        "requestBody": {
          "description": "The Eluvio token request containing the mezzanine object ID.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EluvioTokenRequestModel"
                  }
                ],
                "description": "Represents the request model for generating a signed Eluvio content fabric security token."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The signed Eluvio security token was generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EluvioTokenResponseModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The token could not be generated for the specified object.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/field": {
      "get": {
        "tags": [
          "Field"
        ],
        "summary": "Retrieves all field definitions in the system, ordered alphabetically by title.",
        "description": "\r\n<b>Behavior:</b> Returns all available field definitions converted to models and sorted by title.\r\n            The result includes the total item count for client-side pagination awareness.\r\n\r\n<b>Authorization:</b> Requires authentication and the user must be an admin user.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the user is not an admin.",
        "responses": {
          "200": {
            "description": "Returns the list of all field definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FieldModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The user is not an admin.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/hybrik/webhook/{id}": {
      "post": {
        "tags": [
          "Hybrik"
        ],
        "summary": "Receives a Hybrik encoding webhook callback.",
        "description": "\r\n<b>Behavior:</b> Processes a webhook callback from the Hybrik encoding service. Packages the model data into a batch action message for asynchronous processing via the HybrikUnitOfWork.\r\n\r\n<b>Authorization:</b> No authorization required. Validated by webhook filter.\r\n\r\n<b>Side Effects:</b> A batch action message is sent to trigger asynchronous processing of the encoding result.\r\n\r\n<b>Error Scenarios:</b> Returns 200 OK even on errors to acknowledge receipt. Errors are logged but swallowed to prevent webhook retry storms. Returns 200 OK with no processing if the model is null.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the asset being encoded.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The webhook payload containing encoding details.",
          "content": {
            "application/json-patch+json": {
              "schema": { }
            },
            "application/json": {
              "schema": { }
            },
            "text/json": {
              "schema": { }
            },
            "application/*+json": {
              "schema": { }
            },
            "application/xml": {
              "schema": { }
            },
            "text/xml": {
              "schema": { }
            },
            "application/*+xml": {
              "schema": { }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook callback was received and acknowledged."
          }
        }
      }
    },
    "/admin/job": {
      "post": {
        "tags": [
          "Job"
        ],
        "summary": "Submits a new processing job for an asset.",
        "description": "\r\n<b>Behavior:</b> Creates and submits a new processing job using the provided job model, returning the generated job identifier.\r\n\r\n<b>Authorization:</b> No authorization required.\r\n\r\n<b>Side Effects:</b> A new processing job is created and queued for execution.\r\n\r\n<b>Error Scenarios:</b> Returns an error if the job submission fails.",
        "requestBody": {
          "description": "The job submission model containing processing parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SubmitJobModel"
                  }
                ],
                "description": "Represents the input model for submitting a media processing job."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SubmitJobModel"
                  }
                ],
                "description": "Represents the input model for submitting a media processing job."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SubmitJobModel"
                  }
                ],
                "description": "Represents the input model for submitting a media processing job."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SubmitJobModel"
                  }
                ],
                "description": "Represents the input model for submitting a media processing job."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SubmitJobModel"
                  }
                ],
                "description": "Represents the input model for submitting a media processing job."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SubmitJobModel"
                  }
                ],
                "description": "Represents the input model for submitting a media processing job."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SubmitJobModel"
                  }
                ],
                "description": "Represents the input model for submitting a media processing job."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Job was submitted successfully and the job ID is returned.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          }
        }
      }
    },
    "/admin/job/{assetId}": {
      "post": {
        "tags": [
          "Job"
        ],
        "summary": "Receives a job completion callback for a specific asset.",
        "description": "\r\n<b>Behavior:</b> Processes a job completion notification by sending a batch action message to mark the job as complete for the specified asset.\r\n\r\n<b>Authorization:</b> No authorization required.\r\n\r\n<b>Side Effects:</b> A batch action message is sent to trigger downstream job completion processing.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the model is null.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset whose job has completed.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The job completion details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/JobCompleteModel"
                  }
                ],
                "description": "Represents the completion callback model for a media processing job."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/JobCompleteModel"
                  }
                ],
                "description": "Represents the completion callback model for a media processing job."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/JobCompleteModel"
                  }
                ],
                "description": "Represents the completion callback model for a media processing job."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/JobCompleteModel"
                  }
                ],
                "description": "Represents the completion callback model for a media processing job."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/JobCompleteModel"
                  }
                ],
                "description": "Represents the completion callback model for a media processing job."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/JobCompleteModel"
                  }
                ],
                "description": "Represents the completion callback model for a media processing job."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/JobCompleteModel"
                  }
                ],
                "description": "Represents the completion callback model for a media processing job."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Job completion callback was processed successfully."
          },
          "400": {
            "description": "The completion model was null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/admin/transcribe-job/{assetId}": {
      "post": {
        "tags": [
          "Job"
        ],
        "summary": "Receives an external transcription job completion callback for a specific asset.",
        "description": "\r\n<b>Behavior:</b> Validates the transcription result, verifies the asset and its content access key, then sends a batch action message to complete the transcription workflow. The content access key is deleted after successful validation.\r\n\r\n<b>Authorization:</b> No authorization required.\r\n\r\n<b>Side Effects:</b> The content access key for the asset is deleted. A batch action message is sent to finalize the transcription. Processor job status is updated on failure.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the model is null, the asset ID is invalid, the transcription status is not COMPLETED, or the access key is missing or expired.",
        "parameters": [
          {
            "name": "assetId",
            "in": "path",
            "description": "The unique identifier of the asset whose transcription job has completed.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The transcription result model containing status and transcription data.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NomadTranscriptionModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NomadTranscriptionModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NomadTranscriptionModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NomadTranscriptionModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NomadTranscriptionModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NomadTranscriptionModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NomadTranscriptionModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transcription job completion was processed successfully."
          },
          "400": {
            "description": "The model is null, the asset is invalid, the status is not completed, or the access key is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/liveChannel/new": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a pre-filled template for creating a new live channel.",
        "description": "\r\n<b>Behavior:</b> Returns a pre-populated Nomad.Common.Models.Live.LiveChannelNewModel with default values\r\n            that can be modified and submitted to the create endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the template cannot be generated.",
        "responses": {
          "200": {
            "description": "The template was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelNewModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The template could not be generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a new live channel and requests provisioning of the underlying system resource.",
        "description": "\r\n<b>Behavior:</b> Creates a new live channel record and initiates resource provisioning.\r\n            The channel is not available immediately; it will have a status of Nomad.Common.Enums.LiveChannelStatuses.Creating\r\n            until provisioning completes. Use the M:Nomad.Controller.Live.LiveChannelController.New endpoint to obtain a starter template.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a live channel record and initiates cloud resource provisioning.",
        "requestBody": {
          "description": "The live channel creation model with configuration details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelNewModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The live channel was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves all live channels in the system.",
        "description": "\r\n<b>Behavior:</b> Returns the complete list of live channels regardless of their current status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The live channels were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveChannelModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Updates an existing live channel configuration.",
        "description": "\r\n<b>Behavior:</b> Applies the changes from the edit model to the live channel.\r\n            Note that underlying cloud resources may not be updated immediately even though the\r\n            channel record reflects the changes.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the live channel record and may trigger cloud resource updates.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the edit model is null.",
        "requestBody": {
          "description": "The edit model containing the updated channel configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveChannelEditModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The live channel was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModel"
                }
              }
            }
          },
          "400": {
            "description": "The edit model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a specific live channel by its identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the full live channel model for the specified channel ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live channel was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Deletes a live channel and its associated cloud resource.",
        "description": "\r\n<b>Behavior:</b> Deletes the live channel record and requests deprovisioning of the underlying\r\n            cloud resource. The resource may not be deleted immediately, and the channel record may remain\r\n            temporarily accessible. The operation will fail if other resources (such as schedule events)\r\n            still reference this channel.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes the live channel record and initiates cloud resource deprovisioning.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live channel was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveChannelModelLiveResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/clip": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a clip from a live channel stream.",
        "description": "\r\n<b>Behavior:</b> Initiates a clip operation on the specified live channel using the provided\r\n            clip parameters (e.g., start time, duration). The clip is processed asynchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Initiates a clip extraction from the live stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to clip from.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The clip parameters specifying the segment to extract.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ClipModel"
                  }
                ],
                "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The clip request was accepted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/clipsnapshot": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a snapshot clip from a live channel stream.",
        "description": "\r\n<b>Behavior:</b> Captures a snapshot clip from the specified live channel at the current\r\n            playback position. Returns clip details including the generated asset information.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a snapshot clip asset from the live stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to snapshot.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The snapshot clip was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveClipResponseModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/set-cookies": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves signed cookies or tokens for secure live stream playback.",
        "description": "\r\n<b>Behavior:</b> Generates and sets signed cookies on the response for authenticated\r\n            access to the live stream CDN. If the stream uses token-based authentication instead,\r\n            returns the playback token. This enables third-party integrations to obtain secured\r\n            stream URLs per user.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Sets signed cookies on the HTTP response for CDN authentication.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the channel has no configured output stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The cookies or tokens were generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The channel has no configured output stream.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/properties": {
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Updates the custom properties map for a live channel.",
        "description": "\r\n<b>Behavior:</b> Replaces or merges the specified key-value pairs into the\r\n            live channel's properties dictionary.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the channel's custom properties in the data store.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "A dictionary of property key-value pairs to update.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            },
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            },
            "text/json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "object",
                "additionalProperties": { }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The properties were updated successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/startOutputTracking": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Starts output tracking for a live channel.",
        "description": "\r\n<b>Behavior:</b> Initiates output tracking for the specified live channel,\r\n            enabling monitoring of the channel's output streams and viewer metrics.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Enables output tracking for the channel.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Output tracking was started successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/start": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Starts a live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a start command to the live channel, beginning the live stream.\r\n            The channel must be in a valid state (e.g., idle or stopped) to be started.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Starts the live channel and begins streaming.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to start.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was started successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/pause": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Pauses a live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a pause command to the live channel, temporarily suspending\r\n            the live stream. The channel can be resumed later without restarting.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Pauses the live channel stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to pause.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was paused successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/resume": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Resumes a paused live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a resume command to a previously paused live channel,\r\n            continuing the live stream from where it was paused.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Resumes the live channel stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to resume.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was resumed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/stop": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Stops a live channel.",
        "description": "\r\n<b>Behavior:</b> Sends a stop command to the live channel, ending the live stream.\r\n            The channel can be started again later.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Stops the live channel stream.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to stop.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was stopped successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/nextEvent": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Advances a live channel to its next scheduled event.",
        "description": "\r\n<b>Behavior:</b> Triggers a transition to the next event in the channel's schedule,\r\n            skipping any remaining time on the current event.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Advances the channel schedule to the next event.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel advanced to the next event successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/refresh": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Refreshes all live channels in the system.",
        "description": "\r\n<b>Behavior:</b> Synchronizes the state of all live channels with their\r\n            underlying cloud resources, updating status and configuration information.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the cached state of all live channels.",
        "responses": {
          "200": {
            "description": "All channels were refreshed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/refresh/{utcDateTimeTicks}": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Refreshes a specific live channel at a given point in time.",
        "description": "\r\n<b>Behavior:</b> Synchronizes the state of the specified live channel with its\r\n            underlying cloud resource. The UTC date-time ticks parameter allows specifying the\r\n            reference point for the refresh; if the value cannot be parsed, the current UTC time is used.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the cached state of the specified live channel.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel to refresh.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "utcDateTimeTicks",
            "in": "path",
            "description": "The UTC date-time ticks value for the refresh reference point.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was refreshed successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent/new": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a pre-filled template for creating a new schedule event on a live channel.",
        "description": "\r\n<b>Behavior:</b> Returns a pre-populated Nomad.Common.Models.Live.LiveScheduleEventNewModel with default\r\n            values for the specified channel, which can be modified and submitted to the create schedule event endpoint.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The template was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent": {
      "post": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Creates a new schedule event on a live channel.",
        "description": "\r\n<b>Behavior:</b> Adds a new event to the channel's schedule. The channel ID in the\r\n            request body must match the channel ID in the route.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a new schedule event and may affect the channel's playback schedule.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the channel ID in the body does not match the route.\r\n            Returns 404 if the new schedule event model is null.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The schedule event creation model.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventNewModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule event was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The channel ID in the body does not match the route.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The schedule event model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves all schedule events for a live channel.",
        "description": "\r\n<b>Behavior:</b> Returns the complete list of schedule events associated with the specified live channel.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule events were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveScheduleEventModel"
                  },
                  "description": "Represents a paginated list of live resource models."
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Updates an existing schedule event on a live channel.",
        "description": "\r\n<b>Behavior:</b> Applies the changes from the edit model to the schedule event.\r\n            The channel ID in the request body must match the channel ID in the route.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the schedule event and may affect the channel's playback schedule.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the channel ID in the body does not match the route.\r\n            Returns 404 if the schedule event model is null or the update fails.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The edit model containing the updated schedule event configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventEditModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule event was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventModel"
                }
              }
            }
          },
          "400": {
            "description": "The channel ID in the body does not match the route.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The schedule event was not found or the update failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent/{scheduleEventId}": {
      "get": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Retrieves a specific schedule event from a live channel.",
        "description": "\r\n<b>Behavior:</b> Returns the schedule event model for the specified event within the given channel.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if the schedule event does not exist.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "scheduleEventId",
            "in": "path",
            "description": "The unique identifier of the schedule event.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule event was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The schedule event was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Deletes a schedule event from a live channel.",
        "description": "\r\n<b>Behavior:</b> Removes the specified schedule event from the channel's schedule.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Deletes the schedule event and may affect the channel's playback schedule.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "scheduleEventId",
            "in": "path",
            "description": "The unique identifier of the schedule event to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule event was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleEventResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveChannel/{channelId}/liveScheduleEvent/{scheduleEventId}/move": {
      "put": {
        "tags": [
          "LiveChannel"
        ],
        "summary": "Moves a schedule event to a new position within the channel's schedule.",
        "description": "\r\n<b>Behavior:</b> Repositions the specified schedule event within the channel's schedule order.\r\n            The event is moved to immediately after the event specified by the previous schedule event ID\r\n            in the move model. Returns the updated list of schedule events reflecting the new order.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Reorders the channel's schedule events.",
        "parameters": [
          {
            "name": "channelId",
            "in": "path",
            "description": "The unique identifier of the live channel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "scheduleEventId",
            "in": "path",
            "description": "The unique identifier of the schedule event to move.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The move model specifying the target position.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEventMoveModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule event was moved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveScheduleEventModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveInput/new": {
      "get": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Gets a pre-filled template for creating a new live input.",
        "description": "**Behavior:**\r\nReturns a pre-populated Nomad.Common.Models.Live.LiveInputNewModel object with default values\r\nthat can be customized and submitted to M:Nomad.Controller.Live.LiveInputController.Create(Nomad.Common.Models.Live.LiveInputNewModel) to provision a new live input.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.\r\n- Returns 404 if the template could not be generated.",
        "responses": {
          "200": {
            "description": "Returns the pre-filled live input template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputNewModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Template could not be generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveInput": {
      "post": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Creates a new live input and begins provisioning the underlying resource.",
        "description": "**Behavior:**\r\nCreates a new Nomad.Common.Models.Live.LiveInputModel record and initiates provisioning of the live input resource.\r\nThe initial record will have a Nomad.Common.Models.Live.LiveInputModel.Status of Nomad.Common.Enums.LiveInputStatuses.Creating\r\nuntil provisioning completes.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new live input record is persisted.\r\n- Background provisioning of the live input resource is initiated.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the input model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Live.LiveInputNewModel object. A starter object can be obtained from M:Nomad.Controller.Live.LiveInputController.New.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputNewModel"
                  }
                ],
                "description": "NOTE: MediaConnect input creation not supported"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the newly created live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided input model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Returns all live inputs, excluding those with a Deleting status.",
        "description": "**Behavior:**\r\nRetrieves all Nomad.Common.Models.Live.LiveInputModel records and filters out any that have a status of\r\nNomad.Common.Enums.LiveInputStatuses.Deleting. Inputs currently being deleted are excluded because\r\nfailed deletes transition to an error state which is visible in the UI.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the list of live inputs.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveInputModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Updates an existing live input configuration.",
        "description": "**Behavior:**\r\nUpdates a live input record using the values from the provided Nomad.Common.Models.Live.LiveInputEditModel.\r\nChanges to the underlying resource may not take effect immediately even though the\r\nNomad.Common.Models.Live.LiveInputModel record reflects the update.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live input record is updated in the data store.\r\n- Background propagation of changes to the provisioned resource may occur.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the edit model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Live.LiveInputEditModel containing updated values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveInputEditModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the updated live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided edit model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveInput/{inputId}": {
      "get": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Gets a specific live input by its identifier.",
        "description": "**Behavior:**\r\nRetrieves a single Nomad.Common.Models.Live.LiveInputModel matching the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "inputId",
            "in": "path",
            "description": "The unique identifier of the live input to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveInput"
        ],
        "summary": "Deletes a live input and its provisioned resources.",
        "description": "**Behavior:**\r\nDeletes the Nomad.Common.Models.Live.LiveInputModel record and its associated provisioned resource.\r\nThe deletion may not complete immediately; the resource transitions through intermediate states.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live input record is marked for deletion.\r\n- The provisioned resource is scheduled for teardown.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.\r\n- Fails if Nomad.Common.Models.Live.LiveChannelModel or Nomad.Common.Models.Live.LiveScheduleEventModel objects still reference the live input.",
        "parameters": [
          {
            "name": "inputId",
            "in": "path",
            "description": "The unique identifier of the live input to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the result model containing the deleted live input.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveInputModelLiveResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/start": {
      "post": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Starts a live broadcast.",
        "description": "**Behavior:**\r\nInitiates a new live broadcast session using the provided configuration.\r\nReturns the created Nomad.Common.Models.Admin.LiveOperator.LiveOperatorModel representing the active broadcast.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new live operator record is created.\r\n- The broadcast session begins streaming.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the input model fails validation.\r\n- Returns 401 if the request is not authenticated.\r\n- Returns 404 if the referenced resources could not be found.",
        "requestBody": {
          "description": "The broadcast configuration model specifying stream parameters.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorStreamRequestModel"
                  }
                ],
                "description": "Represents the request model for creating or starting a live operator stream."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorStreamRequestModel"
                  }
                ],
                "description": "Represents the request model for creating or starting a live operator stream."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorStreamRequestModel"
                  }
                ],
                "description": "Represents the request model for creating or starting a live operator stream."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorStreamRequestModel"
                  }
                ],
                "description": "Represents the request model for creating or starting a live operator stream."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorStreamRequestModel"
                  }
                ],
                "description": "Represents the request model for creating or starting a live operator stream."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorStreamRequestModel"
                  }
                ],
                "description": "Represents the request model for creating or starting a live operator stream."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorStreamRequestModel"
                  }
                ],
                "description": "Represents the request model for creating or starting a live operator stream."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the live operator model for the started broadcast.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOperatorModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided broadcast configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Referenced resources could not be found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/{liveOperatorId}/cancel": {
      "post": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Cancels a live broadcast.",
        "description": "**Behavior:**\r\nCancels the broadcast session identified by the specified live operator identifier.\r\nNo recorded content is saved from the cancelled broadcast.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The broadcast session is terminated.\r\n- The live operator record is updated to reflect cancellation.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOperatorId",
            "in": "path",
            "description": "The unique identifier of the broadcast to cancel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The broadcast was cancelled successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/{liveOperatorId}/stop": {
      "post": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Stops a live broadcast.",
        "description": "**Behavior:**\r\nStops the broadcast session identified by the specified live operator identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The broadcast session is stopped.\r\n- The live operator record is updated to reflect the stopped state.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOperatorId",
            "in": "path",
            "description": "The unique identifier of the broadcast to stop.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The broadcast was stopped successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/{liveOperatorId}/startSegment": {
      "post": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Starts a new recording segment within a broadcast.",
        "description": "**Behavior:**\r\nBegins a new recording segment for the broadcast identified by the specified live operator identifier.\r\nA segment captures a portion of the broadcast stream for later retrieval.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new recording segment is started within the broadcast session.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOperatorId",
            "in": "path",
            "description": "The unique identifier of the broadcast in which to start a segment.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The recording segment was started successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/{liveOperatorId}/cancelSegment": {
      "post": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Cancels the current recording segment within a broadcast.",
        "description": "**Behavior:**\r\nCancels the active recording segment for the broadcast identified by the specified live operator identifier.\r\nThe recorded content from the cancelled segment is discarded.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The current recording segment is cancelled and its content is discarded.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOperatorId",
            "in": "path",
            "description": "The unique identifier of the broadcast whose segment to cancel.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The recording segment was cancelled successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/{liveOperatorId}/completeSegment": {
      "post": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Completes the current recording segment and saves the recording.",
        "description": "**Behavior:**\r\nFinalizes the active recording segment for the specified broadcast and persists the recorded content\r\nas an asset. The segment details are provided in the request body.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The current recording segment is completed.\r\n- The recorded content is saved as an asset.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the segment completion model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOperatorId",
            "in": "path",
            "description": "The unique identifier of the broadcast whose segment to complete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The segment completion model containing recording details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorSegmentRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a new segment within a live operator stream."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorSegmentRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a new segment within a live operator stream."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorSegmentRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a new segment within a live operator stream."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorSegmentRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a new segment within a live operator stream."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorSegmentRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a new segment within a live operator stream."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorSegmentRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a new segment within a live operator stream."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreateLiveOperatorSegmentRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a new segment within a live operator stream."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The recording segment was completed and saved successfully."
          },
          "400": {
            "description": "Validation failed for the provided segment completion model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/{liveOperatorId}/segments": {
      "get": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Gets the completed recording segments for a broadcast.",
        "description": "**Behavior:**\r\nRetrieves a list of Nomad.Common.Models.Admin.Asset.AssetReferenceModel objects representing the completed\r\nrecording segments for the specified broadcast.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOperatorId",
            "in": "path",
            "description": "The unique identifier of the broadcast whose segments to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the list of completed recording segments.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AssetReferenceModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator": {
      "get": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Lists all live operators.",
        "description": "**Behavior:**\r\nRetrieves all Nomad.Common.Models.Admin.LiveOperator.LiveOperatorModel records in the system.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the list of all live operators.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveOperatorModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveOperator/{liveOperatorId}": {
      "get": {
        "tags": [
          "LiveOperator"
        ],
        "summary": "Gets a specific live operator by its identifier.",
        "description": "**Behavior:**\r\nRetrieves a single Nomad.Common.Models.Admin.LiveOperator.LiveOperatorModel matching the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOperatorId",
            "in": "path",
            "description": "The unique identifier of the live operator to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested live operator.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOperatorModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfile/new": {
      "get": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Gets a pre-filled template for creating a new output profile.",
        "description": "**Behavior:**\r\nReturns a pre-populated Nomad.Common.Models.Live.LiveOutputProfileModel object with default values\r\nthat can be customized and submitted to M:Nomad.Controller.Live.LiveOutputProfileController.Create(Nomad.Common.Models.Live.LiveOutputProfileModel) to create a new output profile.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.\r\n- Returns 404 if the template could not be generated.",
        "responses": {
          "200": {
            "description": "Returns the pre-filled output profile template.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "Template could not be generated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfile": {
      "post": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Creates a new output profile.",
        "description": "**Behavior:**\r\nCreates a new Nomad.Common.Models.Live.LiveOutputProfileModel record for configuring live output encoding settings.\r\nA starter object can be obtained from M:Nomad.Controller.Live.LiveOutputProfileController.New.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new output profile record is persisted.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Live.LiveOutputProfileModel object containing the output profile configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the newly created output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Returns all output profiles.",
        "description": "**Behavior:**\r\nRetrieves all Nomad.Common.Models.Live.LiveOutputProfileModel records configured in the system.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the list of output profiles.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Updates an existing output profile.",
        "description": "**Behavior:**\r\nUpdates an output profile record using the values from the provided Nomad.Common.Models.Live.LiveOutputProfileModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile record is updated in the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Live.LiveOutputProfileModel containing updated values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileModel"
                  }
                ],
                "description": "Represents a live output encoding profile with video and audio settings."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the updated output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfile/{liveOutputProfileId}": {
      "get": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Gets a specific output profile by its identifier.",
        "description": "**Behavior:**\r\nRetrieves a single Nomad.Common.Models.Live.LiveOutputProfileModel matching the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileId",
            "in": "path",
            "description": "The unique identifier of the output profile to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveOutputProfile"
        ],
        "summary": "Deletes an output profile.",
        "description": "**Behavior:**\r\nDeletes the Nomad.Common.Models.Live.LiveOutputProfileModel record and its associated resources.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile record is removed from the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileId",
            "in": "path",
            "description": "The unique identifier of the output profile to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the result model containing the deleted output profile.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileModelLiveResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfileGroup": {
      "post": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Creates a new output profile group.",
        "description": "**Behavior:**\r\nCreates a new Nomad.Common.Models.Live.LiveOutputProfileGroupModel record that groups related output profiles together.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A new output profile group record is persisted.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile group model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Live.LiveOutputProfileGroupModel object containing the group configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the newly created output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile group model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Returns all output profile groups.",
        "description": "**Behavior:**\r\nRetrieves all Nomad.Common.Models.Live.LiveOutputProfileGroupModel records configured in the system.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "responses": {
          "200": {
            "description": "Returns the list of output profile groups.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Updates an existing output profile group.",
        "description": "**Behavior:**\r\nUpdates an output profile group record using the values from the provided Nomad.Common.Models.Live.LiveOutputProfileGroupModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile group record is updated in the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 400 if the output profile group model fails validation.\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The Nomad.Common.Models.Live.LiveOutputProfileGroupModel containing updated values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                  }
                ],
                "description": "Represents a group of live output profiles with shared configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns the updated output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                }
              }
            }
          },
          "400": {
            "description": "Validation failed for the provided output profile group model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/liveOutputProfileGroup/{liveOutputProfileGroupId}": {
      "get": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Gets a specific output profile group by its identifier.",
        "description": "**Behavior:**\r\nRetrieves a single Nomad.Common.Models.Live.LiveOutputProfileGroupModel matching the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileGroupId",
            "in": "path",
            "description": "The unique identifier of the output profile group to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the requested output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveOutputProfileGroupModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveOutputProfileGroup"
        ],
        "summary": "Deletes an output profile group.",
        "description": "**Behavior:**\r\nDeletes the Nomad.Common.Models.Live.LiveOutputProfileGroupModel record identified by the specified identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The output profile group record is removed from the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "liveOutputProfileGroupId",
            "in": "path",
            "description": "The unique identifier of the output profile group to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the identifier of the deleted output profile group.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Creates or updates a live schedule record for a content item.",
        "description": "**Behavior:**\r\nPersists a new live schedule or updates an existing one for the content item referenced\r\nin the provided Nomad.Common.Models.Live.LiveScheduleEditModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- A live schedule record is created or updated in the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "requestBody": {
          "description": "The create/edit DTO model for live schedule metadata.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleEditModel"
                  }
                ],
                "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The live schedule was saved successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}": {
      "get": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Gets the live schedule for a specific content item.",
        "description": "**Behavior:**\r\nRetrieves the Nomad.Common.Models.Live.LiveScheduleModel associated with the specified content identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the live schedule for the content item.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LiveScheduleModel"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Deletes the live schedule for a specific content item.",
        "description": "**Behavior:**\r\nRemoves the live schedule record associated with the specified content identifier.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live schedule record is removed from the data store.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live schedule was deleted successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}/start": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Starts a live schedule immediately.",
        "description": "**Behavior:**\r\nTriggers an immediate start of the live schedule associated with the specified content item.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live schedule transitions to a running state.\r\n- Associated live channel broadcasting may begin.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to start.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live schedule was started successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}/stop": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Stops a live schedule immediately.",
        "description": "**Behavior:**\r\nTriggers an immediate stop of the live schedule associated with the specified content item.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- The live schedule transitions to a stopped state.\r\n- Associated live channel broadcasting is halted.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item whose live schedule to stop.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The live schedule was stopped successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/liveSchedule/content/{contentId}/copy": {
      "post": {
        "tags": [
          "LiveSchedule"
        ],
        "summary": "Copies a content item and its live schedule using recurring criteria.",
        "description": "**Behavior:**\r\nCreates copies of the content item referenced by the specified identifier along with its\r\nassociated live schedule, applying the recurring criteria defined in the Nomad.Common.Models.Live.LiveScheduleCopyModel.\r\n            \r\n**Authorization:**\r\nRequires an authenticated user with a valid bearer token.\r\n            \r\n**Side Effects:**\r\n- New content records and associated live schedule records are created.\r\n            \r\n**Error Scenarios:**\r\n- Returns 401 if the request is not authenticated.",
        "parameters": [
          {
            "name": "contentId",
            "in": "path",
            "description": "The unique identifier of the content item to copy.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The model containing recurring copy criteria.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LiveScheduleCopyModel"
                  }
                ],
                "description": "Represents the input model for copying a live schedule with recurring options."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The content and schedule were copied successfully."
          },
          "401": {
            "description": "Unauthorized. Bearer token is missing or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/lookup/{lookupType}": {
      "get": {
        "tags": [
          "Lookup"
        ],
        "summary": "Retrieves lookup values for the specified lookup type, with optional key-based filtering.",
        "description": "\r\n<b>Behavior:</b> Returns a list of lookup models matching the specified type. For the `AllTags` lookup type,\r\n            if the lookupKey is a truthy boolean string, content definition tag lookups are appended to the result set.\r\n            Results include the total item count for client-side pagination awareness.\r\n\r\n<b>Authorization:</b> Requires authentication.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 Bad Request if the lookup service returns null for the specified type and key.",
        "operationId": "GetLookup",
        "parameters": [
          {
            "name": "lookupType",
            "in": "path",
            "description": "The type of lookup values to retrieve (e.g., AllTags, Languages, etc.).\n\nPageTemplates\n\nFields\n\nLookupTypes\n\nContentTemplates\n\nContentDefinitions\n\nContentTypes\n\nContentDefinitionGroups\n\nWorkflowStatuses\n\nDataSelectorContentDefinitions\n\nContent\n\nTemplatePacks\n\nPopularTags\n\nAllTags\n\nPropertyValues\n\nMediaTypes\n\nAssetTypes\n\nContentFields\n\nFormSelectorContentDefinitions\n\nCustomRenderers\n\nConstantContactCampaigns\n\nLanguages\n\nSecurityGroups\n\nCollections\n\nSecurityPermissions\n\nCustomLabelerTypes\n\nCustomLabelerStatuses\n\nLabels\n\nUsers\n\nMeetingSources\n\nLiveScheduleEventStatuses\n\nLiveExternalOutputProfiles\n\nLiveScheduleEventTypes\n\nLiveChannelStatuses\n\nLiveInputCodecs\n\nLiveInputMaximumBitrates\n\nLiveInputResolutions\n\nLiveInputStatuses\n\nLiveInputTypes\n\nNodeTypes\n\nLiveChannelTypes\n\nLiveOutputTypes\n\nRoles\n\nNewsSystems\n\nNprProfileTypes\n\nPaymentStatuses\n\nPingStatuses\n\nPropertyValueTypes\n\nScheduleItemSearchTypes\n\nScheduleItemSourceTypes\n\nScheduleItemTypes\n\nScheduleStatuses\n\nScheduleTypes\n\nStorageClasses\n\nSubtitleTypes\n\nSubtitleValueTypes\n\nTextEntityTypes\n\nUploadOverwriteOptions\n\nUserSessionStatuses\n\nVideoSegmentTypes\n\nVideoTrackingEvents\n\nBatchActionProcessorExecutionTypes\n\nVideoTrackingAttributes\n\nTemplatePackTypes\n\nAdServerTypes\n\nAdSlotTypes\n\nAssetRestoreTiers\n\nAssetStatuses\n\nBatchActions\n\nBucketTypes\n\nCloudFrontDistributions\n\nContentAttributes\n\nContentLanguageStatuses\n\nContentTextTypes\n\nContentUnitOfWorkActions\n\nDataFilterFieldOperators\n\nDataIndexTypes\n\nDataJoinFilterFieldClauses\n\nDataPatchTypes\n\nDataSortHeading\n\nEmailTypes\n\nEndPointSystems\n\nFaceMatchTypes\n\nFeaturedContentTypes\n\nImageTypes\n\nIvsChannelTypes\n\nIvsLatencyTypes\n\nJobProcessorActions\n\nLiveRequestActions\n\nLiveRequestTargets\n\nLoginResponseStatuses\n\nMediaConvertTypes\n\nMessageInfoTypes\n\nMetadataTypes\n\nModelContainerModes\n\nDayOfWeek\n\nVideoTrackingActions\n\nFrameIngestActions\n\nArchivePrefixTypes\n\nLiveRecordingStatuses\n\nLiveContentStatuses\n\nLiveScheduleStatuses\n\nContentActionTypes\n\nLiveChannelRealtimeTypes\n\nMediaLiveOutputTypes\n\nTextCaptionTypes\n\nLiveStateUpdateModes\n\nMediaBuilderItemSourceTypes\n\nMediaBuilderStatuses\n\nLocalRestoreProfiles\n\nUserSessionTrackingTypes\n\nShareDurationTypes\n\nTranscoders\n\nBulkIteratorStates\n\nResourceClass\n\nContentVersions\n\nContentFieldClassifications\n\nContentAttributeFlags\n\nContentDataIndexTypes\n\nImportActions\n\nContentMutatorClassifications\n\nShareTypes\n\nSharePermissions\n\nShareStatuses\n\nSearchTextFields\n\nPropertyChangeTypes\n\nUploadReplaceOptions\n\nAdvanceSearchFields\n\nRollupMeasurementSourceTypes\n\nStatMeasurementAggregationOperationTypes\n\nTranscribers\n\nEmbeddingTypes\n\nAssetTransferStatuses\n\nVideoTrackingStatuses\n\nVideoTrackingAlertStatuses\n\nFrameStateFlags\n\nNewsRoomFailureTypes",
            "required": true,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LookupTypes"
                }
              ],
              "x-enumNames": [
                "PageTemplates",
                "Fields",
                "LookupTypes",
                "ContentTemplates",
                "ContentDefinitions",
                "ContentTypes",
                "ContentDefinitionGroups",
                "WorkflowStatuses",
                "DataSelectorContentDefinitions",
                "Content",
                "TemplatePacks",
                "PopularTags",
                "AllTags",
                "PropertyValues",
                "MediaTypes",
                "AssetTypes",
                "ContentFields",
                "FormSelectorContentDefinitions",
                "CustomRenderers",
                "ConstantContactCampaigns",
                "Languages",
                "SecurityGroups",
                "Collections",
                "SecurityPermissions",
                "CustomLabelerTypes",
                "CustomLabelerStatuses",
                "Labels",
                "Users",
                "MeetingSources",
                "LiveScheduleEventStatuses",
                "LiveExternalOutputProfiles",
                "LiveScheduleEventTypes",
                "LiveChannelStatuses",
                "LiveInputCodecs",
                "LiveInputMaximumBitrates",
                "LiveInputResolutions",
                "LiveInputStatuses",
                "LiveInputTypes",
                "NodeTypes",
                "LiveChannelTypes",
                "LiveOutputTypes",
                "Roles",
                "NewsSystems",
                "NprProfileTypes",
                "PaymentStatuses",
                "PingStatuses",
                "PropertyValueTypes",
                "ScheduleItemSearchTypes",
                "ScheduleItemSourceTypes",
                "ScheduleItemTypes",
                "ScheduleStatuses",
                "ScheduleTypes",
                "StorageClasses",
                "SubtitleTypes",
                "SubtitleValueTypes",
                "TextEntityTypes",
                "UploadOverwriteOptions",
                "UserSessionStatuses",
                "VideoSegmentTypes",
                "VideoTrackingEvents",
                "BatchActionProcessorExecutionTypes",
                "VideoTrackingAttributes",
                "TemplatePackTypes",
                "AdServerTypes",
                "AdSlotTypes",
                "AssetRestoreTiers",
                "AssetStatuses",
                "BatchActions",
                "BucketTypes",
                "CloudFrontDistributions",
                "ContentAttributes",
                "ContentLanguageStatuses",
                "ContentTextTypes",
                "ContentUnitOfWorkActions",
                "DataFilterFieldOperators",
                "DataIndexTypes",
                "DataJoinFilterFieldClauses",
                "DataPatchTypes",
                "DataSortHeading",
                "EmailTypes",
                "EndPointSystems",
                "FaceMatchTypes",
                "FeaturedContentTypes",
                "ImageTypes",
                "IvsChannelTypes",
                "IvsLatencyTypes",
                "JobProcessorActions",
                "LiveRequestActions",
                "LiveRequestTargets",
                "LoginResponseStatuses",
                "MediaConvertTypes",
                "MessageInfoTypes",
                "MetadataTypes",
                "ModelContainerModes",
                "DayOfWeek",
                "VideoTrackingActions",
                "FrameIngestActions",
                "ArchivePrefixTypes",
                "LiveRecordingStatuses",
                "LiveContentStatuses",
                "LiveScheduleStatuses",
                "ContentActionTypes",
                "LiveChannelRealtimeTypes",
                "MediaLiveOutputTypes",
                "TextCaptionTypes",
                "LiveStateUpdateModes",
                "MediaBuilderItemSourceTypes",
                "MediaBuilderStatuses",
                "LocalRestoreProfiles",
                "UserSessionTrackingTypes",
                "ShareDurationTypes",
                "Transcoders",
                "BulkIteratorStates",
                "ResourceClass",
                "ContentVersions",
                "ContentFieldClassifications",
                "ContentAttributeFlags",
                "ContentDataIndexTypes",
                "ImportActions",
                "ContentMutatorClassifications",
                "ShareTypes",
                "SharePermissions",
                "ShareStatuses",
                "SearchTextFields",
                "PropertyChangeTypes",
                "UploadReplaceOptions",
                "AdvanceSearchFields",
                "RollupMeasurementSourceTypes",
                "StatMeasurementAggregationOperationTypes",
                "Transcribers",
                "EmbeddingTypes",
                "AssetTransferStatuses",
                "VideoTrackingStatuses",
                "VideoTrackingAlertStatuses",
                "FrameStateFlags",
                "NewsRoomFailureTypes"
              ]
            },
            "x-enumNames": [
              "PageTemplates",
              "Fields",
              "LookupTypes",
              "ContentTemplates",
              "ContentDefinitions",
              "ContentTypes",
              "ContentDefinitionGroups",
              "WorkflowStatuses",
              "DataSelectorContentDefinitions",
              "Content",
              "TemplatePacks",
              "PopularTags",
              "AllTags",
              "PropertyValues",
              "MediaTypes",
              "AssetTypes",
              "ContentFields",
              "FormSelectorContentDefinitions",
              "CustomRenderers",
              "ConstantContactCampaigns",
              "Languages",
              "SecurityGroups",
              "Collections",
              "SecurityPermissions",
              "CustomLabelerTypes",
              "CustomLabelerStatuses",
              "Labels",
              "Users",
              "MeetingSources",
              "LiveScheduleEventStatuses",
              "LiveExternalOutputProfiles",
              "LiveScheduleEventTypes",
              "LiveChannelStatuses",
              "LiveInputCodecs",
              "LiveInputMaximumBitrates",
              "LiveInputResolutions",
              "LiveInputStatuses",
              "LiveInputTypes",
              "NodeTypes",
              "LiveChannelTypes",
              "LiveOutputTypes",
              "Roles",
              "NewsSystems",
              "NprProfileTypes",
              "PaymentStatuses",
              "PingStatuses",
              "PropertyValueTypes",
              "ScheduleItemSearchTypes",
              "ScheduleItemSourceTypes",
              "ScheduleItemTypes",
              "ScheduleStatuses",
              "ScheduleTypes",
              "StorageClasses",
              "SubtitleTypes",
              "SubtitleValueTypes",
              "TextEntityTypes",
              "UploadOverwriteOptions",
              "UserSessionStatuses",
              "VideoSegmentTypes",
              "VideoTrackingEvents",
              "BatchActionProcessorExecutionTypes",
              "VideoTrackingAttributes",
              "TemplatePackTypes",
              "AdServerTypes",
              "AdSlotTypes",
              "AssetRestoreTiers",
              "AssetStatuses",
              "BatchActions",
              "BucketTypes",
              "CloudFrontDistributions",
              "ContentAttributes",
              "ContentLanguageStatuses",
              "ContentTextTypes",
              "ContentUnitOfWorkActions",
              "DataFilterFieldOperators",
              "DataIndexTypes",
              "DataJoinFilterFieldClauses",
              "DataPatchTypes",
              "DataSortHeading",
              "EmailTypes",
              "EndPointSystems",
              "FaceMatchTypes",
              "FeaturedContentTypes",
              "ImageTypes",
              "IvsChannelTypes",
              "IvsLatencyTypes",
              "JobProcessorActions",
              "LiveRequestActions",
              "LiveRequestTargets",
              "LoginResponseStatuses",
              "MediaConvertTypes",
              "MessageInfoTypes",
              "MetadataTypes",
              "ModelContainerModes",
              "DayOfWeek",
              "VideoTrackingActions",
              "FrameIngestActions",
              "ArchivePrefixTypes",
              "LiveRecordingStatuses",
              "LiveContentStatuses",
              "LiveScheduleStatuses",
              "ContentActionTypes",
              "LiveChannelRealtimeTypes",
              "MediaLiveOutputTypes",
              "TextCaptionTypes",
              "LiveStateUpdateModes",
              "MediaBuilderItemSourceTypes",
              "MediaBuilderStatuses",
              "LocalRestoreProfiles",
              "UserSessionTrackingTypes",
              "ShareDurationTypes",
              "Transcoders",
              "BulkIteratorStates",
              "ResourceClass",
              "ContentVersions",
              "ContentFieldClassifications",
              "ContentAttributeFlags",
              "ContentDataIndexTypes",
              "ImportActions",
              "ContentMutatorClassifications",
              "ShareTypes",
              "SharePermissions",
              "ShareStatuses",
              "SearchTextFields",
              "PropertyChangeTypes",
              "UploadReplaceOptions",
              "AdvanceSearchFields",
              "RollupMeasurementSourceTypes",
              "StatMeasurementAggregationOperationTypes",
              "Transcribers",
              "EmbeddingTypes",
              "AssetTransferStatuses",
              "VideoTrackingStatuses",
              "VideoTrackingAlertStatuses",
              "FrameStateFlags",
              "NewsRoomFailureTypes"
            ]
          },
          {
            "name": "lookupKey",
            "in": "query",
            "description": "Optional key to filter lookup results. For AllTags, a boolean string indicating whether to include content definition URLs.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the list of lookup values for the specified type.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LookupModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The lookup service returned null for the specified type and key.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The user is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/mobius-labs/notification/{id}/{callbackType}": {
      "post": {
        "tags": [
          "MobiusLabs"
        ],
        "summary": "Receives a Mobius Labs AI processing webhook callback.",
        "description": "\r\n<b>Behavior:</b> Processes webhook callbacks from Mobius Labs for AI-based feature extraction, video analysis, indexing, and analysis tasks. Routes the callback data as a batch action message for asynchronous processing based on the callback type (feature-extraction, video-analysis, index, or analyze).\r\n\r\n<b>Authorization:</b> No authorization required (Authorize attribute is currently commented out).\r\n\r\n<b>Side Effects:</b> A batch action message is sent to trigger asynchronous processing of the Mobius Labs result.\r\n\r\n<b>Error Scenarios:</b> Throws if the ID, callback type, or model is null or empty. Returns an empty response model and logs an error if the callback type is unknown.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The Mobius Labs task ID or webhook ID (for LLM callbacks).",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "callbackType",
            "in": "path",
            "description": "The callback type (feature-extraction, video-analysis, index, or analyze).",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The Mobius Labs webhook payload containing processing results.",
          "content": {
            "application/json-patch+json": {
              "schema": { }
            },
            "application/json": {
              "schema": { }
            },
            "text/json": {
              "schema": { }
            },
            "application/*+json": {
              "schema": { }
            },
            "application/xml": {
              "schema": { }
            },
            "text/xml": {
              "schema": { }
            },
            "application/*+xml": {
              "schema": { }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook callback was received and processed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MobiusLabsWebhookResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "The ID, callback type, or model was null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/person": {
      "post": {
        "tags": [
          "Person"
        ],
        "summary": "Create a new person entity for facial recognition matching.",
        "description": "\r\n<b>Behavior:</b> Creates a new person with the specified name. The name must be unique —\r\n            duplicate names are not allowed. Optionally accepts lists of matched, unmatched, and blurry face identifiers.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Creates a new person record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or Name is null/empty. Throws if a person with the same name already exists.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Admin.Person.PersonSubmitModel containing the Name and optional face matching lists (MatchedFaces, UnmatchedFaces, BlurryFaces).",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The person was created successfully. Returns the person's ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, Name is null or empty, or a person with this name already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/person/{id}": {
      "get": {
        "tags": [
          "Person"
        ],
        "summary": "Retrieve a person by ID.",
        "description": "\r\n<b>Behavior:</b> Returns the person's details including name, face match counts\r\n            (automatch, probable match, confirmed match, not match), and celebrity detection data.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no person exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the person entity.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PersonModel"
                }
              }
            }
          },
          "404": {
            "description": "No person was found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Person"
        ],
        "summary": "Delete a person by ID.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the person with the specified ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Permanently removes the person record.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the ID is empty.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The person was successfully deleted. Returns the deleted person's ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The ID is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Person"
        ],
        "summary": "Update a person by ID. Note: this endpoint is currently stubbed and returns Guid.Empty.",
        "description": "\r\n<b>Behavior:</b> Currently stubbed — validates input and name but does not perform the update.\r\n            Always returns an IdModel with Guid.Empty. The intended behavior is to update the person's name and face matching lists.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None (stubbed).\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or Name is null/empty.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "A Nomad.Common.Models.Admin.Person.PersonSubmitModel containing the updated Name, MatchedFaces, UnmatchedFaces, and BlurryFaces.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PersonSubmitModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns an IdModel. Note: currently returns Guid.Empty as this endpoint is not fully implemented.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null or Name is null/empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/person/{id}/{personFaceType}": {
      "get": {
        "tags": [
          "Person"
        ],
        "summary": "Retrieve faces associated with a person, filtered by match type. Note: this endpoint is currently stubbed and returns null.",
        "description": "\r\n<b>Behavior:</b> Currently stubbed — always returns null. The intended behavior is to retrieve\r\n            face detection results (bounding boxes, similarity scores, preview images) for a person,\r\n            filtered by the specified face match type.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None (stubbed).\r\n\r\n<b>Error Scenarios:</b> Currently returns null regardless of input.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the person to get faces for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "personFaceType",
            "in": "path",
            "description": "The Nomad.Common.Enums.FaceMatchTypes filter — e.g., Automatch, ProbableMatch, ConfirmedMatch, NotMatch, or Blurry.\n\nAutomatch\n\nProbableMatch\n\nNotMatch\n\nConfirmedMatch\n\nBlurry",
            "required": true,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/FaceMatchTypes"
                }
              ],
              "description": "Categorizes the type of facial recognition match between a detected face and a person.\r\nUsed to filter face results when querying person faces.",
              "x-enumNames": [
                "Automatch",
                "ProbableMatch",
                "NotMatch",
                "ConfirmedMatch",
                "Blurry"
              ]
            },
            "x-enumNames": [
              "Automatch",
              "ProbableMatch",
              "NotMatch",
              "ConfirmedMatch",
              "Blurry"
            ]
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the list of faces. Note: currently returns null as this endpoint is not fully implemented.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PersonFaceModelListResultModel"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/phenix/status": {
      "post": {
        "tags": [
          "Phenix"
        ],
        "summary": "Receives a Phenix RTS status webhook callback.",
        "description": "\r\n<b>Behavior:</b> Processes a status update webhook from the Phenix RTS platform.\r\n            Extracts the Nomad live channel ID from the webhook tags and updates the channel status accordingly.\r\n            The webhook body is read directly from the request stream.\r\n\r\n<b>Authorization:</b> Validated by the `ValidatePhenixWebhookRequestFilter`.\r\n\r\n<b>Side Effects:</b> Updates the live channel status based on the webhook event.",
        "responses": {
          "200": {
            "description": "The webhook was processed successfully."
          }
        }
      }
    },
    "/phenix/refreshToken": {
      "post": {
        "tags": [
          "Phenix"
        ],
        "summary": "Generates a refreshed authentication token for a Phenix live channel.",
        "description": "\r\n<b>Behavior:</b> Generates a new Phenix authentication token for the specified live channel\r\n            and the current authenticated user.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "liveChannelId",
            "in": "query",
            "description": "The live channel identifier to generate a token for.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The token was generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/phenix": {
      "post": {
        "tags": [
          "Phenix"
        ],
        "summary": "Creates a new Phenix channel.",
        "description": "\r\n<b>Behavior:</b> Creates a new external channel on the Phenix RTS platform using\r\n            the provided request model.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates a channel on the Phenix RTS platform.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request model is null or empty.",
        "requestBody": {
          "description": "The Phenix channel creation request model.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixChannelRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a Phenix channel."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixChannelRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a Phenix channel."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixChannelRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a Phenix channel."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixChannelRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a Phenix channel."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixChannelRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a Phenix channel."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixChannelRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a Phenix channel."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixChannelRequestModel"
                  }
                ],
                "description": "Represents the request model for creating a Phenix channel."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The channel was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PhenixChannelEntity"
                }
              }
            }
          },
          "400": {
            "description": "The request model is null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "Phenix"
        ],
        "summary": "Retrieves all Phenix channels.",
        "description": "\r\n<b>Behavior:</b> Returns all Phenix channel entities registered in the system.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The channels were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PhenixChannelEntity"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/phenix/{externalSystemId}": {
      "get": {
        "tags": [
          "Phenix"
        ],
        "summary": "Retrieves a Phenix channel by its external system identifier.",
        "description": "\r\n<b>Behavior:</b> Fetches the Phenix channel entity matching the specified external system ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no channel exists with the specified external ID.",
        "parameters": [
          {
            "name": "externalSystemId",
            "in": "path",
            "description": "The external system identifier of the Phenix channel.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PhenixChannelEntity"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No channel found with the specified external ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Phenix"
        ],
        "summary": "Deletes a Phenix channel.",
        "description": "\r\n<b>Behavior:</b> Deletes the Phenix channel identified by the external system ID from the platform.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Removes the channel from the Phenix RTS platform.",
        "parameters": [
          {
            "name": "externalSystemId",
            "in": "path",
            "description": "The external system identifier of the Phenix channel to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/phenix/{externalSystemId}/stop": {
      "post": {
        "tags": [
          "Phenix"
        ],
        "summary": "Stops a Phenix channel.",
        "description": "\r\n<b>Behavior:</b> Sends a stop command to the Phenix channel identified by the external system ID.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Stops the Phenix channel on the external platform.",
        "parameters": [
          {
            "name": "externalSystemId",
            "in": "path",
            "description": "The external system identifier of the Phenix channel to stop.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The channel was stopped successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/phenix/registerWebhook": {
      "post": {
        "tags": [
          "Phenix"
        ],
        "summary": "Registers a webhook with the Phenix RTS platform.",
        "description": "\r\n<b>Behavior:</b> Registers a webhook URL on the Phenix RTS platform for receiving\r\n            status update callbacks.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Registers a webhook endpoint on the Phenix platform.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the registration model is null or empty.",
        "requestBody": {
          "description": "The webhook registration model containing the URL and configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixWebhookRegistrationModel"
                  }
                ],
                "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixWebhookRegistrationModel"
                  }
                ],
                "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixWebhookRegistrationModel"
                  }
                ],
                "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixWebhookRegistrationModel"
                  }
                ],
                "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixWebhookRegistrationModel"
                  }
                ],
                "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixWebhookRegistrationModel"
                  }
                ],
                "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PhenixWebhookRegistrationModel"
                  }
                ],
                "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The webhook was registered successfully."
          },
          "400": {
            "description": "The registration model is null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/ping": {
      "get": {
        "tags": [
          "Ping"
        ],
        "summary": "Health check endpoint that returns \"Pong\" to confirm the API is running.",
        "description": "\r\n<b>Behavior:</b> Returns the string \"Pong\" as a simple health check response.\r\n            If includeHeaders is true, returns a formatted string listing all HTTP request headers and their values instead,\r\n            which is useful for debugging proxy and load balancer configurations.\r\n\r\n<b>Authorization:</b> Public endpoint — no authentication required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> None — this endpoint always succeeds.",
        "parameters": [
          {
            "name": "includeHeaders",
            "in": "query",
            "description": "When true, returns all HTTP request headers instead of \"Pong\". Useful for debugging. Default is false.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns \"Pong\" or the request header listing.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/ping/auth": {
      "get": {
        "tags": [
          "Ping"
        ],
        "summary": "Authenticated health check endpoint that validates the Bearer token is still valid.",
        "description": "\r\n<b>Behavior:</b> Returns the string \"Pong Auth\". Use this endpoint to verify that a Bearer token\r\n            is still valid. If the token is invalid or expired, the request will be rejected with 401.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token ([Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the Bearer token is missing, invalid, or expired.",
        "responses": {
          "200": {
            "description": "The Bearer token is valid. Returns \"Pong Auth\".",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "401": {
            "description": "The Bearer token is missing, invalid, or expired."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/red5/authenticate": {
      "post": {
        "tags": [
          "Red5"
        ],
        "summary": "Authenticates a Red5 Pro streaming connection.",
        "description": "\r\n<b>Behavior:</b> Validates the authentication credentials for a Red5 Pro streaming request by verifying the stream ID and password against the configured channels.\r\n\r\n<b>Authorization:</b> No authorization required. Validated by webhook filter.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns a response with Result set to false if the authentication credentials are invalid.",
        "requestBody": {
          "description": "The Red5 authentication request containing stream ID and credentials.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Authentication result returned successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Red5AuthResponseModel"
                }
              }
            }
          }
        }
      }
    },
    "/red5/validateCredentials": {
      "post": {
        "tags": [
          "Red5"
        ],
        "summary": "Validates Red5 Pro streaming credentials.",
        "description": "\r\n<b>Behavior:</b> Performs credential validation for a Red5 Pro streaming request, verifying the stream ID and password with an explicit credential validation flag.\r\n\r\n<b>Authorization:</b> No authorization required. Validated by webhook filter.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns a response with Result set to false if the credentials are invalid.",
        "requestBody": {
          "description": "The Red5 credential validation request containing stream ID and credentials.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5AuthRequestModel"
                  }
                ],
                "description": "Represents the authentication request from the Red5 streaming platform."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Credential validation result returned successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Red5AuthResponseModel"
                }
              }
            }
          }
        }
      }
    },
    "/red5/status": {
      "post": {
        "tags": [
          "Red5"
        ],
        "summary": "Receives a Red5 Pro channel status update webhook.",
        "description": "\r\n<b>Behavior:</b> Processes Published and UnPublished status events from Red5 Pro by updating the corresponding channel status in the system.\r\n\r\n<b>Authorization:</b> No authorization required. Validated by webhook filter.\r\n\r\n<b>Side Effects:</b> The channel status is updated in the system when the event is Published or UnPublished.\r\n\r\n<b>Error Scenarios:</b> Logs a warning if the channel status update fails. Non-Published/UnPublished events are ignored.",
        "requestBody": {
          "description": "The Red5 status request containing the channel name and event type.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5StatusRequestModel"
                  }
                ],
                "description": "Represents a status update webhook request from the Red5 streaming platform."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5StatusRequestModel"
                  }
                ],
                "description": "Represents a status update webhook request from the Red5 streaming platform."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5StatusRequestModel"
                  }
                ],
                "description": "Represents a status update webhook request from the Red5 streaming platform."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5StatusRequestModel"
                  }
                ],
                "description": "Represents a status update webhook request from the Red5 streaming platform."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5StatusRequestModel"
                  }
                ],
                "description": "Represents a status update webhook request from the Red5 streaming platform."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5StatusRequestModel"
                  }
                ],
                "description": "Represents a status update webhook request from the Red5 streaming platform."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/Red5StatusRequestModel"
                  }
                ],
                "description": "Represents a status update webhook request from the Red5 streaming platform."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Status update was received and processed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Red5StatusResponseModel"
                }
              }
            }
          }
        }
      }
    },
    "/admin/related": {
      "post": {
        "tags": [
          "Related"
        ],
        "summary": "Creates new related content associations between content items.",
        "description": "\r\n<b>Behavior:</b> Creates related content associations for each item in the provided list. This establishes bidirectional or unidirectional relationships between content items depending on the model configuration.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates metadata records linking content items as related to each other.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty. Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of related content associations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The related content associations were successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The items list is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/related/delete": {
      "post": {
        "tags": [
          "Related"
        ],
        "summary": "Deletes related content associations between content items.",
        "description": "\r\n<b>Behavior:</b> Removes the related content associations for each item in the provided list. This removes the relationships between content items but does not delete the content items themselves.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Removes metadata records linking content items as related to each other.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty. Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of related content associations to delete.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RelatedContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The related content associations were successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The items list is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/s3/webhook": {
      "post": {
        "tags": [
          "S3"
        ],
        "summary": "Receives and processes S3 event notifications via webhook.",
        "description": "\r\n<b>Behavior:</b> Accepts an S3 event notification payload, validates the event against the external bucket configuration, and processes the event to update the corresponding asset. If the model is null, an error is logged and 200 is returned. If the event is not valid, a 400 response is returned.\r\n\r\n<b>Authorization:</b> No authorization is required. This endpoint is designed to receive external S3 event notifications.\r\n\r\n<b>Side Effects:</b> Processes the S3 event which may create, update, or modify asset records based on the event type (e.g., object created, deleted).\r\n\r\n<b>Error Scenarios:</b> Returns 200 with no processing if the model is null. Returns 400 if the S3 event fails validation against the external bucket configuration.",
        "requestBody": {
          "description": "The raw S3 event notification payload.",
          "content": {
            "application/json-patch+json": {
              "schema": { }
            },
            "application/json": {
              "schema": { }
            },
            "text/json": {
              "schema": { }
            },
            "application/*+json": {
              "schema": { }
            },
            "application/xml": {
              "schema": { }
            },
            "text/xml": {
              "schema": { }
            },
            "application/*+xml": {
              "schema": { }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The S3 event was processed successfully or the model was null (logged as error)."
          },
          "400": {
            "description": "The S3 event failed validation against the external bucket configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/admin/schedule/{scheduleId}": {
      "get": {
        "tags": [
          "Schedule"
        ],
        "summary": "Retrieves a specific schedule by its identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the schedule model for the specified identifier.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no schedule exists with the specified ID. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No schedule found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Schedule"
        ],
        "summary": "Updates an existing schedule.",
        "description": "\r\n<b>Behavior:</b> Updates the schedule with the specified ID using the provided request data and returns the updated schedule model.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule record is updated in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The schedule update request containing the new name and properties.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Schedule"
        ],
        "summary": "Deletes a specific schedule.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the schedule with the specified ID and returns the deleted identifier.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule and its associated items are permanently removed from the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/preview": {
      "get": {
        "tags": [
          "Schedule"
        ],
        "summary": "Retrieves a preview of the schedule guide for a specific schedule.",
        "description": "\r\n<b>Behavior:</b> Returns a list of schedule guide items that represent the preview of what the schedule will look like when published.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to preview.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule preview was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ScheduleGuideModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/item/{itemId}": {
      "get": {
        "tags": [
          "Schedule"
        ],
        "summary": "Retrieves a specific schedule item by its identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the schedule item model for the specified item identifier.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no schedule item exists with the specified ID. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "itemId",
            "in": "path",
            "description": "The ID of the schedule item to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule item was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleItemModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No schedule item found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Schedule"
        ],
        "summary": "Updates an existing schedule item.",
        "description": "\r\n<b>Behavior:</b> Updates the schedule item with the specified ID using the provided request data and returns the updated schedule item model.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule item record is updated in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The parent schedule ID.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "itemId",
            "in": "path",
            "description": "The ID of the schedule item to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The schedule item update request.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule item was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleItemModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Schedule"
        ],
        "summary": "Deletes a specific schedule item.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the schedule item with the specified ID and returns a change model reflecting the deletion and any cascading changes to the schedule.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule item is permanently removed and the schedule's item ordering may be updated.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The parent schedule ID.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "itemId",
            "in": "path",
            "description": "The ID of the schedule item to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule item was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleItemChangeModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/items": {
      "get": {
        "tags": [
          "Schedule"
        ],
        "summary": "Retrieves all schedule items for a specific schedule.",
        "description": "\r\n<b>Behavior:</b> Returns all schedule items belonging to the specified schedule, queried by the schedule's key.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule whose items to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule items were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ScheduleItemModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule": {
      "post": {
        "tags": [
          "Schedule"
        ],
        "summary": "Creates a new schedule.",
        "description": "\r\n<b>Behavior:</b> Creates a new schedule with the specified name and returns the created schedule model.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new schedule record is persisted.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body or schedule name is null or empty. Returns 401 if the caller is not authenticated.",
        "requestBody": {
          "description": "The schedule creation request containing the name and optional ID.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleModel"
                  }
                ],
                "description": "Represents a request to create a new schedule with its initial configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body or schedule name was null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/item": {
      "post": {
        "tags": [
          "Schedule"
        ],
        "summary": "Creates a new schedule item within a schedule.",
        "description": "\r\n<b>Behavior:</b> Creates a new schedule item and associates it with the specified schedule. Returns a change model reflecting the created item and any cascading changes.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> A new schedule item record is persisted and the schedule's item ordering may be updated.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body or schedule ID is null or empty. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to add the item to.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The schedule item creation request.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AddScheduleItemModel"
                  }
                ],
                "description": "Represents a request to add a new item to a schedule."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule item was created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleItemChangeModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body or schedule ID was null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/item/{itemId}/move": {
      "post": {
        "tags": [
          "Schedule"
        ],
        "summary": "Moves a schedule item to a new position within the schedule.",
        "description": "\r\n<b>Behavior:</b> Repositions the specified schedule item according to the move request and returns the updated list of all schedule items reflecting the new ordering.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule item ordering is updated in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The parent schedule ID.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "itemId",
            "in": "path",
            "description": "The ID of the schedule item to move.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The move request specifying the new position.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScheduleItemMoveModel"
                  }
                ],
                "description": "Represents a request to move a schedule item to a new position in the schedule order."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScheduleItemMoveModel"
                  }
                ],
                "description": "Represents a request to move a schedule item to a new position in the schedule order."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScheduleItemMoveModel"
                  }
                ],
                "description": "Represents a request to move a schedule item to a new position in the schedule order."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScheduleItemMoveModel"
                  }
                ],
                "description": "Represents a request to move a schedule item to a new position in the schedule order."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScheduleItemMoveModel"
                  }
                ],
                "description": "Represents a request to move a schedule item to a new position in the schedule order."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScheduleItemMoveModel"
                  }
                ],
                "description": "Represents a request to move a schedule item to a new position in the schedule order."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ScheduleItemMoveModel"
                  }
                ],
                "description": "Represents a request to move a schedule item to a new position in the schedule order."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule item was moved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ScheduleItemModel"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/start": {
      "post": {
        "tags": [
          "Schedule"
        ],
        "summary": "Starts a schedule for live playback.",
        "description": "\r\n<b>Behavior:</b> Transitions the schedule to a Starting state and initiates channel playback. When background mode is enabled (default), a batch action message is queued for asynchronous processing. When background mode is disabled, the channel is started synchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule status is updated to Starting and a batch action message may be sent. The associated live channel begins playback.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the schedule is not found or is already in a Running, Starting, or Stopping state. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to start.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "background",
            "in": "query",
            "description": "Whether to run the operation asynchronously in the background. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule start was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleModel"
                }
              }
            }
          },
          "400": {
            "description": "The schedule was not found or is already running.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/stop": {
      "post": {
        "tags": [
          "Schedule"
        ],
        "summary": "Stops a running schedule.",
        "description": "\r\n<b>Behavior:</b> Transitions the schedule to a Stopping state and halts channel playback. When background mode is enabled (default), a batch action message is queued for asynchronous processing. When background mode is disabled, the channel is stopped synchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule status is updated to Stopping and a batch action message may be sent. The associated live channel stops playback.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the schedule is not found or is already in a Stopped state. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to stop.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "background",
            "in": "query",
            "description": "Whether to run the operation asynchronously in the background. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The schedule stop was initiated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleModel"
                }
              }
            }
          },
          "400": {
            "description": "The schedule was not found or is already stopped.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/publish": {
      "post": {
        "tags": [
          "Schedule"
        ],
        "summary": "Publishes an intelligent schedule.",
        "description": "\r\n<b>Behavior:</b> Publishes the intelligent schedule, optionally locking it for a specified number of days. When background mode is enabled (default), a batch action message is queued for asynchronous processing. When background mode is disabled, the schedule is published synchronously.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The schedule is published and its expiration date may be set. A batch action message may be sent for asynchronous processing.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request body is null. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the intelligent schedule to publish.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "background",
            "in": "query",
            "description": "Whether to run the operation asynchronously in the background. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "description": "The publish request containing the number of locked days.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PublishScheduleRequestModel"
                  }
                ],
                "description": "Represents a request to publish a schedule, locking it for a specified number of days."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PublishScheduleRequestModel"
                  }
                ],
                "description": "Represents a request to publish a schedule, locking it for a specified number of days."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PublishScheduleRequestModel"
                  }
                ],
                "description": "Represents a request to publish a schedule, locking it for a specified number of days."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PublishScheduleRequestModel"
                  }
                ],
                "description": "Represents a request to publish a schedule, locking it for a specified number of days."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PublishScheduleRequestModel"
                  }
                ],
                "description": "Represents a request to publish a schedule, locking it for a specified number of days."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PublishScheduleRequestModel"
                  }
                ],
                "description": "Represents a request to publish a schedule, locking it for a specified number of days."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PublishScheduleRequestModel"
                  }
                ],
                "description": "Represents a request to publish a schedule, locking it for a specified number of days."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule was published successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ScheduleModel"
                }
              }
            }
          },
          "400": {
            "description": "The request body was null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/schedule/{scheduleId}/items/import": {
      "post": {
        "tags": [
          "Schedule"
        ],
        "summary": "Bulk imports schedule items into a schedule.",
        "description": "\r\n<b>Behavior:</b> Creates multiple schedule items from the provided import models and associates them with the specified schedule.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Multiple schedule item records are persisted in the data store.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input list is null. Returns 401 if the caller is not authenticated.",
        "parameters": [
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The ID of the schedule to import items into.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The list of schedule items to import.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportScheduleItemModel"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportScheduleItemModel"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportScheduleItemModel"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportScheduleItemModel"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportScheduleItemModel"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportScheduleItemModel"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImportScheduleItemModel"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The schedule items were imported successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ScheduleItemModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The input list was null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/search/mappingFieldNames": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Retrieves all search index field names available for mapping and filtering.",
        "description": "\r\n<b>Behavior:</b> Returns the complete list of field names defined in the search index schema.\r\n            These field names can be used to configure search filters, sort fields, and returned field lists.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The field names were retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/search": {
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Executes a search query against the search index.",
        "description": "\r\n<b>Behavior:</b> Accepts a full search model with filters, sort fields, pagination, and query text.\r\n            Returns a paginated list of matching search results. Use the SearchModel to control which fields are\r\n            returned, how results are sorted, and which filters to apply.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the search model is null or contains invalid filter criteria.",
        "parameters": [
          {
            "name": "includeInternalFieldsInResults",
            "in": "query",
            "description": "When true, includes internal system fields in the search result output. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "The search query model containing filters, sort fields, pagination, and query text.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The search completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The search model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Executes a search query using query string parameters for simple search scenarios.",
        "description": "\r\n<b>Behavior:</b> Provides a GET-based search interface where common search parameters can be passed\r\n            as query strings. Query string values override any corresponding values in the optional request body SearchModel.\r\n            Filters are extracted from additional query string parameters beyond the named ones.\r\n            Sort order accepts \"descending\", \"desc\", or \"1\" for descending sort.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "description": "The number of results to return per page. Overrides the value in the body model.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pageOffset",
            "in": "query",
            "description": "The pagination offset for the result set. Overrides the value in the body model.",
            "schema": { }
          },
          {
            "name": "searchQuery",
            "in": "query",
            "description": "The free-text search query. Overrides the value in the body model.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortField",
            "in": "query",
            "description": "The field name to sort results by.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortOrder",
            "in": "query",
            "description": "The sort direction: ascending (default) or descending.\n\n0 = Ascending\n\n1 = Descending",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchSortTypes"
                }
              ]
            },
            "x-enumNames": [
              "Ascending",
              "Descending"
            ]
          },
          {
            "name": "includeInternalFieldsInResults",
            "in": "query",
            "description": "When true, includes internal system fields in the search result output. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "Optional SearchModel in the request body for advanced search configuration.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The search completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModelListResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The search parameters are invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/search/export": {
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Exports search results as an Excel spreadsheet or queues the export for background processing.",
        "description": "\r\n<b>Behavior:</b> Executes the search query and exports matching results as an XLSX file.\r\n            If no sort fields are provided, results are sorted by masterId by default.\r\n            When the background flag is set, the export is queued as a batch action\r\n            and the caller receives a 204 response immediately; the exported file is delivered via email when ready.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> When running in background mode, creates a batch job for asynchronous processing.\r\n\r\n<b>Error Scenarios:</b> Returns 204 if no records match the search criteria.\r\n            Returns 400 if the search model is null or invalid.",
        "parameters": [
          {
            "name": "background",
            "in": "query",
            "description": "When true, queues the export for background processing and returns immediately. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "The search query model defining which results to export.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SearchModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The export file was generated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "204": {
            "description": "No matching records found, or background export was queued."
          },
          "400": {
            "description": "The search model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/search/rebuild-index/{type}": {
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Rebuilds the search index using the specified rebuild strategy.",
        "description": "\r\n<b>Behavior:</b> Triggers a full or partial rebuild of the search index depending on the type parameter.\r\n            Supported types: `$ALL$` (rebuild from all sources), `$ALL_CLEAR$` (clear index then rebuild),\r\n            `$MONGO$` (rebuild from MongoDB source only), `$DYNAMO$` (rebuild from DynamoDB source only).\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Triggers a potentially long-running reindex operation.\r\n            During a $ALL_CLEAR$ rebuild, search results may be temporarily unavailable.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the type parameter is null.",
        "parameters": [
          {
            "name": "type",
            "in": "path",
            "description": "The rebuild strategy: `$ALL$`, `$ALL_CLEAR$`, `$MONGO$`, or `$DYNAMO$`.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The reindex operation completed successfully."
          },
          "400": {
            "description": "The type parameter is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/search/{id}": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Retrieves a single indexed document by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Fetches a specific document from the search index by ID.\r\n            Returns the full search result representation of the document including all indexed fields.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no document with the given ID exists in the index.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the indexed document to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "includeInternalFieldsInResults",
            "in": "query",
            "description": "When true, includes internal system fields in the result. Defaults to false.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The document was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No document found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/security/{id}/update": {
      "post": {
        "tags": [
          "Security"
        ],
        "summary": "Updates the security configuration for a content item.",
        "description": "\r\n<b>Behavior:</b> Replaces the security settings for the content item identified by ID.\r\n            Security settings control which groups and users have access to the content.\r\n            The inherit security flag determines whether the item inherits permissions from its parent.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates security group and user assignments for the content item.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the security model is null.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the content item to update security for.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The security configuration containing groups, users, and inheritance settings.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SecurityModel"
                  }
                ],
                "description": "Represents the security configuration for a content item including group and user access."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SecurityModel"
                  }
                ],
                "description": "Represents the security configuration for a content item including group and user access."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SecurityModel"
                  }
                ],
                "description": "Represents the security configuration for a content item including group and user access."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SecurityModel"
                  }
                ],
                "description": "Represents the security configuration for a content item including group and user access."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SecurityModel"
                  }
                ],
                "description": "Represents the security configuration for a content item including group and user access."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SecurityModel"
                  }
                ],
                "description": "Represents the security configuration for a content item including group and user access."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SecurityModel"
                  }
                ],
                "description": "Represents the security configuration for a content item including group and user access."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The security settings were updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The security model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/security/user": {
      "get": {
        "tags": [
          "Security"
        ],
        "summary": "Retrieves all users registered in the identity provider.",
        "description": "\r\n<b>Behavior:</b> Returns the full list of users from the identity provider (Cognito).\r\n            To retrieve all users including those not in the identity provider, use the Search API instead.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.",
        "responses": {
          "200": {
            "description": "The user list was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdminUserModelListResultModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "post": {
        "tags": [
          "Security"
        ],
        "summary": "Creates or updates a user account.",
        "description": "\r\n<b>Behavior:</b> Saves the user profile. If the user does not exist, a new account is created.\r\n            If the user already exists, the profile is updated with the provided values.\r\n            Returns the saved user profile.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Creates or updates a user account in the identity provider and system.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the user model is null.\r\n            Returns 404 if the save operation fails.",
        "requestBody": {
          "description": "The admin user model to create or update.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user was saved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdminUserModel"
                }
              }
            }
          },
          "400": {
            "description": "The user model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The save operation did not return a valid user.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/security/user/{id}": {
      "get": {
        "tags": [
          "Security"
        ],
        "summary": "Retrieves a user by their unique identifier.",
        "description": "\r\n<b>Behavior:</b> Returns the full admin user profile for the specified ID,\r\n            including security groups, system roles, and folder assignments.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no user exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the user to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdminUserModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No user found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Security"
        ],
        "summary": "Deletes a user by their unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently removes the user account identified by ID\r\n            from both the identity provider and the system.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes the user account. This operation cannot be undone.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the user to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user was deleted successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Security"
        ],
        "summary": "Updates an existing user account by ID.",
        "description": "\r\n<b>Behavior:</b> Fully replaces the user profile for the specified ID with the provided model.\r\n            The ID in the route is used for REST convention; the user identity is determined from the model body.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Updates the user account in the identity provider and system.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the user model is null.\r\n            Returns 404 if the save operation fails.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the user to update.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The admin user model with updated values.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AdminUserModel"
                  }
                ],
                "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user was updated successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdminUserModel"
                }
              }
            }
          },
          "400": {
            "description": "The user model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The save operation did not return a valid user.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/security/user/by-email/{email}": {
      "get": {
        "tags": [
          "Security"
        ],
        "summary": "Retrieves a user by their email address.",
        "description": "\r\n<b>Behavior:</b> Looks up a user by email address and returns the full admin user profile.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the email is null or empty.\r\n            Returns 404 if no user exists with the specified email.",
        "parameters": [
          {
            "name": "email",
            "in": "path",
            "description": "The email address to look up.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user was retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AdminUserModel"
                }
              }
            }
          },
          "400": {
            "description": "The email is null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No user found with the specified email address.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/create-db-tables": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Creates the required database tables for the application.",
        "description": "\r\n<b>Behavior:</b> Ensures all required database tables exist by creating any that are missing. This is an idempotent operation and can be safely called multiple times.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates database tables that do not already exist. Existing tables are not modified.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the database setup fails due to connectivity or permission issues.",
        "responses": {
          "200": {
            "description": "Database tables were successfully created or already exist."
          },
          "400": {
            "description": "An error occurred during the database setup process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/create-contentdefinitions-file": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Generates the built-in content definitions JSON file.",
        "description": "\r\n<b>Behavior:</b> Generates a JSON representation of the built-in content definitions and returns it as a string. This can be used to bootstrap or inspect the default content definition configuration.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> May write the generated content definitions file to storage depending on the implementation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the content definitions cannot be generated.",
        "responses": {
          "200": {
            "description": "Content definitions JSON was successfully generated.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "An error occurred while generating content definitions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/create-default-savedsearches": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Creates the default saved searches for the environment.",
        "description": "\r\n<b>Behavior:</b> Ensures that all default saved searches exist in the system. This is an idempotent operation; existing saved searches are not duplicated or modified.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates default saved search records in the database if they do not already exist.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the saved search creation fails.",
        "responses": {
          "200": {
            "description": "Default saved searches were successfully created or already exist."
          },
          "400": {
            "description": "An error occurred while creating default saved searches.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/create-default-liveoutputprofilegroups": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Creates the default live output profile groups for the environment.",
        "description": "\r\n<b>Behavior:</b> Ensures that all default live output profile groups exist in the system. This is an idempotent operation; existing profile groups are not duplicated or modified.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates default live output profile group records if they do not already exist.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the profile group creation fails.",
        "responses": {
          "200": {
            "description": "Default live output profile groups were successfully created or already exist."
          },
          "400": {
            "description": "An error occurred while creating default live output profile groups.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/upgrade-2023-12": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Triggers the December 2023 upgrade batch process.",
        "description": "\r\n<b>Behavior:</b> Sends a batch action message to initiate the December 2023 upgrade process. The upgrade runs asynchronously via the batch processing system.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Queues an upgrade batch action message for asynchronous processing. This may modify data schemas and records as part of the upgrade.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the batch message cannot be sent.",
        "responses": {
          "200": {
            "description": "The upgrade batch action was successfully queued."
          },
          "400": {
            "description": "An error occurred while queuing the upgrade batch action.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/upgrade-2024-02": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Triggers the February 2024 full update upgrade batch process.",
        "description": "\r\n<b>Behavior:</b> Sends a batch action message to initiate the February 2024 FullUpdate upgrade process. Supports a preview-only mode that simulates the upgrade without making changes.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> When previewOnly is false, queues an upgrade batch action that modifies data records. When previewOnly is true, only simulates the upgrade.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the batch message cannot be sent.",
        "parameters": [
          {
            "name": "previewOnly",
            "in": "query",
            "description": "When true, the upgrade is simulated without making changes. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upgrade batch action was successfully queued."
          },
          "400": {
            "description": "An error occurred while queuing the upgrade batch action.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/upgrade-2024-08": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Triggers the August 2024 share migration upgrade batch process.",
        "description": "\r\n<b>Behavior:</b> Sends a batch action message to initiate the August 2024 MigrateShares upgrade process including asset re-indexing. Supports a preview-only mode that simulates the upgrade without making changes.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> When previewOnly is false, queues an upgrade batch action that migrates shares and re-indexes assets. When previewOnly is true, only simulates the upgrade.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the batch message cannot be sent.",
        "parameters": [
          {
            "name": "previewOnly",
            "in": "query",
            "description": "When true, the upgrade is simulated without making changes. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The upgrade batch action was successfully queued."
          },
          "400": {
            "description": "An error occurred while queuing the upgrade batch action.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/setup/upgrade-2024-12": {
      "post": {
        "tags": [
          "Setup"
        ],
        "summary": "Triggers the December 2024 security permissions migration and live output profile groups migration upgrade batch process.",
        "description": "\r\n<b>Behavior:</b> Sends two batch action messages: one to migrate security permissions with asset re-indexing, and another to migrate live output profile groups to S3. Both support a preview-only mode that simulates the upgrade without making changes.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> When previewOnly is false, queues two upgrade batch actions that migrate security permissions, re-index assets, and migrate live output profile groups to S3. When previewOnly is true, only simulates the upgrades.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if either batch message cannot be sent.",
        "parameters": [
          {
            "name": "previewOnly",
            "in": "query",
            "description": "When true, the upgrade is simulated without making changes. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Both upgrade batch actions were successfully queued."
          },
          "400": {
            "description": "An error occurred while queuing the upgrade batch actions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/all": {
      "get": {
        "tags": [
          "Statistics"
        ],
        "summary": "Retrieves all statistics records.",
        "description": "\r\n<b>Behavior:</b> Returns a complete list of all statistics records in the system without any date filtering.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the statistics retrieval fails.",
        "responses": {
          "200": {
            "description": "Statistics records retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StatisticsListModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "An error occurred while retrieving statistics.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/date-range": {
      "get": {
        "tags": [
          "Statistics"
        ],
        "summary": "Retrieves statistics records within a specified date range.",
        "description": "\r\n<b>Behavior:</b> Returns statistics records filtered by the specified date range (inclusive of fromDate and toDate).\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the date range is invalid or the statistics retrieval fails.",
        "parameters": [
          {
            "name": "fromDate",
            "in": "query",
            "description": "The start date of the range to query statistics for.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "toDate",
            "in": "query",
            "description": "The end date of the range to query statistics for.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Statistics records for the date range retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StatisticsListModel"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The date range is invalid or an error occurred while retrieving statistics.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/measurements/config": {
      "get": {
        "tags": [
          "Statistics"
        ],
        "summary": "Gets statistics measurement config data.",
        "description": "\r\n<b>Behavior:</b> Retrieves the configuration for available statistics measurements including measurement types, available periods, and display options.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the configuration retrieval fails.",
        "responses": {
          "200": {
            "description": "Statistics measurement configuration retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StatisticsConfigResultModel"
                }
              }
            }
          },
          "400": {
            "description": "An error occurred while retrieving the measurement configuration.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/measurements": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Lists statistics measurement data from search indexes over the specified period.",
        "description": "\r\n<b>Behavior:</b> Queries the search indexes for measurement data matching the specified period and measurement types in the request model, and returns the results as graph-ready data.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request model is invalid or the measurement retrieval fails.",
        "requestBody": {
          "description": "A model containing period and measurements to retrieve.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StatisticsRequestModel"
                  }
                ],
                "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Statistics measurements retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StatisiticsDataGraph"
                  }
                }
              }
            }
          },
          "400": {
            "description": "The request model is invalid or an error occurred while retrieving measurements.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/measurements/rollup": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Restores measurement statistics by loading available rollup snapshot data from S3 into the search index.",
        "description": "\r\n<b>Behavior:</b> Reads rollup snapshot files from S3 and loads the measurement data into the search index. This is used to restore or rebuild measurement statistics from previously generated snapshots.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Modifies the search index by loading measurement data from S3 rollup snapshots. Existing measurement data in the index may be overwritten.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the rollup snapshot restoration fails or no snapshots are available.",
        "responses": {
          "200": {
            "description": "Rollup snapshots were successfully restored into the search index."
          },
          "400": {
            "description": "An error occurred while restoring rollup snapshots.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "put": {
        "tags": [
          "Statistics"
        ],
        "summary": "Generates rollup snapshot data for the specified date and stores it in S3.",
        "description": "\r\n<b>Behavior:</b> Generates rollup measurement snapshots for the specified date (or the current date if not provided) and stores them in S3. These snapshots can later be restored using the POST measurements/rollup endpoint.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates or overwrites rollup snapshot files in S3 for the specified date.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the snapshot generation fails.",
        "parameters": [
          {
            "name": "snapshotDate",
            "in": "query",
            "description": "The date of rollups snapshot to generate. If null, defaults to the current date.",
            "schema": {
              "type": "string",
              "format": "date"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Rollup snapshots were successfully generated."
          },
          "400": {
            "description": "An error occurred while generating rollup snapshots.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/exportjournal": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Exports statistics journal entries for the specified date range as an Excel file.",
        "description": "\r\n<b>Behavior:</b> Exports journal entries for the specified date range. When background is true (default), the export is queued as a batch action for asynchronous processing. When background is false, the export runs synchronously and returns the Excel file directly. If no data is available, returns 204 No Content.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> When background is true, queues a batch export job. When background is false, generates an Excel file in memory.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the export date is invalid or the export process fails. Returns 204 if no journal data exists for the specified date range.",
        "parameters": [
          {
            "name": "exportDate",
            "in": "query",
            "description": "The start date for the journal export.",
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "exportEndDate",
            "in": "query",
            "description": "The optional end date for the journal export. If null, only the export date is used.",
            "schema": {
              "type": "string",
              "format": "date"
            }
          },
          {
            "name": "background",
            "in": "query",
            "description": "When true, the export runs as a background batch job. When false, the export runs synchronously and returns the file. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The journal export was completed and the file is returned (synchronous mode only)."
          },
          "204": {
            "description": "The export was queued as a background job or no data exists for the specified date range."
          },
          "400": {
            "description": "The export date is invalid or an error occurred during the export.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/statistics/generate-statistics": {
      "post": {
        "tags": [
          "Statistics"
        ],
        "summary": "Generates the system statistics for the environment.",
        "description": "\r\n<b>Behavior:</b> Triggers generation of system-level statistics. When forceReload is true, statistics are regenerated even if they already exist for the current period.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute. Additionally, the user must be an admin (checked via IsAdminUser).\r\n\r\n<b>Side Effects:</b> Generates and persists system statistics records. When forceReload is true, existing statistics may be overwritten.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the user is not an admin or the statistics generation fails. Throws a VibrantException if the user lacks admin permissions.",
        "parameters": [
          {
            "name": "forceReload",
            "in": "query",
            "description": "When true, forces statistics to regenerate even if they already exist for the current period.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Statistics were successfully generated.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "The user lacks admin permissions or statistics generation failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/stripe/webhook": {
      "post": {
        "tags": [
          "Stripe"
        ],
        "summary": "Receives and processes a Stripe payment webhook.",
        "description": "\r\n<b>Behavior:</b> Processes incoming Stripe webhook payloads by forwarding the raw input string to the payment unit of work for processing.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> The payment webhook payload is processed, which may update payment or subscription state.\r\n\r\n<b>Error Scenarios:</b> Throws if the input string is null or empty. Returns 401 Unauthorized if the caller is not authenticated.",
        "requestBody": {
          "description": "The raw Stripe webhook payload as a string.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "string"
              }
            },
            "application/json": {
              "schema": {
                "type": "string"
              }
            },
            "text/json": {
              "schema": {
                "type": "string"
              }
            },
            "application/*+json": {
              "schema": {
                "type": "string"
              }
            },
            "application/xml": {
              "schema": {
                "type": "string"
              }
            },
            "text/xml": {
              "schema": {
                "type": "string"
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "string"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook was processed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "The input payload was null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/system/invalidate-cache": {
      "post": {
        "tags": [
          "System"
        ],
        "summary": "Invalidates the CDN distribution cache for the specified paths.",
        "description": "\r\n<b>Behavior:</b> Sends an invalidation request to the CDN distribution for the paths specified in the input model. This forces the CDN to fetch fresh content from the origin on subsequent requests.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Triggers a CDN cache invalidation which may temporarily increase origin load.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid.",
        "requestBody": {
          "description": "The InvalidateDistrubutionModel input containing the distribution paths to invalidate.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InvalidateDistributionModel"
                  }
                ],
                "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InvalidateDistributionModel"
                  }
                ],
                "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InvalidateDistributionModel"
                  }
                ],
                "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InvalidateDistributionModel"
                  }
                ],
                "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InvalidateDistributionModel"
                  }
                ],
                "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InvalidateDistributionModel"
                  }
                ],
                "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InvalidateDistributionModel"
                  }
                ],
                "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Cache invalidation completed successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "The input model is null or invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/system/rebuild-share/{shareId}": {
      "post": {
        "tags": [
          "System"
        ],
        "summary": "Rebuilds the search index records for shares.",
        "description": "\r\n<b>Behavior:</b> Rebuilds the search index for a specific share (if shareId is provided) or all shares. Expired shares can be optionally excluded from the rebuild.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Modifies search index records for the affected shares. May be a long-running operation when rebuilding all shares.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if an error occurs during the rebuild process.",
        "parameters": [
          {
            "name": "shareId",
            "in": "path",
            "description": "Optional ShareId. If missing, all shares are rebuilt.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "excludeExpiredShares",
            "in": "query",
            "description": "Whether to exclude expired shares from the rebuild. Defaults to true.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Share index records rebuilt successfully."
          },
          "400": {
            "description": "An error occurred during the rebuild process.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/system/email-dispatcher": {
      "post": {
        "tags": [
          "System"
        ],
        "summary": "Dispatches an email using the provided email configuration.",
        "description": "\r\n<b>Behavior:</b> Processes and sends an email based on the provided EmailDispatcherModel configuration. Only admin users are permitted to dispatch emails.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the [Authorize] attribute. Additionally, the user must be an admin (checked via IsAdminUser).\r\n\r\n<b>Side Effects:</b> Sends an email to the recipients specified in the input model.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null or invalid. Throws a VibrantException if the current user is not an admin.",
        "requestBody": {
          "description": "The EmailDispatcherModel input containing email configuration such as recipients, subject, and body.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EmailDispatcherModel"
                  }
                ],
                "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EmailDispatcherModel"
                  }
                ],
                "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EmailDispatcherModel"
                  }
                ],
                "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EmailDispatcherModel"
                  }
                ],
                "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EmailDispatcherModel"
                  }
                ],
                "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EmailDispatcherModel"
                  }
                ],
                "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EmailDispatcherModel"
                  }
                ],
                "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Email dispatched successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          },
          "400": {
            "description": "The input model is null or the user lacks admin permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/system/license-test": {
      "post": {
        "tags": [
          "System"
        ],
        "summary": "Tests the current license by performing a license check against the license server.",
        "description": "\r\n<b>Behavior:</b> Validates the current license by querying the license server. When forceReload is true, the cached license is bypassed and a fresh query is made to the license server.\r\n\r\n<b>Authorization:</b> No authorization attribute is applied to this endpoint.\r\n\r\n<b>Side Effects:</b> When forceReload is true, refreshes the cached license data from the license server.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the license check fails or the license server is unreachable.",
        "parameters": [
          {
            "name": "forceReload",
            "in": "query",
            "description": "When true, forces the license check to requery the license server instead of using cached data.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "License check completed successfully and the license grant is returned.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LicenseGrant"
                }
              }
            }
          },
          "400": {
            "description": "The license check failed or the license server could not be reached.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/admin/system/migrate-assets": {
      "post": {
        "tags": [
          "System"
        ],
        "summary": "Triggers a batch migration of assets from one storage platform to another.",
        "description": "\r\n<b>Behavior:</b> Initiates a batch action to migrate assets between storage platforms using the provided bucket replacement mappings. The platform setup must be completed before calling this endpoint. This endpoint only triggers the migration; the actual processing occurs asynchronously.\r\n\r\n<b>Authorization:</b> No [Authorize] attribute, but the user must be an admin (checked via IsAdminUser).\r\n\r\n<b>Side Effects:</b> Queues a batch migration job that moves assets between storage buckets. This is a long-running asynchronous operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if replaceBuckets is null or empty, or if the user is not an admin. Throws a VibrantException for permission or validation failures.",
        "requestBody": {
          "description": "A list of key-value pairs mapping source bucket names to destination bucket names.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/StringStringKeyValuePair"
                }
              }
            },
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/StringStringKeyValuePair"
                }
              }
            },
            "text/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/StringStringKeyValuePair"
                }
              }
            },
            "application/*+json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/StringStringKeyValuePair"
                }
              }
            },
            "application/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/StringStringKeyValuePair"
                }
              }
            },
            "text/xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/StringStringKeyValuePair"
                }
              }
            },
            "application/*+xml": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/StringStringKeyValuePair"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The migration batch job was successfully initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The user lacks admin permissions or replaceBuckets is null or empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/admin/system/align-catalog": {
      "post": {
        "tags": [
          "System"
        ],
        "summary": "Aligns the asset catalog by triggering a batch catalog alignment process.",
        "description": "\r\n<b>Behavior:</b> Initiates a batch action to align the asset catalog based on the provided alignment model. If no model is provided, default alignment settings are used. The actual alignment processing occurs asynchronously.\r\n\r\n<b>Authorization:</b> No [Authorize] attribute, but the user must be an admin (checked via IsAdminUser).\r\n\r\n<b>Side Effects:</b> Queues a batch catalog alignment job that processes and reconciles catalog entries asynchronously.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the user is not an admin. Throws a VibrantException for permission failures.",
        "requestBody": {
          "description": "The AlignCatalogModel containing alignment configuration options. If null, default settings are used.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AlignCatalogModel"
                  }
                ],
                "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AlignCatalogModel"
                  }
                ],
                "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AlignCatalogModel"
                  }
                ],
                "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AlignCatalogModel"
                  }
                ],
                "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AlignCatalogModel"
                  }
                ],
                "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AlignCatalogModel"
                  }
                ],
                "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AlignCatalogModel"
                  }
                ],
                "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The catalog alignment batch job was successfully initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The user lacks admin permissions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tag/{id}": {
      "get": {
        "tags": [
          "Tag"
        ],
        "summary": "Gets a specific tag by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Retrieves a single tag record matching the specified ID. Returns the full tag model if found.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> None. This is a read-only operation.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is malformed. Returns 404 if no tag exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the tag to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tag was found and returned successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TagModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is malformed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "No tag exists with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      },
      "delete": {
        "tags": [
          "Tag"
        ],
        "summary": "Deletes a specific tag by its unique identifier.",
        "description": "\r\n<b>Behavior:</b> Permanently deletes the tag with the specified ID and returns the ID of the deleted tag.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Permanently removes the tag record from the database. Content items previously associated with this tag will lose that association.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the deletion fails or the tag ID is invalid.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier of the tag to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tag was successfully deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The deletion failed or the tag ID is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/tag/content/delete": {
      "post": {
        "tags": [
          "Tag"
        ],
        "summary": "Removes tag associations from the specified content items.",
        "description": "\r\n<b>Behavior:</b> Removes the tag-to-content associations for each content item in the provided list. Note that this does NOT delete the tags themselves, only the associations between tags and content items.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Removes metadata associations between content items and tags. The tags and content items themselves remain intact.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty. Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of tag-content associations to remove, containing the record and tag identifiers.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The tag-content associations were successfully removed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The items list is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/tag": {
      "post": {
        "tags": [
          "Tag"
        ],
        "summary": "Creates a new tag or updates an existing one.",
        "description": "\r\n<b>Behavior:</b> Creates a new tag or updates an existing tag based on the input model. The underlying implementation uses a create-or-update pattern. This design intentionally avoids the need for a separate PUT operation.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates a new tag record in the database or updates an existing one.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the tag name is null.",
        "requestBody": {
          "description": "The tag model containing the name and optional configuration for the tag.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagModel"
                  }
                ],
                "description": "Represents a tag with its identifier and display name."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagModel"
                  }
                ],
                "description": "Represents a tag with its identifier and display name."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagModel"
                  }
                ],
                "description": "Represents a tag with its identifier and display name."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagModel"
                  }
                ],
                "description": "Represents a tag with its identifier and display name."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagModel"
                  }
                ],
                "description": "Represents a tag with its identifier and display name."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagModel"
                  }
                ],
                "description": "Represents a tag with its identifier and display name."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagModel"
                  }
                ],
                "description": "Represents a tag with its identifier and display name."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The tag was successfully created or updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IdModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the tag name is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/tag/content": {
      "post": {
        "tags": [
          "Tag"
        ],
        "summary": "Adds tag associations to the specified content items.",
        "description": "\r\n<b>Behavior:</b> Creates tag-to-content associations for each content item in the provided list. If a referenced tag does not exist, the createNew flag in the model determines whether the tag should be automatically created.\r\n\r\n<b>Authorization:</b> Requires an authenticated user via the class-level [Authorize] attribute.\r\n\r\n<b>Side Effects:</b> Creates metadata associations between content items and tags. May also create new tag records if the createNew flag is set.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input is null or the items list is empty. Returns 404 if the items list is null.",
        "requestBody": {
          "description": "The list of tag-content associations to create.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TagContentModelListModel"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The tag-content associations were successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchResultModel"
                }
              }
            }
          },
          "400": {
            "description": "The input is null or the items list is empty.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "404": {
            "description": "The items list is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized. The caller must provide a valid Bearer token."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/theolive/webhook": {
      "post": {
        "tags": [
          "Theolive"
        ],
        "summary": "Receives and processes Theolive event webhooks.",
        "description": "\r\n<b>Behavior:</b> Processes incoming Theolive webhook events by updating the corresponding channel status. Returns immediately with an \"ok\" response as Theolive terminates requests that take longer than 3 seconds. Exceptions are caught and logged without propagation.\r\n\r\n<b>Authorization:</b> No authorization required. Validated by webhook filter.\r\n\r\n<b>Side Effects:</b> The channel status is updated based on the webhook event type.\r\n\r\n<b>Error Scenarios:</b> Logs a warning if channel status update fails. Logs and swallows any exceptions during processing to ensure a timely 200 response.",
        "requestBody": {
          "description": "The Theolive webhook request containing the event type, channel ID, and event details.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TheoliveWebhookRequestModel"
                  }
                ],
                "description": "Represents a webhook event request from the THEOlive platform."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TheoliveWebhookRequestModel"
                  }
                ],
                "description": "Represents a webhook event request from the THEOlive platform."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TheoliveWebhookRequestModel"
                  }
                ],
                "description": "Represents a webhook event request from the THEOlive platform."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TheoliveWebhookRequestModel"
                  }
                ],
                "description": "Represents a webhook event request from the THEOlive platform."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TheoliveWebhookRequestModel"
                  }
                ],
                "description": "Represents a webhook event request from the THEOlive platform."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TheoliveWebhookRequestModel"
                  }
                ],
                "description": "Represents a webhook event request from the THEOlive platform."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TheoliveWebhookRequestModel"
                  }
                ],
                "description": "Represents a webhook event request from the THEOlive platform."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook was received and acknowledged."
          }
        }
      }
    },
    "/theolive/webhook/health": {
      "get": {
        "tags": [
          "Theolive"
        ],
        "summary": "Returns the health status of the Theolive webhook endpoint.",
        "description": "\r\n<b>Behavior:</b> Returns a simple health check response indicating that the Theolive webhook service is operational.\r\n\r\n<b>Authorization:</b> No authorization required.\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> None expected.",
        "responses": {
          "200": {
            "description": "The Theolive webhook service is healthy."
          }
        }
      }
    },
    "/twelve-labs/notification": {
      "post": {
        "tags": [
          "TwelveLabs"
        ],
        "summary": "Receives a Twelve Labs video understanding webhook callback.",
        "description": "\r\n<b>Behavior:</b> Processes webhook callbacks from the Twelve Labs API by deserializing the payload to extract the task ID and status, then sending a batch action message for asynchronous processing. The request is validated by the ValidateTwelveLabsWebhookRequestFilter.\r\n\r\n<b>Authorization:</b> No authorization required. Validated by webhook filter.\r\n\r\n<b>Side Effects:</b> A batch action message is sent to trigger asynchronous processing of the Twelve Labs task result.\r\n\r\n<b>Error Scenarios:</b> Returns 200 OK even on errors to acknowledge receipt. Errors are logged but swallowed to prevent webhook retry storms.",
        "requestBody": {
          "description": "The webhook payload as a JSON object returned by the Twelve Labs API.",
          "content": {
            "application/json-patch+json": {
              "schema": { }
            },
            "application/json": {
              "schema": { }
            },
            "text/json": {
              "schema": { }
            },
            "application/*+json": {
              "schema": { }
            },
            "application/xml": {
              "schema": { }
            },
            "text/xml": {
              "schema": { }
            },
            "application/*+xml": {
              "schema": { }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Webhook callback was received and acknowledged."
          }
        }
      }
    },
    "/admin/user/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Permanently deletes a user account and all associated data.",
        "description": "\r\n<b>Behavior:</b> Removes the user account and all related data from the system.\r\n            This is a destructive operation that cannot be undone.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes the user and all associated records.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "The unique identifier of the user to delete.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user was deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/userData/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes a user's data without removing the user account itself.",
        "description": "\r\n<b>Behavior:</b> Removes all user-generated data (video tracking, content attributes, saved searches,\r\n            content groups, favorites, likes, etc.) while preserving the user account.\r\n            If no user ID is provided, operates on the current user's data.\r\n            Only administrators can execute this operation; non-admin requests are silently skipped.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token with administrator privileges.\r\n\r\n<b>Side Effects:</b> Permanently deletes all user data records.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's data.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user data was deleted successfully, or the operation was skipped for non-admin callers."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/userVideoTracking/delete": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Deletes video tracking data for a user, asset, content item, or combination thereof.",
        "description": "\r\n<b>Behavior:</b> Removes video tracking records based on the provided filter criteria.\r\n            Supports filtering by user ID, asset ID, and/or content ID, which can be combined:\r\n            user ID deletes all tracking for that user, asset ID deletes all tracking for that asset,\r\n            content ID deletes all tracking for that content item.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes matching video tracking records.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null.",
        "requestBody": {
          "description": "The filter criteria specifying which video tracking records to delete.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserVideoTrackingModel"
                  }
                ],
                "description": "Represents video playback tracking data for a user's viewing progress."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserVideoTrackingModel"
                  }
                ],
                "description": "Represents video playback tracking data for a user's viewing progress."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserVideoTrackingModel"
                  }
                ],
                "description": "Represents video playback tracking data for a user's viewing progress."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserVideoTrackingModel"
                  }
                ],
                "description": "Represents video playback tracking data for a user's viewing progress."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserVideoTrackingModel"
                  }
                ],
                "description": "Represents video playback tracking data for a user's viewing progress."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserVideoTrackingModel"
                  }
                ],
                "description": "Represents video playback tracking data for a user's viewing progress."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserVideoTrackingModel"
                  }
                ],
                "description": "Represents video playback tracking data for a user's viewing progress."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The video tracking data was deleted successfully."
          },
          "400": {
            "description": "The input model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/userContentSecurity/delete": {
      "post": {
        "tags": [
          "User"
        ],
        "summary": "Deletes user content security records for a user, content item, content definition, or combination thereof.",
        "description": "\r\n<b>Behavior:</b> Removes content security records based on the provided filter criteria.\r\n            Supports filtering by user ID, content ID, content definition ID, and content security attribute,\r\n            which can be combined to target specific records.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes matching user content security records.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the input model is null.",
        "requestBody": {
          "description": "The filter criteria specifying which content security records to delete.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentSecurityModel"
                  }
                ],
                "description": "Model for managing per-user content security access records."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentSecurityModel"
                  }
                ],
                "description": "Model for managing per-user content security access records."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentSecurityModel"
                  }
                ],
                "description": "Model for managing per-user content security access records."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentSecurityModel"
                  }
                ],
                "description": "Model for managing per-user content security access records."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentSecurityModel"
                  }
                ],
                "description": "Model for managing per-user content security access records."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentSecurityModel"
                  }
                ],
                "description": "Model for managing per-user content security access records."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UserContentSecurityModel"
                  }
                ],
                "description": "Model for managing per-user content security access records."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The user content security data was deleted successfully."
          },
          "400": {
            "description": "The input model is null.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/savedSearch/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all saved searches for a user.",
        "description": "\r\n<b>Behavior:</b> Removes all saved search records belonging to the specified user.\r\n            If no user ID is provided, operates on the current user's saved searches.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all saved search records for the user.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's saved searches.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The saved searches were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/userSession/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all user session data for a user.",
        "description": "\r\n<b>Behavior:</b> Removes all session records belonging to the specified user.\r\n            If no user ID is provided, operates on the current user's sessions.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all user session records. Active sessions will be invalidated.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's sessions.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user sessions were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/contentGroup/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all content groups owned by a user.",
        "description": "\r\n<b>Behavior:</b> Removes all content groups created by the specified user.\r\n            If no user ID is provided, operates on the current user's content groups.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all content groups owned by the user, including their content associations and sharing records.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's content groups.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The content groups were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/userContentAttribute/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all content attributes (favorites, bookmarks, likes) for a user.",
        "description": "\r\n<b>Behavior:</b> Removes all user content attribute records for the specified user.\r\n            If no user ID is provided, operates on the current user's attributes.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all user content attribute records.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's content attributes.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The content attributes were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/favorite/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all favorite records for a user.",
        "description": "\r\n<b>Behavior:</b> Removes all content items marked as favorites by the specified user.\r\n            If no user ID is provided, operates on the current user's favorites.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all favorite records for the user.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's favorites.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The favorites were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/like/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all like records for a user.",
        "description": "\r\n<b>Behavior:</b> Removes all content items marked as liked by the specified user.\r\n            If no user ID is provided, operates on the current user's likes.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all like records for the user.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's likes.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The likes were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/dislike/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all dislike records for a user.",
        "description": "\r\n<b>Behavior:</b> Removes all content items marked as disliked by the specified user.\r\n            If no user ID is provided, operates on the current user's dislikes.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all dislike records for the user.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's dislikes.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The dislikes were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user/shares/{userId}": {
      "delete": {
        "tags": [
          "User"
        ],
        "summary": "Deletes all share records for a user.",
        "description": "\r\n<b>Behavior:</b> Removes all content sharing records for the specified user.\r\n            If no user ID is provided, operates on the current user's shares.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token.\r\n\r\n<b>Side Effects:</b> Permanently deletes all share records for the user.",
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "description": "Optional user ID. If null, targets the current user's shares.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The shares were deleted successfully."
          },
          "401": {
            "description": "Caller is not authenticated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user-session/{id}": {
      "get": {
        "tags": [
          "UserSession"
        ],
        "summary": "Retrieve a single user session by its ID.",
        "description": "\r\n<b>Behavior:</b> Returns the details of a specific user session including user information,\r\n            session metadata (browser type, IP address, start and last activity dates), and current status.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> None.\r\n\r\n<b>Error Scenarios:</b> Returns 404 if no session exists with the specified ID.",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The unique identifier (Guid) of the user session to retrieve.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the user session details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserSessionModel"
                }
              }
            }
          },
          "404": {
            "description": "No session was found with the specified ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    },
    "/admin/user-session": {
      "post": {
        "tags": [
          "UserSession"
        ],
        "summary": "Change the status of a user session (e.g., kick a user or restrict chat access).",
        "description": "\r\n<b>Behavior:</b> Updates the status of the specified user session to a new value such as Kicked,\r\n            ChatRestricted, or Expired. This is commonly used to kick a user off the system or restrict their\r\n            chat privileges. The affected user will see the status change on their next session ping.\r\n\r\n<b>Authorization:</b> Requires a valid Bearer token (class-level [Authorize]).\r\n\r\n<b>Side Effects:</b> Changes the session status. The affected user will see the status change on their next ping.\r\n\r\n<b>Error Scenarios:</b> Returns 400 if the request is null or Id/UserSessionStatus are missing.",
        "requestBody": {
          "description": "A Nomad.Common.Models.Admin.UserSession.ChangeSessionStatusModel containing the session Id (required), UserSessionStatus to set (required), and optional ApplicationId.",
          "content": {
            "application/json-patch+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeSessionStatusModel"
                  }
                ],
                "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
              }
            },
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeSessionStatusModel"
                  }
                ],
                "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeSessionStatusModel"
                  }
                ],
                "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeSessionStatusModel"
                  }
                ],
                "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
              }
            },
            "application/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeSessionStatusModel"
                  }
                ],
                "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
              }
            },
            "text/xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeSessionStatusModel"
                  }
                ],
                "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
              }
            },
            "application/*+xml": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ChangeSessionStatusModel"
                  }
                ],
                "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The session status was successfully changed. Returns the updated session.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserSessionModel"
                }
              }
            }
          },
          "400": {
            "description": "The request is null, Id is missing, or UserSessionStatus is invalid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "The caller is not authenticated."
          }
        },
        "security": [
          {
            "Bearer": [ ]
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "AccountLoginResponseModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the authenticated user.",
            "format": "uuid"
          },
          "userName": {
            "type": "string",
            "description": "Gets or sets the username (email address) of the authenticated user.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the authenticated user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the authenticated user.",
            "nullable": true
          },
          "loginStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LoginResponseStatuses"
              }
            ],
            "description": "Gets or sets the login status indicating the result of the authentication attempt.\r\nA null value typically indicates success. Non-null values indicate a specific condition\r\n(e.g., IsDisabled, RequiresNewPassword, IsPendingEmailConfirmation).\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
            "nullable": true
          },
          "cookies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LoginCookieModel"
            },
            "description": "Gets or sets the list of cookies to be set on the client after a successful login.",
            "nullable": true
          },
          "token": {
            "type": "string",
            "description": "Gets or sets the JWT access token. Include this in the Authorization header of all API requests, prefixed with \"Bearer \".",
            "nullable": true
          },
          "refreshToken": {
            "type": "string",
            "description": "Gets or sets the refresh token. Use this to obtain a new access token when the current one expires.",
            "nullable": true
          },
          "expirationSeconds": {
            "type": "number",
            "description": "Gets or sets the duration in seconds until the access token expires.",
            "format": "double"
          },
          "scopeId": {
            "type": "string",
            "description": "Gets or sets the scope identifier, if applicable.",
            "format": "uuid",
            "nullable": true
          },
          "scopeName": {
            "type": "string",
            "description": "Gets or sets the scope name, if applicable.",
            "nullable": true
          },
          "twoFactorQRCodeImage": {
            "type": "string",
            "description": "Gets or sets the base64-encoded QR code image for two-factor authentication setup, if required.",
            "nullable": true
          },
          "twoFactorQRCode": {
            "type": "string",
            "description": "Gets or sets the two-factor authentication secret code for manual entry, if required.",
            "nullable": true
          },
          "claims": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Claim"
            },
            "description": "Gets or sets the list of claims associated with the authenticated user's token.",
            "nullable": true
          },
          "isAdmin": {
            "type": "boolean",
            "description": "Gets or sets whether the user has system administrator privileges.",
            "nullable": true
          },
          "isGuest": {
            "type": "boolean",
            "description": "Gets or sets whether the user is a guest user with limited access.",
            "nullable": true
          },
          "userSessionId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the session created by this login. Use this for session ping and logout.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AdBreakModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the ID of the ad break",
            "format": "uuid"
          },
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the timecode of the ad break in the format of hh:mm:ss:ff",
            "nullable": true
          },
          "score": {
            "type": "number",
            "description": "Gets or sets the calculated score of the ad break from the AI analysis. The higher the better.",
            "format": "double",
            "nullable": true
          },
          "adBreakType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AdSlotTypes"
              }
            ],
            "description": "Gets or sets the type of the ad break (pre-roll, post-roll, mid-roll)\n\nPreroll\n\nMidroll\n\nPostroll",
            "x-enumNames": [
              "Preroll",
              "Midroll",
              "Postroll"
            ]
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags that are targeted with this ad break",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of labels that are targeted with this ad break",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an ad break marker within a media asset, defining the insertion point, type, and targeting criteria."
      },
      "AdBreakSubmitModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the ID of the ad break",
            "format": "uuid",
            "nullable": true
          },
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the timecode of the ad break in the format of hh:mm:ss:ff",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags that are targeted with this ad break",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of labels that are targeted with this ad break",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to create or update an ad break marker within a media asset."
      },
      "AdSlotTypes": {
        "enum": [
          "Preroll",
          "Midroll",
          "Postroll"
        ],
        "type": "string",
        "description": "\n\nPreroll\n\nMidroll\n\nPostroll",
        "x-enumNames": [
          "Preroll",
          "Midroll",
          "Postroll"
        ]
      },
      "AddAnnotationModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the annotation; if null, a new identifier will be generated.",
            "format": "uuid",
            "nullable": true
          },
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation begins.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation ends.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of custom properties associated with the annotation.",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the content identifier used internally for processing.",
            "format": "uuid"
          },
          "imageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the image associated with the annotation, used internally for processing.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to add a new annotation to a media asset, defining a time range and associated properties."
      },
      "AddDownloadQueueModel": {
        "type": "object",
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of asset identifiers to add to the download queue.",
            "nullable": true
          },
          "downloadProxy": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to download the lower-resolution proxy version of the assets."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to add one or more assets to the download queue for asynchronous processing."
      },
      "AddScheduleItemModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the optional identifier for the new schedule item. If not provided, one will be generated.",
            "format": "uuid",
            "nullable": true
          },
          "previousItem": {
            "type": "string",
            "description": "Gets or sets the identifier of the preceding item to determine insertion position.",
            "format": "uuid",
            "nullable": true
          },
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the start time code for the new schedule item.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the new schedule item.",
            "nullable": true
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the asset reference to associate with this schedule item.",
            "nullable": true
          },
          "scheduleItemType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleItemTypes"
              }
            ],
            "description": "Gets or sets the type of the schedule item.\n\nAsset\n\nDynamic",
            "x-enumNames": [
              "Asset",
              "Dynamic"
            ]
          },
          "scheduleId": {
            "type": "string",
            "description": "Gets or sets the identifier of the parent schedule this item will be added to.",
            "format": "uuid"
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the end time code for the new schedule item.",
            "nullable": true
          },
          "days": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of days on which this schedule item should be active.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the tags to associate with this schedule item.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the related content items to link to this schedule item.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collections to assign this schedule item to.",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the labels to assign to this schedule item.",
            "nullable": true
          },
          "playlistSchedule": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the playlist schedule reference for this item.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference for this schedule item.",
            "nullable": true
          },
          "defaultVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the default video asset reference used as a fallback.",
            "nullable": true
          },
          "thumbnailAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the thumbnail asset reference for this schedule item.",
            "nullable": true
          },
          "searchFilterType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleItemSearchTypes"
              }
            ],
            "description": "Gets or sets the search filter type used to select content for this item.\n\nRandom\n\nRandomWithinDateRange\n\nNewest\n\nNewestNotPlayed",
            "nullable": true
          },
          "sourceType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleItemSourceTypes"
              }
            ],
            "description": "Gets or sets the source type indicating where the schedule item content originates.\n\nPlaylistSchedule\n\nSearchFilters\n\nVideoAsset\n\nLiveChannel",
            "nullable": true
          },
          "searchDurationInMinutes": {
            "type": "integer",
            "description": "Gets or sets the search duration in minutes for filtering content by time window.",
            "format": "int32",
            "nullable": true
          },
          "endSearchDurationInMinutes": {
            "type": "integer",
            "description": "Gets or sets the end search duration in minutes for the content time window.",
            "format": "int32",
            "nullable": true
          },
          "searchDate": {
            "type": "string",
            "description": "Gets or sets the start date for search-based content filtering.",
            "format": "date-time",
            "nullable": true
          },
          "endSearchDate": {
            "type": "string",
            "description": "Gets or sets the end date for search-based content filtering.",
            "format": "date-time",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties for the new schedule item.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to add a new item to a schedule."
      },
      "AddScheduleModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the optional identifier for the new schedule. If not provided, one will be generated.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the new schedule.",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "description": "Gets or sets the URL-friendly route name for the new schedule.",
            "nullable": true
          },
          "thumbnailAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the thumbnail asset reference for the new schedule.",
            "nullable": true
          },
          "scheduleType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleTypes"
              }
            ],
            "description": "Gets or sets the type of schedule to create.\n\nPlaylist\n\nIntelligentSchedule\n\nIntelligentPlaylist",
            "x-enumNames": [
              "Playlist",
              "IntelligentSchedule",
              "IntelligentPlaylist"
            ]
          },
          "timeZoneId": {
            "type": "string",
            "description": "Gets or sets the identifier of the time zone for the new schedule.",
            "format": "uuid",
            "nullable": true
          },
          "defaultVideoAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the default video asset reference used when no scheduled content is available.",
            "nullable": true
          },
          "loopPlaylist": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the playlist should loop when it reaches the end.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties for the new schedule.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to create a new schedule with its initial configuration."
      },
      "AdminUserModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user.",
            "format": "uuid"
          },
          "email": {
            "type": "string",
            "description": "Gets or sets the email address of the user.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user.",
            "nullable": true
          },
          "isAdmin": {
            "type": "boolean",
            "description": "Gets or sets whether the user has system administrator privileges.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties of the user. Any unrecognized JSON properties are captured here.",
            "nullable": true,
            "readOnly": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the status of the user",
            "nullable": true
          },
          "loginStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LoginResponseStatuses"
              }
            ],
            "description": "Gets or sets the login status of the user from the identity provider.\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
            "nullable": true
          },
          "assignedSecurityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the security groups that this user is part of",
            "nullable": true
          },
          "assignedSystemRoles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the system roles that this user is part of",
            "nullable": true
          },
          "personalFolder": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the personal folder Asset ID for this user",
            "nullable": true
          },
          "homeFolder": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the home folder Asset ID for this user",
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "description": "Gets or sets the date and time the user was last modified.",
            "format": "date-time"
          },
          "createdDate": {
            "type": "string",
            "description": "Gets or sets the date and time the user account was created.",
            "format": "date-time"
          },
          "lastModifiedUserName": {
            "type": "string",
            "description": "Gets or sets the username of the person who last modified this user.",
            "nullable": true
          },
          "lastModifiedUserId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the person who last modified this user.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an administrative user account with security group assignments, system roles, and folder configuration."
      },
      "AdminUserModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdminUserModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdminUserModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "AlignCatalogModel": {
        "type": "object",
        "properties": {
          "stage": {
            "type": "integer",
            "description": "Gets or sets the current processing stage of the alignment operation.",
            "format": "int32",
            "nullable": true
          },
          "bucket": {
            "type": "string",
            "description": "Gets or sets the S3 bucket name to align.",
            "nullable": true
          },
          "runInSingleThread": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the alignment should run in a single thread rather than in parallel."
          },
          "overrideExistingJobs": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether existing processing jobs should be overridden during alignment."
          },
          "continuationToken": {
            "type": "string",
            "description": "Gets or sets the S3 continuation token for paginated listing of objects.",
            "nullable": true
          },
          "fileCounter": {
            "type": "integer",
            "description": "Gets or sets the current file counter for tracking progress through the alignment.",
            "format": "int32",
            "nullable": true
          },
          "fixFolderStatuses": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether folder statuses should be corrected during alignment.",
            "nullable": true
          },
          "realignFolders": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether folders should be realigned with the catalog.",
            "nullable": true
          },
          "realignFiles": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether files should be realigned with the catalog.",
            "nullable": true
          },
          "reprocessAssets": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether assets should be reprocessed during alignment.",
            "nullable": true
          },
          "previewOrphanDynamoAssets": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether orphan DynamoDB assets should be previewed without removal.",
            "nullable": true
          },
          "removeOrphanDynamoAssets": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether orphan DynamoDB assets should be removed.",
            "nullable": true
          },
          "bulkDeleteAssets": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether assets should be bulk deleted during alignment.",
            "nullable": true
          },
          "undeleteMissingFiles": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether missing files should be undeleted in the catalog.",
            "nullable": true
          },
          "deleteFullyMissingDynamoAssets": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether DynamoDB assets with no corresponding S3 objects should be deleted.",
            "nullable": true
          },
          "objectKeyPrefixes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of S3 object key prefixes to filter the alignment scope.",
            "nullable": true
          },
          "extensions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of file extensions to filter during alignment.",
            "nullable": true
          },
          "assetTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetTypes"
            },
            "description": "Gets or sets the list of asset types to include in the alignment.",
            "nullable": true
          },
          "assetStatuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetStatuses"
            },
            "description": "Gets or sets the list of asset statuses to include in the alignment.",
            "nullable": true
          },
          "mediaTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaTypes"
            },
            "description": "Gets or sets the list of media types to include in the alignment.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents configuration parameters for a catalog alignment operation that reconciles assets between S3 storage and the DynamoDB catalog."
      },
      "AnnotationModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the annotation.",
            "format": "uuid"
          },
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation begins.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the annotation ends.",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the image associated with the annotation.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of custom properties associated with the annotation.",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the content identifier used internally for processing.",
            "format": "uuid"
          }
        },
        "additionalProperties": false,
        "description": "Represents an annotation on a media asset, including its time range, image reference, and custom properties."
      },
      "AssetDetailModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the asset.",
            "format": "uuid"
          },
          "permission": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityPermissions"
              }
            ],
            "description": "Gets or sets the permission level the current user has for this asset.\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
            "nullable": true
          },
          "isRestricted": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether access to this asset is restricted.",
            "nullable": true
          },
          "isShared": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether this asset has been shared with others.",
            "nullable": true
          },
          "inheritSecurity": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether this asset inherits security settings from its parent."
          },
          "relatedAudio": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of related audio assets associated with this asset.",
            "nullable": true
          },
          "relatedAssets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of general related assets associated with this asset.",
            "nullable": true
          },
          "relatedVideos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of related video assets associated with this asset.",
            "nullable": true
          },
          "relatedImages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of related image assets associated with this asset.",
            "nullable": true
          },
          "relatedContentGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content groups associated with this asset.",
            "nullable": true
          },
          "screenshots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of screenshot references captured from this asset.",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LabelModel"
            },
            "description": "Gets or sets the list of labels applied to this asset for categorization.",
            "nullable": true
          },
          "faceItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FaceModel"
            },
            "description": "Gets or sets the list of detected faces within this asset.",
            "nullable": true
          },
          "persons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PersonReferenceModel"
            },
            "description": "Gets or sets the list of identified persons associated with this asset.",
            "nullable": true
          },
          "textItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextItemGroupModel"
            },
            "description": "Gets or sets the list of detected text item groups within this asset.",
            "nullable": true
          },
          "availability": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AvailabilityModel"
            },
            "description": "Gets or sets the list of availability windows that define when this asset is accessible.",
            "nullable": true
          },
          "geoData": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GeoData"
              }
            ],
            "description": "Gets or sets the geographic location data associated with this asset.",
            "nullable": true
          },
          "parents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetModel"
            },
            "description": "Gets or sets the list of parent folder assets that contain this asset.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of collections this asset belongs to.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags assigned to this asset.",
            "nullable": true
          },
          "shares": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of shares this asset is included in.",
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of security groups that have access to this asset.",
            "nullable": true
          },
          "securityUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of individual users that have access to this asset.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content items linked to this asset.",
            "nullable": true
          },
          "assetStats": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetStatsModel"
              }
            ],
            "description": "Gets or sets the usage and engagement statistics for this asset.",
            "nullable": true
          },
          "textCaptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextCaptionModel"
            },
            "description": "Gets or sets the list of text captions or subtitles associated with this asset.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of system-level properties for this asset.",
            "nullable": true
          },
          "customAttributes": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the dictionary of user-defined custom attributes for this asset.",
            "nullable": true
          },
          "attributeSummary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserContentAttributeSummaryModel"
              }
            ],
            "description": "Gets or sets the summary of content attribute definitions available for this asset.",
            "nullable": true
          },
          "highlights": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VideoHighlightModel"
            },
            "description": "Gets or sets the list of video highlights or bookmarked moments within this asset.",
            "nullable": true
          },
          "chapters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VideoHighlightModel"
            },
            "description": "Gets or sets the list of chapters defining segments within this asset.",
            "nullable": true
          },
          "adBreaks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdBreakModel"
            },
            "description": "Gets or sets the list of ad break markers within this asset.",
            "nullable": true
          },
          "audioTracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AudioTrackModel"
            },
            "description": "Gets or sets the list of audio tracks available for this asset.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the full detail view of an asset, including metadata, relationships, security settings, and associated content."
      },
      "AssetDownloadModel": {
        "type": "object",
        "properties": {
          "assetIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of asset identifiers to include in the download.",
            "nullable": true
          },
          "filename": {
            "type": "string",
            "description": "Gets or sets the desired filename for the download output.",
            "nullable": true
          },
          "downloadProxy": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to download the lower-resolution proxy version of the assets."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to download one or more assets, optionally packaged into a single file."
      },
      "AssetModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the asset.",
            "format": "uuid"
          },
          "parentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the parent folder that contains this asset.",
            "format": "uuid",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "Gets or sets the user-friendly display name of the asset.",
            "nullable": true
          },
          "displayDate": {
            "type": "string",
            "description": "Gets or sets the display date associated with the asset.",
            "format": "date-time",
            "nullable": true
          },
          "bucketName": {
            "type": "string",
            "description": "Gets or sets the name of the storage bucket where the asset resides.",
            "nullable": true
          },
          "objectKey": {
            "type": "string",
            "description": "Gets or sets the storage object key that identifies the asset within its bucket.",
            "nullable": true
          },
          "fullUrl": {
            "type": "string",
            "description": "Gets or sets the fully qualified URL for accessing the asset.",
            "nullable": true
          },
          "assetStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetStatuses"
              }
            ],
            "description": "Gets or sets the current processing or lifecycle status of the asset.\n\nAvailable\n\nRenaming\n\nCopying\n\nRestoring\n\nRegistering\n\nUploading\n\nArchiving\n\nArchived\n\nPendingArchive\n\nPendingRestore\n\nRestored\n\nDeleting\n\nMoving\n\nSlugReplaced\n\nUpdating\n\nError\n\nAssembling\n\nClipping\n\nPlaceholder\n\nCreating\n\nReplacing",
            "nullable": true
          },
          "storageClass": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StorageClasses"
              }
            ],
            "description": "Gets or sets the storage class tier for the asset.\n\nStandard\n\nReducedRedundancy\n\nGlacier\n\nStandardInfrequentAccess\n\nOneZoneInfrequentAccess\n\nIntelligentTiering\n\nDeepArchive\n\nGlacierInstantRetrieval\n\nOutposts",
            "nullable": true
          },
          "assetType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetTypes"
              }
            ],
            "description": "Gets or sets the type classification of the asset (e.g., video, image, audio, document).\n\nFolder\n\nFile\n\nBucket",
            "x-enumNames": [
              "Folder",
              "File",
              "Bucket"
            ]
          }
        },
        "additionalProperties": false,
        "description": "Represents a summary view of an asset, including its identity, location, and current status."
      },
      "AssetPartUploadModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the ID of this specific part",
            "format": "uuid"
          },
          "url": {
            "type": "string",
            "description": "Gets or sets the URL that can be used to upload TO. This is meant to be a partial file upload location and will expire.",
            "nullable": true
          },
          "partNumber": {
            "type": "integer",
            "description": "Gets or sets the # of the part being uploaded",
            "format": "int32"
          },
          "startingPosition": {
            "type": "integer",
            "description": "Gets or sets the starting byte of the upload chunk for this part",
            "format": "int64"
          },
          "endingPosition": {
            "type": "integer",
            "description": "Gets or sets the ending byte of the upload chunk for this part",
            "format": "int64"
          },
          "isCompleted": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether if the part has already been uploaded"
          }
        },
        "additionalProperties": false,
        "description": "Represents a single part within a multipart upload, including its upload URL and byte range."
      },
      "AssetReferenceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "jobId": {
            "type": "string",
            "nullable": true
          },
          "url": {
            "type": "string",
            "nullable": true
          },
          "fullUrl": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "language": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LanguageModel"
              }
            ],
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "nullable": true
          },
          "metadataTypeDisplay": {
            "type": "string",
            "nullable": true
          },
          "mediaType": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "mediaTypeDisplay": {
            "type": "string",
            "nullable": true
          },
          "format": {
            "type": "string",
            "nullable": true
          },
          "templateName": {
            "type": "string",
            "nullable": true
          },
          "videoDuration": {
            "type": "string",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "isUrlSecure": {
            "type": "boolean",
            "nullable": true
          },
          "hasAds": {
            "type": "boolean",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "AssetStatsModel": {
        "type": "object",
        "properties": {
          "mediaTypeCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "assetTypeCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "assetStatusCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "storageClassCounts": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "totalContentLength": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "totalContentLengthDisplay": {
            "type": "string",
            "nullable": true
          },
          "totalVideoDuration": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "totalVideoDurationDisplay": {
            "type": "string",
            "nullable": true
          },
          "totalAudioDuration": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "totalAudioDurationDisplay": {
            "type": "string",
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AssetStatuses": {
        "enum": [
          "Available",
          "Renaming",
          "Copying",
          "Restoring",
          "Registering",
          "Uploading",
          "Archiving",
          "Archived",
          "PendingArchive",
          "PendingRestore",
          "Restored",
          "Deleting",
          "Moving",
          "SlugReplaced",
          "Updating",
          "Error",
          "Assembling",
          "Clipping",
          "Placeholder",
          "Creating",
          "Replacing"
        ],
        "type": "string",
        "description": "Indicates the current processing or lifecycle status of an asset.\r\nAn asset transitions through various statuses during operations such as upload, archive, restore, and delete.\n\nAvailable\n\nRenaming\n\nCopying\n\nRestoring\n\nRegistering\n\nUploading\n\nArchiving\n\nArchived\n\nPendingArchive\n\nPendingRestore\n\nRestored\n\nDeleting\n\nMoving\n\nSlugReplaced\n\nUpdating\n\nError\n\nAssembling\n\nClipping\n\nPlaceholder\n\nCreating\n\nReplacing",
        "x-enumNames": [
          "Available",
          "Renaming",
          "Copying",
          "Restoring",
          "Registering",
          "Uploading",
          "Archiving",
          "Archived",
          "PendingArchive",
          "PendingRestore",
          "Restored",
          "Deleting",
          "Moving",
          "SlugReplaced",
          "Updating",
          "Error",
          "Assembling",
          "Clipping",
          "Placeholder",
          "Creating",
          "Replacing"
        ]
      },
      "AssetTransferStatuses": {
        "enum": [
          "Queued",
          "Downloading",
          "Uploading",
          "Error",
          "Complete",
          "Cancelled"
        ],
        "type": "string",
        "description": "\n\nQueued\n\nDownloading\n\nUploading\n\nError\n\nComplete\n\nCancelled",
        "x-enumNames": [
          "Queued",
          "Downloading",
          "Uploading",
          "Error",
          "Complete",
          "Cancelled"
        ]
      },
      "AssetTypes": {
        "enum": [
          "Folder",
          "File",
          "Bucket"
        ],
        "type": "string",
        "description": "Categorizes the type of an asset in the media library.\n\nFolder\n\nFile\n\nBucket",
        "x-enumNames": [
          "Folder",
          "File",
          "Bucket"
        ]
      },
      "AssetUploadCompletePartRequestModel": {
        "type": "object",
        "properties": {
          "etag": {
            "type": "string",
            "description": "Gets or sets the etag that was returned from the client upload",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to mark an individual upload part as completed by providing its verification tag."
      },
      "AssetUploadModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the ID of the upload",
            "format": "uuid"
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the Asset ID where the upload will become",
            "format": "uuid"
          },
          "etag": {
            "type": "string",
            "description": "Gets or sets determines if the asset has been uploaded. If it has, the etag is there, else null.",
            "nullable": true
          },
          "url": {
            "type": "string",
            "description": "Gets or sets the URL of the upload",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "description": "Gets or sets the size of the file",
            "format": "int64"
          },
          "startDate": {
            "type": "string",
            "description": "Gets or sets the date the original upload was started",
            "format": "date-time"
          },
          "parts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetPartUploadModel"
            },
            "description": "Gets or sets the collection of individual upload parts that make up this multipart upload.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an active or completed asset upload session, including progress and part details."
      },
      "AssetUploadStartRequestModel": {
        "type": "object",
        "properties": {
          "existingAssetId": {
            "type": "string",
            "description": "Gets or sets the Existing AssetId (file) that should be overwritten with this upload.\r\nNote that by specifying this attribute then the parentId, relativePath and displayName are all ignored.",
            "format": "uuid",
            "nullable": true
          },
          "relatedContentId": {
            "type": "string",
            "description": "Gets or sets the Content ID of the related content record to associate this asset to.\r\nNote that by specifying this attribute then the parentId and relativePath attributes are both ignored.",
            "format": "uuid",
            "nullable": true
          },
          "parentId": {
            "type": "string",
            "description": "Gets or sets the Parent AssetId (folder) to add the upload to. Note that if there is a full relativePath, then it is appended to this parent path. If this value is omitted then the file will be added to the predefined incoming folder.\r\nThis is ignored if the ExistingAssetId or if the RelatedContentId has a value",
            "format": "uuid",
            "nullable": true
          },
          "relativePath": {
            "type": "string",
            "description": "Gets or sets the filename to upload - or a full path with the filename at the end.\r\nThis is ignored if the ExistingAssetId or if the RelatedContentId has a value",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "description": "Gets or sets the language of the asset to upload. If this is left blank then the default system language is used.",
            "format": "uuid",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "description": "Gets or sets the display name of the file to upload (does not include the path) and must include the file extension\r\nThis is ignored if the ExistingAssetId has a value",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "description": "Gets or sets the size of the asset to upload. This is used to calculate the upload parts.",
            "format": "int64"
          },
          "chunkSize": {
            "type": "integer",
            "description": "Gets or sets the size of the upload chunks. This should be adjusted to optimize the upload size based on the user's internet connection.",
            "format": "int64"
          },
          "uploadOverwriteOption": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UploadOverwriteOptions"
              }
            ],
            "description": "Gets or sets if the file already exists on the server, this decides how to handle the situation\n\nCancel\n\nContinue\n\nReplace\n\nAssetReplace",
            "x-enumNames": [
              "Cancel",
              "Continue",
              "Replace",
              "AssetReplace"
            ]
          },
          "uploadReplaceOptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UploadReplaceOptions"
            },
            "description": "Gets or sets if the asset already exists on the server, this decides how to handle the situation with related assets.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties for the uploaded file",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to initiate a new asset upload session, specifying the target location, file details, and upload options."
      },
      "AudioTrackModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "bitRate": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "samplingRate": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "numChannels": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "format": {
            "type": "string",
            "nullable": true
          },
          "frameRate": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "frameCount": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "bitDepth": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "bitRateMode": {
            "type": "string",
            "nullable": true
          },
          "durationSeconds": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "language": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LanguageModel"
              }
            ],
            "nullable": true
          },
          "trackPosition": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "inputTracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AudioTrackModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AuthProvider": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "priority": {
            "type": "integer",
            "format": "int32"
          },
          "visible": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AvailabilityModel": {
        "type": "object",
        "properties": {
          "availableStartDate": {
            "type": "string",
            "description": "Gets or sets the availability starting date of the asset for entitlement purposes.",
            "format": "date-time",
            "nullable": true
          },
          "availableEndDate": {
            "type": "string",
            "description": "Gets or sets the availability ending date of the asset for entitlement purposes.",
            "format": "date-time",
            "nullable": true
          },
          "isInherited": {
            "type": "boolean",
            "description": "Gets or sets availability isInherited flag.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BatchModel": {
        "type": "object",
        "properties": {
          "batchAction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "schemaName": {
            "type": "string",
            "nullable": true
          },
          "targetIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "userId": {
            "type": "string",
            "format": "uuid"
          },
          "actionArguments": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "resolverExempt": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BatchResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": { },
              "description": "A dictionary-based model that extends CaseInsensitiveDictionary. Contains a primary key Id (Guid) and dynamic key-value pairs representing entity properties. Use GetProperty<T>(key) to access typed values."
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          }
        },
        "additionalProperties": false,
        "description": "Contains a list of PartialModel items representing the results of a batch operation, along with TotalItemCount indicating how many items were processed."
      },
      "BigDecimal": {
        "type": "object",
        "properties": {
          "sign": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "significantDigits": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "length": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "decimalPlaces": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          },
          "wholeValue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BigInteger"
              }
            ],
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "BigInteger": {
        "type": "object",
        "properties": {
          "isPowerOfTwo": {
            "type": "boolean",
            "readOnly": true
          },
          "isZero": {
            "type": "boolean",
            "readOnly": true
          },
          "isOne": {
            "type": "boolean",
            "readOnly": true
          },
          "isEven": {
            "type": "boolean",
            "readOnly": true
          },
          "sign": {
            "type": "integer",
            "format": "int32",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "BoundingBoxModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "format": "double"
          },
          "top": {
            "type": "number",
            "format": "double"
          },
          "left": {
            "type": "number",
            "format": "double"
          },
          "height": {
            "type": "number",
            "format": "double"
          },
          "width": {
            "type": "number",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "Callback": {
        "type": "object",
        "properties": {
          "protocol": {
            "type": "string",
            "description": "Gets or sets the protocol for the callback URL. Defaults to \"https\".",
            "nullable": true
          },
          "host": {
            "type": "string",
            "description": "Gets or sets the hostname of the callback endpoint.",
            "nullable": true
          },
          "port": {
            "type": "integer",
            "description": "Gets or sets the port number for the callback endpoint. Defaults to 443.",
            "format": "int32"
          },
          "method": {
            "type": "string",
            "description": "Gets or sets the HTTP method for the callback request. Defaults to \"POST\".",
            "nullable": true
          },
          "path": {
            "type": "string",
            "description": "Gets or sets the URL path for the callback endpoint. Defaults to \"/api/phenix/status\".",
            "nullable": true
          },
          "query": {
            "type": "string",
            "description": "Gets or sets the optional query string parameters for the callback URL.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the callback endpoint configuration for a Phenix webhook registration."
      },
      "ChangeAssetLanguageModel": {
        "type": "object",
        "properties": {
          "languageId": {
            "type": "string",
            "description": "Gets or sets the identifier of the language to assign to the asset, or null to clear the language.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to change the language assigned to an asset."
      },
      "ChangeAssetPropertiesModel": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "description": "Gets or sets the visual name of the asset for display purposes",
            "nullable": true
          },
          "displayDate": {
            "type": "string",
            "description": "Gets or sets the visual date of the asset for display purposes",
            "format": "date-time",
            "nullable": true
          },
          "availableStartDate": {
            "type": "string",
            "description": "Gets or sets the availability starting date of the asset for entitlement purposes\r\nMinValue is used to differentiate between null values and missing properties\r\nWe technically want null so we can clear the date.",
            "format": "date-time",
            "nullable": true
          },
          "availableEndDate": {
            "type": "string",
            "description": "Gets or sets the availability ending date of the asset for entitlement purposes\r\nMinValue is used to differentiate between null values and missing properties\r\nWe technically want null so we can clear the date.",
            "format": "date-time",
            "nullable": true
          },
          "customProperties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets a list of custom properties that should be saved for the asset.\r\nTo remove a property value, set the value to null.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to modify the display properties and custom attributes of an asset."
      },
      "ChangeEmailRequestModel": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Gets or sets the user's current password for verification.",
            "nullable": true
          },
          "newEmail": {
            "type": "string",
            "description": "Gets or sets the new email address to set for the user.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ChangePasswordRequestModel": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Gets or sets the user's current password for verification.",
            "nullable": true
          },
          "newPassword": {
            "type": "string",
            "description": "Gets or sets the new password to set for the user.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ChangeSessionStatusModel": {
        "required": [
          "id",
          "userSessionStatus"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user session to update. Required.",
            "format": "uuid"
          },
          "userSessionStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserSessionStatuses"
              }
            ],
            "description": "Gets or sets the new status to apply to the session (e.g., Kicked, ChatRestricted, Expired). Required.\n\nNormal\n\nChatDisabled\n\nSessionReplaced\n\nDeactivated\n\nSharedAccess\n\nPendingInvite\n\nExpired\n\nDeletedInvite",
            "x-enumNames": [
              "Normal",
              "ChatDisabled",
              "SessionReplaced",
              "Deactivated",
              "SharedAccess",
              "PendingInvite",
              "Expired",
              "DeletedInvite"
            ]
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the optional application identifier to scope the session lookup.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for changing the status of a user session (e.g., kicking a user or restricting chat access)."
      },
      "Claim": {
        "type": "object",
        "properties": {
          "issuer": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "originalIssuer": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "nullable": true,
            "readOnly": true
          },
          "subject": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ClaimsIdentity"
              }
            ],
            "nullable": true,
            "readOnly": true
          },
          "type": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "value": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "valueType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ClaimsIdentity": {
        "type": "object",
        "properties": {
          "authenticationType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "isAuthenticated": {
            "type": "boolean",
            "readOnly": true
          },
          "actor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ClaimsIdentity"
              }
            ],
            "nullable": true
          },
          "bootstrapContext": {
            "nullable": true
          },
          "claims": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Claim"
            },
            "nullable": true,
            "readOnly": true
          },
          "label": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "nameClaimType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "roleClaimType": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ClipModel": {
        "type": "object",
        "properties": {
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the clip begins.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode where the clip ends.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the clip.",
            "nullable": true
          },
          "outputFolderId": {
            "type": "string",
            "description": "Gets or sets the identifier of the folder where the generated clip will be placed.",
            "format": "uuid",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags to apply to the generated clip.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of collections to assign the generated clip to.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content items to link to the generated clip.",
            "nullable": true
          },
          "internalMasterManifestUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the master manifest used for clip generation.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to create a clip from a media asset by specifying a time range and metadata."
      },
      "CloudFrontDistributions": {
        "enum": [
          "Content",
          "PublicApi",
          "RestrictedContent"
        ],
        "type": "string",
        "description": "\n\nContent\n\nPublicApi\n\nRestrictedContent",
        "x-enumNames": [
          "Content",
          "PublicApi",
          "RestrictedContent"
        ]
      },
      "CollectionContentModel": {
        "type": "object",
        "properties": {
          "contentDefinition": {
            "type": "string",
            "description": "Gets or sets the content definition string name of the content records that should be affected\r\nLike asset, video, etc",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the ID of the content record to apply the new or removed attributes",
            "format": "uuid"
          },
          "createNew": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether defaults to False. If true, then the attribute will be added if it doesn't already exist with a matching name"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the collection that should be added or removed. If the name and the collectionId are both specified, the name is ignored.",
            "nullable": true
          },
          "collectionId": {
            "type": "string",
            "description": "Gets or sets the collection ID that should be added or removed",
            "format": "uuid",
            "nullable": true
          },
          "childId": {
            "type": "string",
            "description": "Gets the child identifier, which is the collection identifier.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "childPropertyName": {
            "type": "string",
            "description": "Gets the name of the child property used for serialization.",
            "nullable": true,
            "readOnly": true
          },
          "indexPropertyName": {
            "type": "string",
            "description": "Gets the name of the index property used in search indexing.",
            "nullable": true,
            "readOnly": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets the content definition identifier for collections.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the association between a content item and a collection, used for adding or removing content from collections."
      },
      "CollectionContentModelListModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CollectionContentModel"
            },
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "CollectionModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the collection, or null when creating a new collection.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the collection.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a content collection with its identifier and display name."
      },
      "ConfigAdminModel": {
        "type": "object",
        "properties": {
          "assetRootName": {
            "type": "string",
            "nullable": true
          },
          "assetListContentTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "assetContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "assetMetadataContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "collectionContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "securityGroupContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "roleContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "customLabelerContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinitionContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentFieldContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "dataSelectorContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "faceContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "personContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "timeZoneContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "tagContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "liveChannelContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "formSelectorContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "defaultPageTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "pageContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "pageTemplateContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "playlistContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "intelligentProgrammingContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "dayOfWeekContentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "defaultLanguage": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "publicContentId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "rootAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "rootTemplateId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "shortTextFieldId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "siteInitializationStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SiteInitializationStatuses"
              }
            ],
            "description": "\n\n1 = New\n\n2 = Initializing\n\n3 = InitializingContent\n\n4 = Initialized\n\n5 = InitializationError",
            "nullable": true
          },
          "fileAssetTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "folderAssetTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "imageMediaTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "siteName": {
            "type": "string",
            "nullable": true
          },
          "baseDomain": {
            "type": "string",
            "nullable": true
          },
          "siteUrl": {
            "type": "string",
            "nullable": true
          },
          "logoImageUrl": {
            "type": "string",
            "nullable": true
          },
          "loginLogoImageUrl": {
            "type": "string",
            "nullable": true
          },
          "webRtcIceServer": {
            "type": "string",
            "nullable": true
          },
          "webRtcApplication": {
            "type": "string",
            "nullable": true
          },
          "theoPlayerLicenseKey": {
            "type": "string",
            "nullable": true
          },
          "bitmovinPlayerLicenseKey": {
            "type": "string",
            "nullable": true
          },
          "bitmovinAnalyticsLicenseKey": {
            "type": "string",
            "nullable": true
          },
          "allowLiveScreenshots": {
            "type": "boolean"
          },
          "templatePack": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "propertyMetadata": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "nullable": true
          },
          "customProperties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "nullable": true
          },
          "authProviders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthProvider"
            },
            "nullable": true
          },
          "players": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VideoPlayerProfile"
            },
            "nullable": true
          },
          "videoTrackingBeaconIntervalInSeconds": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "allowRealtimeChannel": {
            "type": "boolean",
            "nullable": true
          },
          "allowBasicChannel": {
            "type": "boolean",
            "nullable": true
          },
          "googleTagManagerId": {
            "type": "string",
            "nullable": true
          },
          "startWorkflowTitle": {
            "type": "string",
            "nullable": true
          },
          "startWorkflowName": {
            "type": "string",
            "nullable": true
          },
          "enableBulkDownload": {
            "type": "boolean"
          },
          "allowLiveClipping": {
            "type": "boolean"
          },
          "enableLlmSearch": {
            "type": "boolean"
          },
          "webRtcDebugEnabled": {
            "type": "boolean"
          },
          "webRtcUseWhepClient": {
            "type": "boolean"
          },
          "webRtcUseStreamManager": {
            "type": "boolean"
          },
          "webRtcNodeGroup": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConfigTypes": {
        "enum": [
          1,
          2,
          3
        ],
        "type": "integer",
        "description": "\n\n1 = Admin\n\n2 = Lambda\n\n3 = Groundtruth",
        "format": "int32",
        "x-enumNames": [
          "Admin",
          "Lambda",
          "Groundtruth"
        ]
      },
      "ContentBulkMetadataUpdateModel": {
        "type": "object",
        "properties": {
          "contentDefinitionId": {
            "type": "string",
            "description": "The content definition ID scoping the update. Defaults to the asset content definition if null.",
            "format": "uuid",
            "nullable": true
          },
          "contentIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "The list of content item IDs to update.",
            "nullable": true
          },
          "propertyChanges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentChangePropertyModel"
            },
            "description": "The list of property changes to apply to each content item.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for applying bulk metadata updates across multiple content items."
      },
      "ContentChangePropertyModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "value": {
            "nullable": true
          },
          "changeType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PropertyChangeTypes"
              }
            ],
            "description": "\n\nReplace\n\nClear",
            "x-enumNames": [
              "Replace",
              "Clear"
            ]
          }
        },
        "additionalProperties": false
      },
      "ContentDefinitionGroupModel": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "nullable": true
          },
          "contentDefinitionGroupId": {
            "type": "string",
            "format": "uuid"
          },
          "contentDefinitions": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ContentDefinitionGroupModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentDefinitionGroupModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentDefinitionGroupModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "ContentDefinitionModel": {
        "type": "object",
        "properties": {
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "editorTemplate": {
            "type": "string",
            "nullable": true
          },
          "permission": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityPermissions"
              }
            ],
            "description": "\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
            "nullable": true
          },
          "isSystemModule": {
            "type": "boolean"
          },
          "useEditorFormOverride": {
            "type": "boolean"
          },
          "templateFolderAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentFieldModel"
            },
            "nullable": true,
            "readOnly": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          },
          "assignedSecurity": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ContentDefinitionModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentDefinitionModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentDefinitionModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "ContentFieldModel": {
        "type": "object",
        "properties": {
          "contentFieldId": {
            "type": "string",
            "format": "uuid"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "listViewSequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "editorViewSequence": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "isInEditorForm": {
            "type": "boolean"
          },
          "isInContentList": {
            "type": "boolean"
          },
          "isDeleted": {
            "type": "boolean"
          },
          "isSystemField": {
            "type": "boolean"
          },
          "isReadOnly": {
            "type": "boolean"
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ContentLanguageStatuses": {
        "enum": [
          "Original",
          "Override",
          "Auto"
        ],
        "type": "string",
        "description": "\n\nOriginal\n\nOverride\n\nAuto",
        "x-enumNames": [
          "Original",
          "Override",
          "Auto"
        ]
      },
      "ContentManagementTypes": {
        "enum": [
          1,
          2,
          3
        ],
        "type": "integer",
        "description": "\n\n1 = None\n\n2 = DataSelector\n\n3 = FormSelector",
        "format": "int32",
        "x-enumNames": [
          "None",
          "DataSelector",
          "FormSelector"
        ]
      },
      "ContentModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "format": "uuid"
          },
          "masterId": {
            "type": "string",
            "format": "uuid"
          },
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "expirationDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "language": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentLanguageStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentLanguageStatuses"
              }
            ],
            "description": "\n\nOriginal\n\nOverride\n\nAuto",
            "nullable": true
          },
          "originalLanguageName": {
            "type": "string",
            "nullable": true
          },
          "permission": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityPermissions"
              }
            ],
            "description": "\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
            "x-enumNames": [
              "Read",
              "FileWrite",
              "FolderWrite",
              "Administrator",
              "Guest"
            ]
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ContentResult": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "nullable": true
          },
          "contentType": {
            "type": "string",
            "nullable": true
          },
          "statusCode": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ContentResultsModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid"
          }
        },
        "additionalProperties": false
      },
      "ContentRevisionModel": {
        "type": "object",
        "properties": {
          "revisionId": {
            "type": "string",
            "format": "uuid"
          },
          "revisionDate": {
            "type": "string",
            "format": "date-time"
          },
          "user": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ContentTextTypes": {
        "enum": [
          "Line",
          "Word",
          "Person",
          "Location",
          "Organization",
          "CommercialItem",
          "Event",
          "Date",
          "Quantity",
          "Title",
          "Entity",
          "KeyPhrase",
          "MixedSentiment",
          "NegativeSentiment",
          "NeutralSentiment",
          "PositiveSentiment",
          "Transcript",
          "Other"
        ],
        "type": "string",
        "description": "\n\nLine\n\nWord\n\nPerson\n\nLocation\n\nOrganization\n\nCommercialItem\n\nEvent\n\nDate\n\nQuantity\n\nTitle\n\nEntity\n\nKeyPhrase\n\nMixedSentiment\n\nNegativeSentiment\n\nNeutralSentiment\n\nPositiveSentiment\n\nTranscript\n\nOther",
        "x-enumNames": [
          "Line",
          "Word",
          "Person",
          "Location",
          "Organization",
          "CommercialItem",
          "Event",
          "Date",
          "Quantity",
          "Title",
          "Entity",
          "KeyPhrase",
          "MixedSentiment",
          "NegativeSentiment",
          "NeutralSentiment",
          "PositiveSentiment",
          "Transcript",
          "Other"
        ]
      },
      "ContentTypeModel": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "nullable": true
          },
          "contentTypeId": {
            "type": "string",
            "format": "uuid"
          },
          "typeName": {
            "type": "string",
            "nullable": true
          },
          "contentManagementType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentManagementTypes"
              }
            ],
            "description": "\n\n1 = None\n\n2 = DataSelector\n\n3 = FormSelector",
            "x-enumNames": [
              "None",
              "DataSelector",
              "FormSelector"
            ]
          },
          "hasLayout": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "ContentTypeModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentTypeModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentTypeModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "ContentUpdateModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "format": "uuid"
          },
          "masterId": {
            "type": "string",
            "format": "uuid"
          },
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid"
          },
          "language": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ContentUserSessionModel": {
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "string",
            "format": "uuid"
          },
          "userId": {
            "type": "string",
            "format": "uuid"
          },
          "firstName": {
            "type": "string",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "nullable": true
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "browserType": {
            "type": "string",
            "nullable": true
          },
          "userAgent": {
            "type": "string",
            "nullable": true
          },
          "ipAddress": {
            "type": "string",
            "nullable": true
          },
          "environmentName": {
            "type": "string",
            "nullable": true
          },
          "startDate": {
            "type": "string",
            "format": "date-time"
          },
          "lastActivityDate": {
            "type": "string",
            "format": "date-time"
          },
          "deactivated": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "ContentUserSessionModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentUserSessionModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ContentUserSessionModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "CreateFolderModel": {
        "required": [
          "displayName"
        ],
        "type": "object",
        "properties": {
          "displayName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the visual name of the new folder. It can contain spaces and other characters."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to create a new folder within the asset hierarchy."
      },
      "CreateLiveOperatorSegmentRequestModel": {
        "type": "object",
        "properties": {
          "liveOperatorId": {
            "type": "string",
            "description": "Gets or sets the identifier of the live operator session to create the segment in.",
            "format": "uuid",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content references for the segment.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags associated with the segment.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the request model for creating a new segment within a live operator stream."
      },
      "CreateLiveOperatorStreamRequestModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the optional identifier for the live operator stream.",
            "format": "uuid",
            "nullable": true
          },
          "preRollAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the pre-roll asset played before the live stream starts.",
            "nullable": true
          },
          "postRollAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the post-roll asset played after the live stream ends.",
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live input source reference for the stream.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content references for the stream.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags associated with the stream.",
            "nullable": true
          },
          "liveChannelId": {
            "type": "string",
            "description": "Gets or sets the live channel identifier to assign to the stream.",
            "format": "uuid"
          },
          "customProperties": {
            "type": "object",
            "additionalProperties": { },
            "description": "Gets or sets the custom properties dictionary for the stream.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the request model for creating or starting a live operator stream."
      },
      "CreatePlaceholderModel": {
        "required": [
          "assetName"
        ],
        "type": "object",
        "properties": {
          "assetName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the visual name of the new placeholder. It can contain spaces and other characters,\r\nmust contain file extension"
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to create a placeholder asset that reserves a name before the actual file is uploaded."
      },
      "EluvioTokenRequestModel": {
        "type": "object",
        "properties": {
          "mezzanineObjectId": {
            "type": "string",
            "description": "Gets or sets the Eluvio mezzanine object identifier.",
            "nullable": true
          },
          "mezzanineLibraryId": {
            "type": "string",
            "description": "Gets or sets the Eluvio mezzanine library identifier.",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the content identifier associated with the token request.",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets or sets the content definition identifier associated with the token request.",
            "format": "uuid",
            "nullable": true
          },
          "useJsClientApi": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to use the JavaScript client API for token generation."
          }
        },
        "additionalProperties": false,
        "description": "Represents the request model for generating a signed Eluvio content fabric security token."
      },
      "EluvioTokenResponseModel": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Gets or sets the signed Eluvio security token.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response containing a signed Eluvio security token."
      },
      "EmailDispatcherModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the email dispatch request.",
            "format": "uuid"
          },
          "emailType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EmailTypes"
              }
            ],
            "description": "Gets or sets the type of email to dispatch.\n\nAssetRestored\n\nUserApproved\n\nCollectionShared\n\nCollectionSharedExternal\n\nUserInvite\n\nAssetShared\n\nDownloadZipFile\n\nMediaBuilderNotification\n\nLiveRecordingStopped\n\nExportSearchResults\n\nAssetSharedExternal",
            "x-enumNames": [
              "AssetRestored",
              "UserApproved",
              "CollectionShared",
              "CollectionSharedExternal",
              "UserInvite",
              "AssetShared",
              "DownloadZipFile",
              "MediaBuilderNotification",
              "LiveRecordingStopped",
              "ExportSearchResults",
              "AssetSharedExternal"
            ]
          },
          "userId": {
            "type": "string",
            "description": "Gets or sets the identifier of the user associated with the email.",
            "format": "uuid"
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the asset referenced in the email.",
            "format": "uuid"
          },
          "userFirstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user for email personalization.",
            "nullable": true
          },
          "userLastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user for email personalization.",
            "nullable": true
          },
          "userEmail": {
            "type": "string",
            "description": "Gets or sets the email address of the user.",
            "nullable": true
          },
          "assetName": {
            "type": "string",
            "description": "Gets or sets the name of the asset referenced in the email.",
            "nullable": true
          },
          "recipients": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of recipient email addresses.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties used for email template rendering.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an email dispatch request containing recipient details, email type, and contextual data."
      },
      "EmailTypes": {
        "enum": [
          "AssetRestored",
          "UserApproved",
          "CollectionShared",
          "CollectionSharedExternal",
          "UserInvite",
          "AssetShared",
          "DownloadZipFile",
          "MediaBuilderNotification",
          "LiveRecordingStopped",
          "ExportSearchResults",
          "AssetSharedExternal"
        ],
        "type": "string",
        "description": "\n\nAssetRestored\n\nUserApproved\n\nCollectionShared\n\nCollectionSharedExternal\n\nUserInvite\n\nAssetShared\n\nDownloadZipFile\n\nMediaBuilderNotification\n\nLiveRecordingStopped\n\nExportSearchResults\n\nAssetSharedExternal",
        "x-enumNames": [
          "AssetRestored",
          "UserApproved",
          "CollectionShared",
          "CollectionSharedExternal",
          "UserInvite",
          "AssetShared",
          "DownloadZipFile",
          "MediaBuilderNotification",
          "LiveRecordingStopped",
          "ExportSearchResults",
          "AssetSharedExternal"
        ]
      },
      "FaceMatchTypes": {
        "enum": [
          "Automatch",
          "ProbableMatch",
          "NotMatch",
          "ConfirmedMatch",
          "Blurry"
        ],
        "type": "string",
        "description": "Categorizes the type of facial recognition match between a detected face and a person.\r\nUsed to filter face results when querying person faces.\n\nAutomatch\n\nProbableMatch\n\nNotMatch\n\nConfirmedMatch\n\nBlurry",
        "x-enumNames": [
          "Automatch",
          "ProbableMatch",
          "NotMatch",
          "ConfirmedMatch",
          "Blurry"
        ]
      },
      "FaceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "confidence": {
            "type": "number",
            "format": "double"
          },
          "externalFaceId": {
            "type": "string",
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "similarityScore": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "personId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "nullable": true
          },
          "rotationCorrection": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "celebrityExternalId": {
            "type": "string",
            "nullable": true
          },
          "celebrityConfidence": {
            "type": "number",
            "format": "float",
            "nullable": true
          },
          "celebrityName": {
            "type": "string",
            "nullable": true
          },
          "celebrityUrls": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "isPersonValidated": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "FieldModel": {
        "type": "object",
        "properties": {
          "fieldId": {
            "type": "string",
            "format": "uuid"
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "typeName": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "FieldModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FieldModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FieldModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "ForgotPasswordRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to reset. Required."
          }
        },
        "additionalProperties": false,
        "description": "Request model for initiating a password reset flow."
      },
      "GenerateImageModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the source asset to use as a reference for image generation.",
            "format": "uuid"
          },
          "prompt": {
            "type": "string",
            "description": "Gets or sets the text prompt describing the desired image output.",
            "nullable": true
          },
          "negativePrompt": {
            "type": "string",
            "description": "Gets or sets the optional negative prompt describing elements to exclude from the generated image.",
            "nullable": true
          },
          "boundingBox": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BoundingBoxModel"
              }
            ],
            "description": "Gets or sets the optional bounding box that defines the region of interest for image generation.",
            "nullable": true
          },
          "applyInternalBoundingBox": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to apply the internally computed bounding box during generation."
          },
          "maskPrompt": {
            "type": "string",
            "description": "Gets or sets the optional mask prompt used to define areas of the image to modify.",
            "nullable": true
          },
          "variation": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to generate a variation of the source image rather than a new image."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to generate a new image based on an existing asset using AI image generation capabilities."
      },
      "GenerateImageModelResponse": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the newly generated image asset, or null if generation failed.",
            "format": "uuid",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "description": "Gets or sets the URL where the generated image can be accessed, or null if generation failed.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response from an AI image generation request, containing the resulting asset and its URL."
      },
      "GeoData": {
        "type": "object",
        "properties": {
          "latitude": {
            "type": "number",
            "description": "Latitude measures the distance north or south of the equator.",
            "format": "double",
            "nullable": true
          },
          "longitude": {
            "type": "number",
            "description": "Longitude is a geographic coordinate that specifies the east–west position of a point on the surface of the Earth, or another celestial body.",
            "format": "double",
            "nullable": true
          },
          "altitude": {
            "type": "number",
            "description": "Altitude is the vertical elevation of an object above a surface (such as sea level or land) of a planet or natural satellite.",
            "format": "double",
            "nullable": true
          },
          "latitudeSpan": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "longitudeSpan": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Google Photos Specific Class For GeoData.\r\nhttps://exiftool.org/forum/index.php?topic=9972.0 --> ExifTool Parsing Google JSON.\r\n\r\nhttps://github.com/StarGeekSpaceNerd/Metadata_Reference/blob/master/Photos.google.com.md\r\ngeoData (Location entered on website)\r\ngeoDataExif (original location per file exif)"
      },
      "HistoryEntityResponseModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the audit entry.",
            "format": "uuid"
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets or sets the content definition ID of the audited item.",
            "format": "uuid",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the content item ID that was audited.",
            "format": "uuid",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Gets or sets a human-readable description of the audited action.",
            "nullable": true
          },
          "action": {
            "type": "string",
            "description": "Gets or sets the type of action that was performed (e.g., Create, Update, Delete).",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the application ID that performed the action.",
            "format": "uuid",
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "description": "Gets or sets the date and time the audit entry was last modified.",
            "format": "date-time"
          },
          "createdDate": {
            "type": "string",
            "description": "Gets or sets the date and time the audit event occurred.",
            "format": "date-time"
          },
          "lastModifiedUserName": {
            "type": "string",
            "description": "Gets or sets the username of the person who performed the action.",
            "nullable": true
          },
          "lastModifiedUserId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the person who performed the action.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a single audit history entry for a content item."
      },
      "IdModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          }
        },
        "additionalProperties": false,
        "description": "A wrapper containing a single Guid identifier. The Id property represents the unique identifier of the created or affected entity."
      },
      "ImportScheduleItemModel": {
        "type": "object",
        "properties": {
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the start time code for the imported schedule item.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the end time code for the imported schedule item.",
            "nullable": true
          },
          "days": {
            "type": "string",
            "description": "Gets or sets the comma-separated list of days on which the imported item is active.",
            "nullable": true
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the asset associated with the imported schedule item.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a schedule item to be imported, typically from an external source or bulk import file."
      },
      "InvalidateDistributionModel": {
        "type": "object",
        "properties": {
          "cloudFrontDistribution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CloudFrontDistributions"
              }
            ],
            "description": "Gets or sets the CloudFront distribution to invalidate.\n\nContent\n\nPublicApi\n\nRestrictedContent",
            "x-enumNames": [
              "Content",
              "PublicApi",
              "RestrictedContent"
            ]
          },
          "path": {
            "type": "string",
            "description": "Gets or sets the path pattern to invalidate within the distribution cache.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to invalidate a CloudFront distribution cache for a specified path."
      },
      "JobCompleteModel": {
        "required": [
          "jobResultsUrl"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string",
            "description": "Gets or sets the external identifier for correlating the completed job with an external system.",
            "nullable": true
          },
          "jobResultsUrl": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the URL where the job results can be retrieved."
          }
        },
        "additionalProperties": false,
        "description": "Represents the completion callback model for a media processing job."
      },
      "JobHistoryModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the job history record.",
            "format": "uuid"
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the asset that this job was executed against.",
            "format": "uuid"
          },
          "jobType": {
            "type": "string",
            "description": "Gets or sets the type classification of the job (e.g., transcode, thumbnail generation).",
            "nullable": true
          },
          "registerDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the job was initially registered in the queue.",
            "format": "date-time",
            "nullable": true
          },
          "startDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the job started processing.",
            "format": "date-time",
            "nullable": true
          },
          "completeDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the job completed successfully.",
            "format": "date-time",
            "nullable": true
          },
          "errorDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the job encountered an error.",
            "format": "date-time",
            "nullable": true
          },
          "isErrored": {
            "type": "boolean",
            "description": "Gets a value indicating whether the job has encountered an error.",
            "readOnly": true
          },
          "description": {
            "type": "string",
            "description": "Gets or sets a technical description of the job.",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "Gets or sets the user-facing message describing the job status or result.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the dictionary of additional properties associated with the job.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a historical record of a processing job executed against an asset, including status and timing information."
      },
      "LabelModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the label.",
            "format": "uuid"
          },
          "labelName": {
            "type": "string",
            "description": "Gets or sets the name of the detected label.",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "description": "Gets or sets the confidence score of the label detection, expressed as a value between 0 and 100.",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "description": "Gets or sets the number of times this label was detected across segments or frames.",
            "format": "int64",
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "description": "Gets or sets the list of time-based segments where this label was detected.",
            "nullable": true
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LabelModel"
            },
            "description": "Gets or sets the list of child labels that are more specific subcategories of this label.",
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "description": "Gets or sets the list of bounding boxes that indicate where this label was detected in the image.",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "description": "Gets or sets the source identifier used when no bounding box data is available.",
            "format": "uuid",
            "nullable": true
          },
          "rollupCount": {
            "type": "integer",
            "description": "Gets or sets the aggregated count across all child labels and segments.",
            "format": "int32",
            "nullable": true
          },
          "rollupConfidence": {
            "type": "number",
            "description": "Gets or sets the aggregated confidence score across all child labels and segments.",
            "format": "double",
            "nullable": true
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "Gets or sets the type of metadata analysis that produced this label.\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a detected label or category identified within an asset, including confidence scores and hierarchical relationships."
      },
      "LanguageModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "translatedTitle": {
            "type": "string",
            "nullable": true
          },
          "iso2": {
            "type": "string",
            "nullable": true
          },
          "iso3": {
            "type": "string",
            "nullable": true
          },
          "iso5": {
            "type": "string",
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "float",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LicenseGrant": {
        "type": "object",
        "properties": {
          "customer": {
            "type": "string",
            "description": "Gets or sets the name or identifier of the customer that holds the license.",
            "nullable": true
          },
          "isAdminGranted": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the customer is granted access to the Admin API."
          },
          "isPortalGranted": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the customer is granted access to the Portal API."
          }
        },
        "additionalProperties": false,
        "description": "Represents a license grant configuration specifying which API access is granted to a customer."
      },
      "LiveChannelEditModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "thumbnailImage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "archivePrefixes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "nullable": true
          },
          "externalUrl": {
            "type": "string",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean"
          },
          "enableHighAvailability": {
            "type": "boolean",
            "nullable": true
          },
          "enableLiveClipping": {
            "type": "boolean",
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputScreenshots": {
            "type": "boolean"
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the security groups that this live channel is part of",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveChannelModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the live channel.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the live channel.",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "description": "Gets or sets the URL-friendly route name for the live channel.",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the output stream uses secure (signed) URLs."
          },
          "outputScreenshots": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether output screenshots are enabled for the channel."
          },
          "enableHighAvailability": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether high availability mode is enabled for the channel.",
            "nullable": true
          },
          "disableChannelControls": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether channel controls are disabled in the UI.",
            "nullable": true
          },
          "disableRecordingControls": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether recording controls are disabled in the UI.",
            "nullable": true
          },
          "thumbnailImageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the channel's thumbnail image.",
            "nullable": true
          },
          "thumbnailImage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the thumbnail image asset reference for the channel.",
            "nullable": true
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the folder asset reference where archived recordings are stored.",
            "nullable": true
          },
          "channelId": {
            "type": "string",
            "description": "Gets or sets the external channel identifier from the live streaming provider.",
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of the live channel.",
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output type configuration for the live channel.",
            "nullable": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the live channel.",
            "nullable": true
          },
          "recordingStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current recording status of the live channel.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "nullable": true
          },
          "outputStartTime": {
            "type": "string",
            "description": "Gets or sets the date and time when the output stream started.",
            "format": "date-time",
            "nullable": true
          },
          "inputMaximumBitrate": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the maximum bitrate configuration for the input stream.",
            "nullable": true
          },
          "inputResolution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the resolution configuration for the input stream.",
            "nullable": true
          },
          "inputCodec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the codec configuration for the input stream.",
            "nullable": true
          },
          "outputLiveVideoUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the live video output stream.",
            "nullable": true
          },
          "outputLiveVideoHlsUrl": {
            "type": "string",
            "description": "Gets or sets the HLS URL of the live video output stream.",
            "nullable": true
          },
          "outputLiveVideoRtcUrl": {
            "type": "string",
            "description": "Gets or sets the WebRTC URL of the live video output stream.",
            "nullable": true
          },
          "inputIngestAddress": {
            "type": "string",
            "description": "Gets or sets the ingest address for the input stream.",
            "nullable": true
          },
          "inputStreamKey": {
            "type": "string",
            "description": "Gets or sets the stream key used to authenticate the input stream.",
            "nullable": true
          },
          "inputAuthKey": {
            "type": "string",
            "description": "Gets or sets the authentication key for the input stream.",
            "nullable": true
          },
          "scheduleEvents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "description": "Gets or sets the list of schedule events associated with this channel.",
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the channel was last modified.",
            "format": "date-time"
          },
          "lastStateChangedDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the channel state last changed.",
            "format": "date-time",
            "nullable": true
          },
          "lastRecordingStateChangedDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the recording state last changed.",
            "format": "date-time",
            "nullable": true
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of output encoding profiles for the channel.",
            "nullable": true
          },
          "statusMessages": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets the collection of status messages for the channel.",
            "nullable": true,
            "readOnly": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output profile group reference for the channel.",
            "nullable": true
          },
          "recordingStartedByUser": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the user who started the current recording.",
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of external output profiles for the channel.",
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of security groups assigned to the channel.",
            "nullable": true
          },
          "archivePrefixes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of archive prefix paths for the channel.",
            "nullable": true
          },
          "archiveOutputFilename": {
            "type": "string",
            "description": "Gets or sets the filename pattern used for archived output recordings.",
            "nullable": true
          },
          "liveScheduleId": {
            "type": "string",
            "description": "Gets or sets the identifier of the live schedule associated with this channel.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the internal live channel model with extended configuration, status, and recording information."
      },
      "LiveChannelModelLiveResultModel": {
        "type": "object",
        "properties": {
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveChannelModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveChannelNewModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean"
          },
          "outputScreenshots": {
            "type": "boolean"
          },
          "enableHighAvailability": {
            "type": "boolean",
            "nullable": true
          },
          "enableLiveClipping": {
            "type": "boolean",
            "nullable": true
          },
          "thumbnailImage": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "externalUrl": {
            "type": "string",
            "nullable": true
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "archivePrefixes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the security groups that this live channel is part of",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveClipResponseModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the clip.",
            "format": "uuid"
          },
          "internalMasterManifestUrl": {
            "type": "string",
            "description": "Gets or sets the internal URL to the master manifest for the clip.",
            "nullable": true
          },
          "masterHlsSnapshotUrl": {
            "type": "string",
            "description": "Gets or sets the master HLS snapshot URL for the clip.",
            "nullable": true
          },
          "snapshotStartDtUtc": {
            "type": "string",
            "description": "Gets or sets the UTC date and time when the snapshot started.",
            "format": "date-time",
            "nullable": true
          },
          "snapshotDuration": {
            "type": "number",
            "description": "Gets or sets the duration of the snapshot in seconds.",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the response from a live stream snapshot clip operation."
      },
      "LiveEndpointInfoModel": {
        "type": "object",
        "properties": {
          "ip": {
            "type": "string",
            "nullable": true
          },
          "port": {
            "type": "string",
            "nullable": true
          },
          "url": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveInputEditModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "sourceCidr": {
            "type": "string",
            "nullable": true
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: URL_PULL, MP4_FILE",
            "nullable": true
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: RTMP_PULL",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveInputModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "sourceCidr": {
            "type": "string",
            "nullable": true
          },
          "resourceName": {
            "type": "string",
            "nullable": true
          },
          "inputId": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "thumbnailUrl": {
            "type": "string",
            "nullable": true
          },
          "videoAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "nullable": true
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveInputModelLiveResultModel": {
        "type": "object",
        "properties": {
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveInputModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveInputNewModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "sourceCidr": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "isStandard": {
            "type": "boolean"
          },
          "videoAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "destinations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: RTMP_PUSH, URL_PULL, MP4_FILE",
            "nullable": true
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveEndpointInfoModel"
            },
            "description": "Gets or sets sources must be URLs and are only valid for input types: RTMP_PULL",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "NOTE: MediaConnect input creation not supported"
      },
      "LiveOperatorModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the live operator session.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the live operator session.",
            "nullable": true
          },
          "liveChannelType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of the live channel associated with this operator session.",
            "nullable": true
          },
          "liveRecordingStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current recording status of the live operator session.",
            "nullable": true
          },
          "liveContentStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the content status of the live operator session.",
            "nullable": true
          },
          "liveChannelStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the associated live channel.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference assigned to this operator session.",
            "nullable": true
          },
          "startRecordingTime": {
            "type": "string",
            "description": "Gets or sets the date and time when recording started.",
            "format": "date-time",
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live input source reference for the operator session.",
            "nullable": true
          },
          "segmentStartTime": {
            "type": "string",
            "description": "Gets or sets the date and time when the current segment started.",
            "format": "date-time",
            "nullable": true
          },
          "isCompleted": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the live operator session is completed.",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the output stream uses secure (signed) URLs.",
            "nullable": true
          },
          "isLiveChannelDynamic": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the live channel is dynamically allocated.",
            "nullable": true
          },
          "allowPostRollTransition": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether post-roll transition is allowed.",
            "nullable": true
          },
          "preRollAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the pre-roll asset played before the live stream starts.",
            "nullable": true
          },
          "postRollAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the post-roll asset played after the live stream ends.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags associated with the live operator session.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content references for the live operator session.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of collections the live operator session belongs to.",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of labels applied to the live operator session.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "description": "Gets or sets the status message describing the current state of the operator session.",
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetReferenceModel"
            },
            "description": "Gets or sets the list of recorded segments within the live operator session.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the system properties dictionary for the live operator session.",
            "nullable": true
          },
          "customProperties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the custom properties dictionary for the live operator session.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a live operator session with recording state, channel assignment, and metadata."
      },
      "LiveOutputProfileGroupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the output profile group.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the output profile group.",
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether we are enabled."
          },
          "manifestType": {
            "type": "string",
            "description": "Gets or sets acceptable values:\r\n- HLS\r\n- DASH\r\n- BOTH (assumes HLS and DASH",
            "nullable": true
          },
          "isDefaultGroup": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether if this is the default group,\r\nonly one default group is allowed at a time."
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output type for the assetgroup.",
            "nullable": true
          },
          "archiveOutputProfile": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the optional profile to use for archival operations.",
            "nullable": true
          },
          "outputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the required Live Output Profiles to use for this group.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a group of live output profiles with shared configuration."
      },
      "LiveOutputProfileModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the output profile.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the output profile.",
            "nullable": true
          },
          "videoCodec": {
            "type": "string",
            "description": "Gets or sets acceptable values:\r\n- {leave null/empty }\r\n- H264\r\n- H265",
            "nullable": true
          },
          "videoWidth": {
            "type": "integer",
            "description": "Gets or sets video output width. For example 1920.",
            "format": "int32",
            "nullable": true
          },
          "videoHeight": {
            "type": "integer",
            "description": "Gets or sets video output height. For example 1080.",
            "format": "int32",
            "nullable": true
          },
          "videoBitRateMode": {
            "type": "string",
            "description": "Gets or sets acceptable values:\r\n- {leave null/empty }\r\n- CBR\r\n- VBR",
            "nullable": true
          },
          "videoBitRate": {
            "type": "integer",
            "description": "Gets or sets the video bitrate in bytes. For example, 2mbps = 2048000.",
            "format": "int32",
            "nullable": true
          },
          "videoFramesPerSecond": {
            "type": "number",
            "description": "Gets or sets the video frames per second in decimal format. 29.97, 60.0 are some examples.",
            "format": "float",
            "nullable": true
          },
          "audioBitRate": {
            "type": "integer",
            "description": "Gets or sets the audio bitrate in bytes. For example, 128KB = 128000.",
            "format": "int32",
            "nullable": true
          },
          "outputType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output type from MediaLiveOutputTypes.",
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether we are enabled."
          },
          "outputUrl": {
            "type": "string",
            "description": "Gets or sets the primary output destination url for our MediaLive single output rendition only.",
            "nullable": true
          },
          "outputStreamKey": {
            "type": "string",
            "description": "Gets or sets the primary streamkey for our MediaLive output destination single output rendition only.",
            "nullable": true
          },
          "secondaryOutputUrl": {
            "type": "string",
            "description": "Gets or sets the secondary output destination url for our MediaLive single output rendition only.",
            "nullable": true
          },
          "secondaryOutputStreamKey": {
            "type": "string",
            "description": "Gets or sets the secondary streamkey for our MediaLive output destination single output rendition only.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a live output encoding profile with video and audio settings."
      },
      "LiveOutputProfileModelLiveResultModel": {
        "type": "object",
        "properties": {
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveOutputProfileModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleCopyModel": {
        "type": "object",
        "properties": {
          "recurringWeeks": {
            "type": "integer",
            "description": "Gets or sets the number of weeks the recurring schedule should repeat.",
            "format": "int32",
            "nullable": true
          },
          "recurringDays": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the days of the week on which the schedule should recur.",
            "nullable": true
          },
          "timeZoneOffsetSeconds": {
            "type": "integer",
            "description": "Gets or sets the time zone offset in seconds from UTC for scheduling.",
            "format": "int32",
            "nullable": true
          },
          "recurringEndDate": {
            "type": "string",
            "description": "Gets or sets the end date for the recurring schedule.",
            "format": "date-time",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for copying a live schedule with recurring options."
      },
      "LiveScheduleEditModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "description": "Gets or sets event reference.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the live schedule.",
            "nullable": true
          },
          "prerollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the pre-roll video asset played before the live stream starts.",
            "nullable": true
          },
          "postrollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the post-roll video asset played after the live stream ends.",
            "nullable": true
          },
          "slateVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the slate video asset displayed when no live content is available.",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the output stream uses secure (signed) URLs."
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the folder asset reference where archived recordings are stored.",
            "nullable": true
          },
          "primaryLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the primary live input source reference.",
            "nullable": true
          },
          "primaryLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the primary live stream input.",
            "nullable": true
          },
          "backupLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the backup live input source reference.",
            "nullable": true
          },
          "backupLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the backup live stream input.",
            "nullable": true
          },
          "liveScheduleStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the live schedule.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "description": "Gets or sets the status message describing the current state of the live schedule.",
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of external output profiles for the live schedule.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference assigned to this schedule.",
            "nullable": true
          },
          "overrideSettings": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to override the default channel settings.",
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output profile group reference for the live schedule.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for editing an existing live schedule. Inherits all properties from LiveScheduleModel."
      },
      "LiveScheduleEventEditModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "channelId": {
            "type": "string",
            "format": "uuid"
          },
          "thumbnail": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "startOffsetTimeCode": {
            "type": "string",
            "nullable": true
          },
          "fixedOnAirTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "durationTimeCode": {
            "type": "string",
            "nullable": true
          },
          "isLoop": {
            "type": "boolean"
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput2": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "previousId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "internalName": {
            "type": "string",
            "nullable": true
          },
          "channelId": {
            "type": "string",
            "format": "uuid"
          },
          "thumbnailUrl": {
            "type": "string",
            "nullable": true
          },
          "startOffsetTimeCode": {
            "type": "string",
            "nullable": true
          },
          "fixedOnAirTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "durationTimeCode": {
            "type": "string",
            "nullable": true
          },
          "isLoop": {
            "type": "boolean"
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput2": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "nullable": true
          },
          "startTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventMoveModel": {
        "type": "object",
        "properties": {
          "previousScheduleEventId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventNewModel": {
        "type": "object",
        "properties": {
          "previousId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "channelId": {
            "type": "string",
            "format": "uuid"
          },
          "startOffsetTimeCode": {
            "type": "string",
            "nullable": true
          },
          "fixedOnAirTimeUtc": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "durationTimeCode": {
            "type": "string",
            "nullable": true
          },
          "isLoop": {
            "type": "boolean"
          },
          "thumbnail": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "type": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          },
          "liveInput2": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleEventResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          },
          "requestId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "changeList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LiveScheduleEventModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LiveScheduleModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "description": "Gets or sets event reference.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the live schedule.",
            "nullable": true
          },
          "prerollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the pre-roll video asset played before the live stream starts.",
            "nullable": true
          },
          "postrollVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the post-roll video asset played after the live stream ends.",
            "nullable": true
          },
          "slateVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the slate video asset displayed when no live content is available.",
            "nullable": true
          },
          "isSecureOutput": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the output stream uses secure (signed) URLs."
          },
          "archiveFolderAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the folder asset reference where archived recordings are stored.",
            "nullable": true
          },
          "primaryLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the primary live input source reference.",
            "nullable": true
          },
          "primaryLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the primary live stream input.",
            "nullable": true
          },
          "backupLiveInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the backup live input source reference.",
            "nullable": true
          },
          "backupLiveStreamInputUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the backup live stream input.",
            "nullable": true
          },
          "liveScheduleStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the live schedule.",
            "nullable": true
          },
          "statusMessage": {
            "type": "string",
            "description": "Gets or sets the status message describing the current state of the live schedule.",
            "nullable": true
          },
          "externalOutputProfiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of external output profiles for the live schedule.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference assigned to this schedule.",
            "nullable": true
          },
          "overrideSettings": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to override the default channel settings.",
            "nullable": true
          },
          "outputProfileGroup": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the output profile group reference for the live schedule.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a live schedule with input sources, output configuration, and channel assignment."
      },
      "LocalRestoreModel": {
        "type": "object",
        "properties": {
          "sourceAssetIds": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the array of asset identifiers to restore from archive.",
            "nullable": true
          },
          "restoreProfileNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the array of restore profile names defining the target storage locations.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to restore assets from archive storage to a local storage profile."
      },
      "LoginCookieModel": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Gets or sets the URL path scope for the cookie.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the cookie.",
            "nullable": true
          },
          "expires": {
            "type": "string",
            "description": "Gets or sets the expiration date and time of the cookie.",
            "format": "date-time"
          },
          "value": {
            "type": "string",
            "description": "Gets or sets the value of the cookie.",
            "nullable": true
          },
          "domain": {
            "type": "string",
            "description": "Gets or sets the domain scope for the cookie.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a cookie returned from a successful login that the client should set in the browser."
      },
      "LoginRequestModel": {
        "required": [
          "password",
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the user's email address used as the login identifier. Required."
          },
          "password": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the user's current password. Required."
          },
          "token": {
            "type": "string",
            "description": "Gets or sets an authentication token, if available (e.g., for multi-factor authentication flows).",
            "nullable": true
          },
          "newPassword": {
            "type": "string",
            "description": "Gets or sets the new password to set if the account requires a password change on login.",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the application identifier the user is logging in from, used for session tracking.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for authenticating a user and obtaining a JWT access token."
      },
      "LoginResponseStatuses": {
        "enum": [
          "TwoFactorSetupRequired",
          "TwoFactorCodeRequired",
          "IsDisabled",
          "IsPendingEmailConfirmation",
          "IsPendingNewAccountSignup",
          "IsPendingAccountMigrationSignup",
          "IsPendingNewPassword",
          "IsExpired",
          "IsPendingInvitation"
        ],
        "type": "string",
        "description": "Indicates the result status of a login or account-related operation.\r\nReturned in the LoginStatus field of login and account response models.\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
        "x-enumNames": [
          "TwoFactorSetupRequired",
          "TwoFactorCodeRequired",
          "IsDisabled",
          "IsPendingEmailConfirmation",
          "IsPendingNewAccountSignup",
          "IsPendingAccountMigrationSignup",
          "IsPendingNewPassword",
          "IsExpired",
          "IsPendingInvitation"
        ]
      },
      "LogoutRequestModel": {
        "type": "object",
        "properties": {
          "userSessionId": {
            "type": "string",
            "description": "Gets or sets the identifier of the session to terminate.",
            "format": "uuid",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the application identifier associated with the session.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for logging out a user and ending their session."
      },
      "LookupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets primary key associated with model instance.",
            "format": "uuid"
          },
          "enumValue": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "lookupTypeId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "masterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "rankSeq": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "description2": {
            "type": "string",
            "nullable": true
          },
          "description3": {
            "type": "string",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LookupModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "LookupTypes": {
        "enum": [
          "PageTemplates",
          "Fields",
          "LookupTypes",
          "ContentTemplates",
          "ContentDefinitions",
          "ContentTypes",
          "ContentDefinitionGroups",
          "WorkflowStatuses",
          "DataSelectorContentDefinitions",
          "Content",
          "TemplatePacks",
          "PopularTags",
          "AllTags",
          "PropertyValues",
          "MediaTypes",
          "AssetTypes",
          "ContentFields",
          "FormSelectorContentDefinitions",
          "CustomRenderers",
          "ConstantContactCampaigns",
          "Languages",
          "SecurityGroups",
          "Collections",
          "SecurityPermissions",
          "CustomLabelerTypes",
          "CustomLabelerStatuses",
          "Labels",
          "Users",
          "MeetingSources",
          "LiveScheduleEventStatuses",
          "LiveExternalOutputProfiles",
          "LiveScheduleEventTypes",
          "LiveChannelStatuses",
          "LiveInputCodecs",
          "LiveInputMaximumBitrates",
          "LiveInputResolutions",
          "LiveInputStatuses",
          "LiveInputTypes",
          "NodeTypes",
          "LiveChannelTypes",
          "LiveOutputTypes",
          "Roles",
          "NewsSystems",
          "NprProfileTypes",
          "PaymentStatuses",
          "PingStatuses",
          "PropertyValueTypes",
          "ScheduleItemSearchTypes",
          "ScheduleItemSourceTypes",
          "ScheduleItemTypes",
          "ScheduleStatuses",
          "ScheduleTypes",
          "StorageClasses",
          "SubtitleTypes",
          "SubtitleValueTypes",
          "TextEntityTypes",
          "UploadOverwriteOptions",
          "UserSessionStatuses",
          "VideoSegmentTypes",
          "VideoTrackingEvents",
          "BatchActionProcessorExecutionTypes",
          "VideoTrackingAttributes",
          "TemplatePackTypes",
          "AdServerTypes",
          "AdSlotTypes",
          "AssetRestoreTiers",
          "AssetStatuses",
          "BatchActions",
          "BucketTypes",
          "CloudFrontDistributions",
          "ContentAttributes",
          "ContentLanguageStatuses",
          "ContentTextTypes",
          "ContentUnitOfWorkActions",
          "DataFilterFieldOperators",
          "DataIndexTypes",
          "DataJoinFilterFieldClauses",
          "DataPatchTypes",
          "DataSortHeading",
          "EmailTypes",
          "EndPointSystems",
          "FaceMatchTypes",
          "FeaturedContentTypes",
          "ImageTypes",
          "IvsChannelTypes",
          "IvsLatencyTypes",
          "JobProcessorActions",
          "LiveRequestActions",
          "LiveRequestTargets",
          "LoginResponseStatuses",
          "MediaConvertTypes",
          "MessageInfoTypes",
          "MetadataTypes",
          "ModelContainerModes",
          "DayOfWeek",
          "VideoTrackingActions",
          "FrameIngestActions",
          "ArchivePrefixTypes",
          "LiveRecordingStatuses",
          "LiveContentStatuses",
          "LiveScheduleStatuses",
          "ContentActionTypes",
          "LiveChannelRealtimeTypes",
          "MediaLiveOutputTypes",
          "TextCaptionTypes",
          "LiveStateUpdateModes",
          "MediaBuilderItemSourceTypes",
          "MediaBuilderStatuses",
          "LocalRestoreProfiles",
          "UserSessionTrackingTypes",
          "ShareDurationTypes",
          "Transcoders",
          "BulkIteratorStates",
          "ResourceClass",
          "ContentVersions",
          "ContentFieldClassifications",
          "ContentAttributeFlags",
          "ContentDataIndexTypes",
          "ImportActions",
          "ContentMutatorClassifications",
          "ShareTypes",
          "SharePermissions",
          "ShareStatuses",
          "SearchTextFields",
          "PropertyChangeTypes",
          "UploadReplaceOptions",
          "AdvanceSearchFields",
          "RollupMeasurementSourceTypes",
          "StatMeasurementAggregationOperationTypes",
          "Transcribers",
          "EmbeddingTypes",
          "AssetTransferStatuses",
          "VideoTrackingStatuses",
          "VideoTrackingAlertStatuses",
          "FrameStateFlags",
          "NewsRoomFailureTypes"
        ],
        "type": "string",
        "description": "\n\nPageTemplates\n\nFields\n\nLookupTypes\n\nContentTemplates\n\nContentDefinitions\n\nContentTypes\n\nContentDefinitionGroups\n\nWorkflowStatuses\n\nDataSelectorContentDefinitions\n\nContent\n\nTemplatePacks\n\nPopularTags\n\nAllTags\n\nPropertyValues\n\nMediaTypes\n\nAssetTypes\n\nContentFields\n\nFormSelectorContentDefinitions\n\nCustomRenderers\n\nConstantContactCampaigns\n\nLanguages\n\nSecurityGroups\n\nCollections\n\nSecurityPermissions\n\nCustomLabelerTypes\n\nCustomLabelerStatuses\n\nLabels\n\nUsers\n\nMeetingSources\n\nLiveScheduleEventStatuses\n\nLiveExternalOutputProfiles\n\nLiveScheduleEventTypes\n\nLiveChannelStatuses\n\nLiveInputCodecs\n\nLiveInputMaximumBitrates\n\nLiveInputResolutions\n\nLiveInputStatuses\n\nLiveInputTypes\n\nNodeTypes\n\nLiveChannelTypes\n\nLiveOutputTypes\n\nRoles\n\nNewsSystems\n\nNprProfileTypes\n\nPaymentStatuses\n\nPingStatuses\n\nPropertyValueTypes\n\nScheduleItemSearchTypes\n\nScheduleItemSourceTypes\n\nScheduleItemTypes\n\nScheduleStatuses\n\nScheduleTypes\n\nStorageClasses\n\nSubtitleTypes\n\nSubtitleValueTypes\n\nTextEntityTypes\n\nUploadOverwriteOptions\n\nUserSessionStatuses\n\nVideoSegmentTypes\n\nVideoTrackingEvents\n\nBatchActionProcessorExecutionTypes\n\nVideoTrackingAttributes\n\nTemplatePackTypes\n\nAdServerTypes\n\nAdSlotTypes\n\nAssetRestoreTiers\n\nAssetStatuses\n\nBatchActions\n\nBucketTypes\n\nCloudFrontDistributions\n\nContentAttributes\n\nContentLanguageStatuses\n\nContentTextTypes\n\nContentUnitOfWorkActions\n\nDataFilterFieldOperators\n\nDataIndexTypes\n\nDataJoinFilterFieldClauses\n\nDataPatchTypes\n\nDataSortHeading\n\nEmailTypes\n\nEndPointSystems\n\nFaceMatchTypes\n\nFeaturedContentTypes\n\nImageTypes\n\nIvsChannelTypes\n\nIvsLatencyTypes\n\nJobProcessorActions\n\nLiveRequestActions\n\nLiveRequestTargets\n\nLoginResponseStatuses\n\nMediaConvertTypes\n\nMessageInfoTypes\n\nMetadataTypes\n\nModelContainerModes\n\nDayOfWeek\n\nVideoTrackingActions\n\nFrameIngestActions\n\nArchivePrefixTypes\n\nLiveRecordingStatuses\n\nLiveContentStatuses\n\nLiveScheduleStatuses\n\nContentActionTypes\n\nLiveChannelRealtimeTypes\n\nMediaLiveOutputTypes\n\nTextCaptionTypes\n\nLiveStateUpdateModes\n\nMediaBuilderItemSourceTypes\n\nMediaBuilderStatuses\n\nLocalRestoreProfiles\n\nUserSessionTrackingTypes\n\nShareDurationTypes\n\nTranscoders\n\nBulkIteratorStates\n\nResourceClass\n\nContentVersions\n\nContentFieldClassifications\n\nContentAttributeFlags\n\nContentDataIndexTypes\n\nImportActions\n\nContentMutatorClassifications\n\nShareTypes\n\nSharePermissions\n\nShareStatuses\n\nSearchTextFields\n\nPropertyChangeTypes\n\nUploadReplaceOptions\n\nAdvanceSearchFields\n\nRollupMeasurementSourceTypes\n\nStatMeasurementAggregationOperationTypes\n\nTranscribers\n\nEmbeddingTypes\n\nAssetTransferStatuses\n\nVideoTrackingStatuses\n\nVideoTrackingAlertStatuses\n\nFrameStateFlags\n\nNewsRoomFailureTypes",
        "x-enumNames": [
          "PageTemplates",
          "Fields",
          "LookupTypes",
          "ContentTemplates",
          "ContentDefinitions",
          "ContentTypes",
          "ContentDefinitionGroups",
          "WorkflowStatuses",
          "DataSelectorContentDefinitions",
          "Content",
          "TemplatePacks",
          "PopularTags",
          "AllTags",
          "PropertyValues",
          "MediaTypes",
          "AssetTypes",
          "ContentFields",
          "FormSelectorContentDefinitions",
          "CustomRenderers",
          "ConstantContactCampaigns",
          "Languages",
          "SecurityGroups",
          "Collections",
          "SecurityPermissions",
          "CustomLabelerTypes",
          "CustomLabelerStatuses",
          "Labels",
          "Users",
          "MeetingSources",
          "LiveScheduleEventStatuses",
          "LiveExternalOutputProfiles",
          "LiveScheduleEventTypes",
          "LiveChannelStatuses",
          "LiveInputCodecs",
          "LiveInputMaximumBitrates",
          "LiveInputResolutions",
          "LiveInputStatuses",
          "LiveInputTypes",
          "NodeTypes",
          "LiveChannelTypes",
          "LiveOutputTypes",
          "Roles",
          "NewsSystems",
          "NprProfileTypes",
          "PaymentStatuses",
          "PingStatuses",
          "PropertyValueTypes",
          "ScheduleItemSearchTypes",
          "ScheduleItemSourceTypes",
          "ScheduleItemTypes",
          "ScheduleStatuses",
          "ScheduleTypes",
          "StorageClasses",
          "SubtitleTypes",
          "SubtitleValueTypes",
          "TextEntityTypes",
          "UploadOverwriteOptions",
          "UserSessionStatuses",
          "VideoSegmentTypes",
          "VideoTrackingEvents",
          "BatchActionProcessorExecutionTypes",
          "VideoTrackingAttributes",
          "TemplatePackTypes",
          "AdServerTypes",
          "AdSlotTypes",
          "AssetRestoreTiers",
          "AssetStatuses",
          "BatchActions",
          "BucketTypes",
          "CloudFrontDistributions",
          "ContentAttributes",
          "ContentLanguageStatuses",
          "ContentTextTypes",
          "ContentUnitOfWorkActions",
          "DataFilterFieldOperators",
          "DataIndexTypes",
          "DataJoinFilterFieldClauses",
          "DataPatchTypes",
          "DataSortHeading",
          "EmailTypes",
          "EndPointSystems",
          "FaceMatchTypes",
          "FeaturedContentTypes",
          "ImageTypes",
          "IvsChannelTypes",
          "IvsLatencyTypes",
          "JobProcessorActions",
          "LiveRequestActions",
          "LiveRequestTargets",
          "LoginResponseStatuses",
          "MediaConvertTypes",
          "MessageInfoTypes",
          "MetadataTypes",
          "ModelContainerModes",
          "DayOfWeek",
          "VideoTrackingActions",
          "FrameIngestActions",
          "ArchivePrefixTypes",
          "LiveRecordingStatuses",
          "LiveContentStatuses",
          "LiveScheduleStatuses",
          "ContentActionTypes",
          "LiveChannelRealtimeTypes",
          "MediaLiveOutputTypes",
          "TextCaptionTypes",
          "LiveStateUpdateModes",
          "MediaBuilderItemSourceTypes",
          "MediaBuilderStatuses",
          "LocalRestoreProfiles",
          "UserSessionTrackingTypes",
          "ShareDurationTypes",
          "Transcoders",
          "BulkIteratorStates",
          "ResourceClass",
          "ContentVersions",
          "ContentFieldClassifications",
          "ContentAttributeFlags",
          "ContentDataIndexTypes",
          "ImportActions",
          "ContentMutatorClassifications",
          "ShareTypes",
          "SharePermissions",
          "ShareStatuses",
          "SearchTextFields",
          "PropertyChangeTypes",
          "UploadReplaceOptions",
          "AdvanceSearchFields",
          "RollupMeasurementSourceTypes",
          "StatMeasurementAggregationOperationTypes",
          "Transcribers",
          "EmbeddingTypes",
          "AssetTransferStatuses",
          "VideoTrackingStatuses",
          "VideoTrackingAlertStatuses",
          "FrameStateFlags",
          "NewsRoomFailureTypes"
        ]
      },
      "MeasurementInfo": {
        "type": "object",
        "properties": {
          "domain": {
            "type": "string",
            "description": "Gets or sets the domain or category that this measurement belongs to.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the measurement.",
            "nullable": true
          },
          "groupingFieldNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of field names available for grouping results.",
            "nullable": true
          },
          "predefinedStackMemberships": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of predefined stack membership names available for this measurement.",
            "nullable": true
          },
          "scaleFactors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScaleFactor"
            },
            "description": "Gets or sets the list of scale factors available for this measurement.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents metadata about a single measurement, including its domain, grouping fields, and scale factors."
      },
      "MeasurementRequest": {
        "type": "object",
        "properties": {
          "measurementName": {
            "type": "string",
            "description": "Gets or sets the name of the measurement to retrieve.",
            "nullable": true
          },
          "groupingFields": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of field names to group the measurement results by.",
            "nullable": true
          },
          "stackName": {
            "type": "string",
            "description": "Gets or sets the stack name for grouping datasets in stacked chart visualizations.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a single measurement request within a statistics query, specifying the metric name, grouping, and stacking."
      },
      "MediaBuilderRenderModel": {
        "type": "object",
        "properties": {
          "mediaBuilderId": {
            "type": "string",
            "description": "Gets or sets the identifier of the media builder template to use for rendering.",
            "format": "uuid"
          },
          "sources": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MediaBuilderSourceModel"
            },
            "description": "Gets or sets the array of source assets to include in the rendered output.",
            "nullable": true
          },
          "title": {
            "type": "string",
            "description": "Gets or sets the title of the rendered output asset.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of tags to apply to the rendered output asset.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of collections to assign the rendered output asset to.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of related content items to link to the rendered output asset.",
            "nullable": true
          },
          "destinationFolderId": {
            "type": "string",
            "description": "Gets or sets the identifier of the destination folder where the rendered output will be placed.",
            "format": "uuid"
          },
          "videoBitrate": {
            "type": "integer",
            "description": "Gets or sets the optional video bitrate in bits per second for the rendered output.",
            "format": "int32",
            "nullable": true
          },
          "audioTracks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AudioTrackModel"
            },
            "description": "Gets or sets the array of audio track configurations for the rendered output.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to render a media composition from one or more source assets into a new output asset."
      },
      "MediaBuilderSourceModel": {
        "type": "object",
        "properties": {
          "sourceAssetId": {
            "type": "string",
            "format": "uuid"
          },
          "startTimeCode": {
            "type": "string",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MediaTypes": {
        "enum": [
          "Image",
          "Video",
          "Document",
          "Text",
          "Audio",
          "Other",
          "MediaManifest"
        ],
        "type": "string",
        "description": "\n\nImage\n\nVideo\n\nDocument\n\nText\n\nAudio\n\nOther\n\nMediaManifest",
        "x-enumNames": [
          "Image",
          "Video",
          "Document",
          "Text",
          "Audio",
          "Other",
          "MediaManifest"
        ]
      },
      "MetadataTypes": {
        "enum": [
          "DocumentContent",
          "ComprehendKeyPhrases",
          "ComprehendEntities",
          "RekognitionImageIndexFaces",
          "RekognitionImageSearchFaces",
          "RekognitionImageLabels",
          "RekognitionImageCelebrityRecognition",
          "RekognitionVideoLabels",
          "TextractAnalyzeDocument",
          "Transcribe",
          "TranscribeVtt",
          "TranscribeTranslation",
          "TranscribeVttTranslation",
          "RekognitionVideoCelebrityRecognition",
          "RekognitionVideoPersonTracking",
          "RekognitionVideoFaceDetection",
          "ImageInfo",
          "Transcode",
          "Clip",
          "MediaInfo",
          "RekognitionImageDetectText",
          "RekognitionImageUnsafeContent",
          "RekognitionVideoUnsafeContent",
          "Screenshot",
          "SageMakerGroundTruthLabelResults",
          "ThumbnailSheet",
          "ThumbnailImage",
          "SageMakerInvokeEndpointResults",
          "SageMakerModelLabels",
          "RekognitionImageCustomLabels",
          "SageMakerManifest",
          "PreviewImage",
          "RekognitionVideoTextDetection",
          "RekognitionVideoSegmentDetection",
          "NomadVideoSegmentDetection",
          "TranscribeMedical",
          "PreviewAudio",
          "Text",
          "AssetManifest",
          "IntervalSegments",
          "TranscribeMedicalText",
          "TranscribeMedicalTranslation",
          "AdobeMetadata",
          "AdobeMetadataText",
          "ImageExif",
          "TextractImageDetectText",
          "AdSegments",
          "Vmap",
          "Vast",
          "MediaTailorVideo",
          "TranscribeSrt",
          "TranscribeRaw",
          "Subtitles",
          "VizRtMetadata",
          "ProcessorJobs",
          "OfficeDocument",
          "TranscriptionContainer",
          "ComprehendSentiment",
          "ComprehendLanguage",
          "OriginalSourceVideo",
          "ImportManifest",
          "TranscribeScc",
          "TranscribeTtml",
          "TranscribeDfxp",
          "TranscribeSmptett",
          "TranscribeXml",
          "TranscribeQt",
          "TranscribeRt",
          "TranscribeSsa",
          "TranscribeAss",
          "TranscribeSbv",
          "TranscribeSmi",
          "TranscribeSami",
          "TranscribeStl",
          "TranscribeSub",
          "AssociatedAsset",
          "MobiusLabsImageLabels",
          "MobiusLabsVideoAnalysis",
          "ContactSheetVTT",
          "ContactSheetTimecodes",
          "ContactSheetImage",
          "RenderedImage",
          "RokuBif",
          "MobiusLabsVideoExtractFeatures",
          "AzureImageAnalysis",
          "AzureImageVectorize",
          "AzureTextVectorize",
          "ContentVectors",
          "SceneXDescribe",
          "MobiusLabsLabelsExtractFeatures",
          "SportLogiqVideoAnalysis",
          "OciImageCaption",
          "OciTextVectorizer",
          "AnimatedGif",
          "OciTextSummary",
          "NomadMediaTasks",
          "GooglePhotosMetadata",
          "SageMakerImageToText",
          "TwelveLabsVideoAnalysis",
          "AccurateRegister",
          "BedrockImageAnalysis",
          "BedrockTextVectorizer",
          "BedrockImageVectorize",
          "BedrockTextSummary",
          "GeneratedImage",
          "TranscodeIvsRecording",
          "DolbyRaspRegister",
          "MobiusLabsLlmVideoAnalysis",
          "MobiusLabsLlmImageAnalysis",
          "TranscriptSummary",
          "SearchCache",
          "WhisperTranscription",
          "BitmovinSceneDetection",
          "BedrockDataAutomation",
          "BedrockSceneDetection",
          "MobiusLabsLlmSegmentContent",
          "AudioWaveform",
          "CustomType"
        ],
        "type": "string",
        "description": "Note that this is a PARTIAL list of types that we need to know about\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
        "x-enumNames": [
          "DocumentContent",
          "ComprehendKeyPhrases",
          "ComprehendEntities",
          "RekognitionImageIndexFaces",
          "RekognitionImageSearchFaces",
          "RekognitionImageLabels",
          "RekognitionImageCelebrityRecognition",
          "RekognitionVideoLabels",
          "TextractAnalyzeDocument",
          "Transcribe",
          "TranscribeVtt",
          "TranscribeTranslation",
          "TranscribeVttTranslation",
          "RekognitionVideoCelebrityRecognition",
          "RekognitionVideoPersonTracking",
          "RekognitionVideoFaceDetection",
          "ImageInfo",
          "Transcode",
          "Clip",
          "MediaInfo",
          "RekognitionImageDetectText",
          "RekognitionImageUnsafeContent",
          "RekognitionVideoUnsafeContent",
          "Screenshot",
          "SageMakerGroundTruthLabelResults",
          "ThumbnailSheet",
          "ThumbnailImage",
          "SageMakerInvokeEndpointResults",
          "SageMakerModelLabels",
          "RekognitionImageCustomLabels",
          "SageMakerManifest",
          "PreviewImage",
          "RekognitionVideoTextDetection",
          "RekognitionVideoSegmentDetection",
          "NomadVideoSegmentDetection",
          "TranscribeMedical",
          "PreviewAudio",
          "Text",
          "AssetManifest",
          "IntervalSegments",
          "TranscribeMedicalText",
          "TranscribeMedicalTranslation",
          "AdobeMetadata",
          "AdobeMetadataText",
          "ImageExif",
          "TextractImageDetectText",
          "AdSegments",
          "Vmap",
          "Vast",
          "MediaTailorVideo",
          "TranscribeSrt",
          "TranscribeRaw",
          "Subtitles",
          "VizRtMetadata",
          "ProcessorJobs",
          "OfficeDocument",
          "TranscriptionContainer",
          "ComprehendSentiment",
          "ComprehendLanguage",
          "OriginalSourceVideo",
          "ImportManifest",
          "TranscribeScc",
          "TranscribeTtml",
          "TranscribeDfxp",
          "TranscribeSmptett",
          "TranscribeXml",
          "TranscribeQt",
          "TranscribeRt",
          "TranscribeSsa",
          "TranscribeAss",
          "TranscribeSbv",
          "TranscribeSmi",
          "TranscribeSami",
          "TranscribeStl",
          "TranscribeSub",
          "AssociatedAsset",
          "MobiusLabsImageLabels",
          "MobiusLabsVideoAnalysis",
          "ContactSheetVTT",
          "ContactSheetTimecodes",
          "ContactSheetImage",
          "RenderedImage",
          "RokuBif",
          "MobiusLabsVideoExtractFeatures",
          "AzureImageAnalysis",
          "AzureImageVectorize",
          "AzureTextVectorize",
          "ContentVectors",
          "SceneXDescribe",
          "MobiusLabsLabelsExtractFeatures",
          "SportLogiqVideoAnalysis",
          "OciImageCaption",
          "OciTextVectorizer",
          "AnimatedGif",
          "OciTextSummary",
          "NomadMediaTasks",
          "GooglePhotosMetadata",
          "SageMakerImageToText",
          "TwelveLabsVideoAnalysis",
          "AccurateRegister",
          "BedrockImageAnalysis",
          "BedrockTextVectorizer",
          "BedrockImageVectorize",
          "BedrockTextSummary",
          "GeneratedImage",
          "TranscodeIvsRecording",
          "DolbyRaspRegister",
          "MobiusLabsLlmVideoAnalysis",
          "MobiusLabsLlmImageAnalysis",
          "TranscriptSummary",
          "SearchCache",
          "WhisperTranscription",
          "BitmovinSceneDetection",
          "BedrockDataAutomation",
          "BedrockSceneDetection",
          "MobiusLabsLlmSegmentContent",
          "AudioWaveform",
          "CustomType"
        ]
      },
      "MobiusLabsWebhookResponseModel": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "Gets the status.\r\nreturn success (Ok, 200) from the controller",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "The mobius labs webhook response model."
      },
      "NomadTranscriptionModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "format": "uuid"
          },
          "status": {
            "type": "string",
            "description": "Gets or Sets the Status, one-of(\"COMPLETE\" || \"FAILED\").",
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "nullable": true
          },
          "accessKey": {
            "type": "string",
            "nullable": true
          },
          "relatedAssetId": {
            "type": "string",
            "format": "uuid"
          },
          "jobName": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PersonFaceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of this face detection result.",
            "format": "uuid"
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the asset (image) containing this face.",
            "format": "uuid"
          },
          "segmentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the video segment where this face was detected, if applicable.",
            "format": "uuid",
            "nullable": true
          },
          "videoAssetId": {
            "type": "string",
            "description": "Gets or sets the identifier of the source video asset, if the face was detected in a video.",
            "format": "uuid",
            "nullable": true
          },
          "similarity": {
            "type": "number",
            "description": "Gets or sets the similarity score (0.0 to 100.0) indicating how closely this face matches the person.",
            "format": "double"
          },
          "boundingBox": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BoundingBoxModel"
              }
            ],
            "description": "Gets or sets the bounding box coordinates of the detected face within the image.",
            "nullable": true
          },
          "rotationCorrection": {
            "type": "integer",
            "description": "Gets or sets the rotation correction in degrees applied to normalize the face orientation.",
            "format": "int32",
            "nullable": true
          },
          "previewImageUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the cropped preview image of the detected face.",
            "nullable": true
          },
          "previewImageHeight": {
            "type": "integer",
            "description": "Gets or sets the height in pixels of the preview image.",
            "format": "int32"
          },
          "previewImageWidth": {
            "type": "integer",
            "description": "Gets or sets the width in pixels of the preview image.",
            "format": "int32"
          },
          "displayName": {
            "type": "string",
            "description": "Gets or sets the display name associated with this face detection.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PersonFaceModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PersonFaceModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PersonFaceModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "PersonModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the person.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the person",
            "nullable": true
          },
          "automatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that are automatched for this person",
            "format": "int32",
            "nullable": true
          },
          "probableMatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that have been identified as probable matches for this person",
            "format": "int32",
            "nullable": true
          },
          "confirmedMatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that have been marked as confirmed for this person",
            "format": "int32",
            "nullable": true
          },
          "notMatchFaceCount": {
            "type": "integer",
            "description": "Gets or sets the count of faces that have been marked as not a match for this person",
            "format": "int32",
            "nullable": true
          },
          "celebrityConfidence": {
            "type": "number",
            "description": "Gets or sets the % confidence of the celebrity name that was automatically detected through AI",
            "format": "float",
            "nullable": true
          },
          "celebrityExternalId": {
            "type": "string",
            "description": "Gets or sets the external (usually IMDB) ID of the celebrity that was identified",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PersonReferenceModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "confidence": {
            "type": "number",
            "format": "double"
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PersonSubmitModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the person. Must be unique. Required.",
            "nullable": true
          },
          "matchedFaces": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of face IDs that match this person. This list contains only changed faces that have become matched.",
            "nullable": true
          },
          "unmatchedFaces": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of face IDs that do not match this person. This list contains only changed faces that have become not matched.",
            "nullable": true
          },
          "blurryFaces": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of face IDs that are blurry. This list contains only changed faces that are marked as blurry.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PhenixChannelEntity": {
        "type": "object",
        "properties": {
          "alias": {
            "type": "string",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "type": "string",
            "nullable": true
          },
          "streamKey": {
            "type": "string",
            "nullable": true
          },
          "created": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "lastUpdate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "estimatedSize": {
            "nullable": true
          },
          "options": {
            "type": "array",
            "items": { },
            "nullable": true
          },
          "channelId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PhenixChannelRequestModel": {
        "type": "object",
        "properties": {
          "channel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PhenixChannelEntity"
              }
            ],
            "description": "Gets or sets the channel entity containing the channel configuration details.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the request model for creating a Phenix channel."
      },
      "PhenixWebhookRegistrationModel": {
        "type": "object",
        "properties": {
          "callback": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Callback"
              }
            ],
            "description": "Gets or sets the callback configuration for the webhook endpoint.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the configuration for registering a webhook on the Phenix RTS platform."
      },
      "PingRequestModel": {
        "type": "object",
        "properties": {
          "userSessionId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the active user session to keep alive.",
            "format": "uuid"
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the optional application identifier associated with the session.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for the session ping/keep-alive endpoint."
      },
      "PingResponseModel": {
        "type": "object",
        "properties": {
          "redirectUrl": {
            "type": "string",
            "description": "Gets or sets a URL the client should redirect to, if applicable (e.g., when the session has expired or been replaced).",
            "nullable": true
          },
          "pingStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PingStatuses"
              }
            ],
            "description": "Gets or sets the status of the session ping. Normal indicates the session is active.\r\nAccountExpired or SessionReplaced indicate the client should terminate the session.\n\nNormal\n\nChatDisabled\n\nAccountExpired\n\nSessionDeactivated",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Response model for the session ping/keep-alive endpoint."
      },
      "PingStatuses": {
        "enum": [
          "Normal",
          "ChatDisabled",
          "AccountExpired",
          "SessionDeactivated"
        ],
        "type": "string",
        "description": "Indicates the status returned from a session ping/keep-alive request.\n\nNormal\n\nChatDisabled\n\nAccountExpired\n\nSessionDeactivated",
        "x-enumNames": [
          "Normal",
          "ChatDisabled",
          "AccountExpired",
          "SessionDeactivated"
        ]
      },
      "ProblemDetails": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "detail": {
            "type": "string",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": { }
      },
      "PropertyChangeTypes": {
        "enum": [
          "Replace",
          "Clear"
        ],
        "type": "string",
        "description": "\n\nReplace\n\nClear",
        "x-enumNames": [
          "Replace",
          "Clear"
        ]
      },
      "PublishScheduleRequestModel": {
        "required": [
          "numberOfLockedDays"
        ],
        "type": "object",
        "properties": {
          "scheduleId": {
            "type": "string",
            "description": "Gets or sets schedule Id",
            "format": "uuid"
          },
          "numberOfLockedDays": {
            "type": "integer",
            "description": "Gets or sets number of days to lock schedule",
            "format": "int32"
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to publish a schedule, locking it for a specified number of days."
      },
      "Red5AuthRequestModel": {
        "type": "object",
        "properties": {
          "userName": {
            "type": "string",
            "description": "Gets or sets the username for Red5 authentication.",
            "nullable": true
          },
          "password": {
            "type": "string",
            "description": "Gets or sets the password for Red5 authentication.",
            "nullable": true
          },
          "token": {
            "type": "string",
            "description": "Gets or sets the authentication token provided by the Red5 platform.",
            "nullable": true
          },
          "type": {
            "type": "string",
            "description": "Gets or sets the type of authentication request (e.g., publish, subscribe).",
            "nullable": true
          },
          "streamId": {
            "type": "string",
            "description": "Gets or sets the identifier of the stream being authenticated.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the authentication request from the Red5 streaming platform."
      },
      "Red5AuthResponseModel": {
        "type": "object",
        "properties": {
          "result": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the authentication was successful."
          },
          "url": {
            "type": "string",
            "description": "Gets or sets an optional arbitrary URL returned with the authentication response.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the authentication response to the Red5 streaming platform."
      },
      "Red5StatusRequestModel": {
        "type": "object",
        "properties": {
          "event": {
            "type": "string",
            "description": "Gets or sets the event type that triggered the status update.",
            "nullable": true
          },
          "channel": {
            "type": "string",
            "description": "Gets or sets the channel identifier associated with the status event.",
            "nullable": true
          },
          "clusterNodeType": {
            "type": "string",
            "description": "Gets or sets the type of cluster node reporting the status.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a status update webhook request from the Red5 streaming platform."
      },
      "Red5StatusResponseModel": {
        "type": "object",
        "additionalProperties": false,
        "description": "Represents the response to a Red5 status webhook."
      },
      "RefreshTokenRequestModel": {
        "required": [
          "refreshToken"
        ],
        "type": "object",
        "properties": {
          "refreshToken": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the refresh token obtained from a previous login or token refresh response. Required."
          }
        },
        "additionalProperties": false,
        "description": "Request model for exchanging a refresh token for a new JWT access token."
      },
      "RegisterAssetModel": {
        "required": [
          "bucketName",
          "objectKey"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier for the asset; if null, a new identifier will be generated.",
            "format": "uuid",
            "nullable": true
          },
          "parentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the parent folder where the asset should be placed.",
            "format": "uuid",
            "nullable": true
          },
          "displayObjectKey": {
            "type": "string",
            "description": "Gets or sets the display-friendly version of the storage object key.",
            "nullable": true
          },
          "bucketName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the name of the storage bucket where the asset is stored."
          },
          "objectKey": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the object key that uniquely identifies the asset within the storage bucket."
          },
          "eTag": {
            "type": "string",
            "description": "Gets or sets the entity tag used to verify asset integrity.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of tag names to associate with the asset.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of collection names to associate with the asset.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of related content identifiers to link to the asset.",
            "nullable": true
          },
          "customAttributes": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the dictionary of user-defined custom attributes for the asset.",
            "nullable": true,
            "readOnly": true
          },
          "sequencer": {
            "type": "string",
            "description": "Gets or sets the sequencer value used for ordering storage events.",
            "nullable": true
          },
          "assetStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetStatuses"
              }
            ],
            "description": "Gets or sets the initial processing or lifecycle status of the asset.\n\nAvailable\n\nRenaming\n\nCopying\n\nRestoring\n\nRegistering\n\nUploading\n\nArchiving\n\nArchived\n\nPendingArchive\n\nPendingRestore\n\nRestored\n\nDeleting\n\nMoving\n\nSlugReplaced\n\nUpdating\n\nError\n\nAssembling\n\nClipping\n\nPlaceholder\n\nCreating\n\nReplacing",
            "nullable": true
          },
          "storageClass": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StorageClasses"
              }
            ],
            "description": "Gets or sets the storage class tier for the asset.\n\nStandard\n\nReducedRedundancy\n\nGlacier\n\nStandardInfrequentAccess\n\nOneZoneInfrequentAccess\n\nIntelligentTiering\n\nDeepArchive\n\nGlacierInstantRetrieval\n\nOutposts",
            "nullable": true
          },
          "assetType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetTypes"
              }
            ],
            "description": "Gets or sets the type classification of the asset (e.g., video, image, audio, document).\n\nFolder\n\nFile\n\nBucket",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "description": "Gets or sets the file size of the asset in bytes.",
            "format": "int64",
            "nullable": true
          },
          "storageEventName": {
            "type": "string",
            "description": "Gets or sets the name of the storage event that triggered the registration.",
            "nullable": true
          },
          "createdDate": {
            "type": "string",
            "description": "Gets or sets the date when the asset was originally created.",
            "format": "date-time",
            "nullable": true
          },
          "storageSourceIpAddress": {
            "type": "string",
            "description": "Gets or sets the IP address of the source that initiated the storage event.",
            "nullable": true
          },
          "externalAssetLocation": {
            "type": "string",
            "description": "Gets or sets the external URL or path where the asset is located outside the system.",
            "nullable": true
          },
          "startMediaProcessor": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the media processor should be started after registration."
          },
          "deleteMissingAsset": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to delete the asset record if the underlying file is missing."
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to register a new asset or update an existing asset in the system."
      },
      "RelatedAssetUploadStartRequestModel": {
        "type": "object",
        "properties": {
          "existingAssetId": {
            "type": "string",
            "description": "Gets or sets the Existing AssetId (file) that should be overwritten with this upload.\r\nNote that by specifying this attribute then the parentId, relativePath and displayName are all ignored.",
            "format": "uuid",
            "nullable": true
          },
          "relatedAssetId": {
            "type": "string",
            "description": "Gets or sets the related asset ID of the existingAsset that we're replacing. If this is used, most of the other properties are not needed.",
            "format": "uuid",
            "nullable": true
          },
          "newRelatedAssetMetadataType": {
            "type": "string",
            "description": "Gets or sets the type of the related asset metadata to be created for a given ExistingAssetId.\r\nIf specified, ExistingAssetId has to have a value defined.",
            "format": "uuid",
            "nullable": true
          },
          "relativePath": {
            "type": "string",
            "description": "Gets or sets the filename to upload - or a full path with the filename at the end.\r\nThis is ignored if the ExistingAssetId or if the RelatedContentId has a value",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "description": "Gets or sets the language of the asset to upload. If this is left blank then the default system language is used.",
            "format": "uuid",
            "nullable": true
          },
          "contentLength": {
            "type": "integer",
            "description": "Gets or sets the size of the asset to upload. This is used to calculate the upload parts.",
            "format": "int64"
          },
          "chunkSize": {
            "type": "integer",
            "description": "Gets or sets the size of the upload chunks. This should be adjusted to optimize the upload size based on the user's internet connection.",
            "format": "int64"
          },
          "uploadOverwriteOption": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UploadOverwriteOptions"
              }
            ],
            "description": "Gets or sets if the file already exists on the server, this decides how to handle the situation\n\nCancel\n\nContinue\n\nReplace\n\nAssetReplace",
            "x-enumNames": [
              "Cancel",
              "Continue",
              "Replace",
              "AssetReplace"
            ]
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties for the uploaded file",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to initiate an upload for a related asset, such as a sidecar file or alternate rendition."
      },
      "RelatedContentModel": {
        "type": "object",
        "properties": {
          "contentDefinition": {
            "type": "string",
            "description": "Gets or sets the content definition string name of the content records that should be affected\r\nLike asset, video, etc",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the ID of the content record to apply the new or removed attributes",
            "format": "uuid"
          },
          "createNew": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether defaults to False. If true, then the attribute will be added if it doesn't already exist with a matching name"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the collection that should be added or removed. If the name and the collectionId are both specified, the name is ignored.",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets the id of the metadata content defintion, i.e. tags, collections",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "relatedContentId": {
            "type": "string",
            "description": "Gets or sets the related content ID that should be added or removed",
            "format": "uuid"
          },
          "childId": {
            "type": "string",
            "description": "Gets the child identifier, which is the related content identifier.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "childPropertyName": {
            "type": "string",
            "description": "Gets the name of the child property used for serialization.",
            "nullable": true,
            "readOnly": true
          },
          "indexPropertyName": {
            "type": "string",
            "description": "Gets the name of the index property used in search indexing.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the association between a content item and a related content item, used for linking or unlinking related content."
      },
      "RelatedContentModelListModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RelatedContentModel"
            },
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "RenderSubtitlesModel": {
        "type": "object",
        "properties": {
          "showTimestamps": {
            "type": "boolean"
          },
          "showSpeakers": {
            "type": "boolean"
          },
          "useActualTime": {
            "type": "boolean"
          },
          "exportFormat": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TranscriptionContainerOutputTypes"
              }
            ],
            "description": "\n\n0 = DocX\n\n1 = Text\n\n2 = SRT\n\n3 = VTT",
            "x-enumNames": [
              "DocX",
              "Text",
              "SRT",
              "VTT"
            ]
          },
          "textTimePrefix": {
            "type": "string",
            "nullable": true
          },
          "textTimeSuffix": {
            "type": "string",
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "format": "uuid"
          }
        },
        "additionalProperties": false
      },
      "ResendConfirmationCodeRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to re-send the verification code to. Required."
          }
        },
        "additionalProperties": false,
        "description": "Request model for re-sending the email verification confirmation code."
      },
      "ResetPasswordRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to reset. Required."
          },
          "token": {
            "type": "string",
            "description": "Gets or sets the verification code received via the forgot-password email.",
            "nullable": true
          },
          "newPassword": {
            "type": "string",
            "description": "Gets or sets the new password to set for the account.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for completing a password reset using a verification code."
      },
      "ResponseCookieWrapper": {
        "type": "object",
        "properties": {
          "internalCookies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets the list of cookie strings intended for internal processing and not included in serialized output.",
            "nullable": true,
            "readOnly": true
          },
          "responseCookies": {
            "description": "Gets the response body object that will be serialized and returned to the caller.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Wraps a response object along with associated cookies to be set on the HTTP response."
      },
      "ScaleFactor": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "value": {
            "type": "number",
            "format": "double"
          },
          "rankSeq": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ScheduleGuideModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the schedule guide entry.",
            "format": "uuid",
            "nullable": true
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the asset reference associated with this guide entry.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference for this guide entry.",
            "nullable": true
          },
          "scheduleItem": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the schedule item reference that this guide entry corresponds to.",
            "nullable": true
          },
          "startTime": {
            "type": "string",
            "description": "Gets or sets the local start time of the guide entry.",
            "format": "date-time",
            "nullable": true
          },
          "startTimeUtc": {
            "type": "string",
            "description": "Gets or sets the UTC start time of the guide entry.",
            "format": "date-time",
            "nullable": true
          },
          "duration": {
            "type": "string",
            "description": "Gets or sets the duration of the guide entry as a formatted string.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the guide entry.",
            "nullable": true
          },
          "sourceName": {
            "type": "string",
            "description": "Gets or sets the name of the source providing the content for this guide entry.",
            "nullable": true
          },
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the start time code for the guide entry.",
            "nullable": true
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the end time code for the guide entry.",
            "nullable": true
          },
          "dayId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the day identifier indicating which day of the week this guide entry applies to.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an entry in a schedule guide (EPG), providing time slot and content details for display."
      },
      "ScheduleItemChangeModel": {
        "type": "object",
        "properties": {
          "scheduleItemId": {
            "type": "string",
            "description": "Gets or sets the identifier of the schedule item being changed.",
            "format": "uuid"
          },
          "changedList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduleItemModel"
            },
            "description": "Gets or sets the list of schedule items that were affected by the change.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to change a schedule item along with the resulting list of affected items."
      },
      "ScheduleItemModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the schedule item.",
            "format": "uuid"
          },
          "previousItem": {
            "type": "string",
            "description": "Gets or sets the identifier of the preceding item in the schedule order.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the schedule item.",
            "nullable": true
          },
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the start time code for the schedule item.",
            "nullable": true
          },
          "asset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the asset reference associated with this schedule item.",
            "nullable": true
          },
          "scheduleItemType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleItemTypes"
              }
            ],
            "description": "Gets or sets the type of the schedule item.\n\nAsset\n\nDynamic",
            "x-enumNames": [
              "Asset",
              "Dynamic"
            ]
          },
          "scheduleId": {
            "type": "string",
            "description": "Gets or sets the identifier of the parent schedule this item belongs to.",
            "format": "uuid"
          },
          "endTimeCode": {
            "type": "string",
            "description": "Gets or sets the end time code for the schedule item.",
            "nullable": true
          },
          "days": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of days on which this schedule item is active.",
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the tags associated with this schedule item.",
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the related content items linked to this schedule item.",
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the collections this schedule item belongs to.",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the labels assigned to this schedule item.",
            "nullable": true
          },
          "playlistSchedule": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the playlist schedule associated with this item.",
            "nullable": true
          },
          "liveChannel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the live channel reference for this schedule item.",
            "nullable": true
          },
          "defaultVideo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the default video asset reference used as a fallback.",
            "nullable": true
          },
          "thumbnailAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the thumbnail asset reference for this schedule item.",
            "nullable": true
          },
          "searchFilterType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleItemSearchTypes"
              }
            ],
            "description": "Gets or sets the search filter type used to select content for this item.\n\nRandom\n\nRandomWithinDateRange\n\nNewest\n\nNewestNotPlayed",
            "nullable": true
          },
          "sourceType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleItemSourceTypes"
              }
            ],
            "description": "Gets or sets the source type indicating where the schedule item content originates.\n\nPlaylistSchedule\n\nSearchFilters\n\nVideoAsset\n\nLiveChannel",
            "nullable": true
          },
          "searchDurationInMinutes": {
            "type": "integer",
            "description": "Gets or sets the search duration in minutes for filtering content by time window.",
            "format": "int32",
            "nullable": true
          },
          "endSearchDurationInMinutes": {
            "type": "integer",
            "description": "Gets or sets the end search duration in minutes for the content time window.",
            "format": "int32",
            "nullable": true
          },
          "searchDate": {
            "type": "string",
            "description": "Gets or sets the start date for search-based content filtering.",
            "format": "date-time",
            "nullable": true
          },
          "endSearchDate": {
            "type": "string",
            "description": "Gets or sets the end date for search-based content filtering.",
            "format": "date-time",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties associated with the schedule item.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an individual item within a schedule, including its time slot, associated asset, and metadata."
      },
      "ScheduleItemMoveModel": {
        "type": "object",
        "properties": {
          "previousItem": {
            "type": "string",
            "description": "Gets or sets the identifier of the item that should precede the moved item in the new position.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to move a schedule item to a new position in the schedule order."
      },
      "ScheduleItemSearchTypes": {
        "enum": [
          "Random",
          "RandomWithinDateRange",
          "Newest",
          "NewestNotPlayed"
        ],
        "type": "string",
        "description": "\n\nRandom\n\nRandomWithinDateRange\n\nNewest\n\nNewestNotPlayed",
        "x-enumNames": [
          "Random",
          "RandomWithinDateRange",
          "Newest",
          "NewestNotPlayed"
        ]
      },
      "ScheduleItemSourceTypes": {
        "enum": [
          "PlaylistSchedule",
          "SearchFilters",
          "VideoAsset",
          "LiveChannel"
        ],
        "type": "string",
        "description": "\n\nPlaylistSchedule\n\nSearchFilters\n\nVideoAsset\n\nLiveChannel",
        "x-enumNames": [
          "PlaylistSchedule",
          "SearchFilters",
          "VideoAsset",
          "LiveChannel"
        ]
      },
      "ScheduleItemTypes": {
        "enum": [
          "Asset",
          "Dynamic"
        ],
        "type": "string",
        "description": "\n\nAsset\n\nDynamic",
        "x-enumNames": [
          "Asset",
          "Dynamic"
        ]
      },
      "ScheduleModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the schedule.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the schedule.",
            "nullable": true
          },
          "routeName": {
            "type": "string",
            "description": "Gets or sets the URL-friendly route name for the schedule.",
            "nullable": true
          },
          "thumbnailAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the thumbnail asset reference associated with the schedule.",
            "nullable": true
          },
          "scheduleType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleTypes"
              }
            ],
            "description": "Gets or sets the type of the schedule.\n\nPlaylist\n\nIntelligentSchedule\n\nIntelligentPlaylist",
            "x-enumNames": [
              "Playlist",
              "IntelligentSchedule",
              "IntelligentPlaylist"
            ]
          },
          "statusMessage": {
            "type": "string",
            "description": "Gets or sets a message describing the current status of the schedule.",
            "nullable": true
          },
          "scheduleStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleStatuses"
              }
            ],
            "description": "Gets or sets the current status of the schedule.\n\nNew\n\nStopped\n\nStarting\n\nRunning\n\nStopping\n\nError",
            "x-enumNames": [
              "New",
              "Stopped",
              "Starting",
              "Running",
              "Stopping",
              "Error"
            ]
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the status as a lookup model for display purposes.",
            "nullable": true
          },
          "playBackUrl": {
            "type": "string",
            "description": "Gets or sets the playback URL for the schedule stream.",
            "nullable": true
          },
          "timeZoneId": {
            "type": "string",
            "description": "Gets or sets the identifier of the time zone used by the schedule.",
            "format": "uuid",
            "nullable": true
          },
          "defaultVideoAsset": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetReferenceModel"
              }
            ],
            "description": "Gets or sets the default video asset reference used when no scheduled content is available.",
            "nullable": true
          },
          "loopPlaylist": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the playlist should loop when it reaches the end.",
            "nullable": true
          },
          "expirationDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the schedule expires.",
            "format": "date-time",
            "nullable": true
          },
          "hasAds": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the schedule includes advertisements.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets additional dynamic properties associated with the schedule.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a schedule with its configuration, status, and playback details."
      },
      "ScheduleStatuses": {
        "enum": [
          "New",
          "Stopped",
          "Starting",
          "Running",
          "Stopping",
          "Error"
        ],
        "type": "string",
        "description": "\n\nNew\n\nStopped\n\nStarting\n\nRunning\n\nStopping\n\nError",
        "x-enumNames": [
          "New",
          "Stopped",
          "Starting",
          "Running",
          "Stopping",
          "Error"
        ]
      },
      "ScheduleTypes": {
        "enum": [
          "Playlist",
          "IntelligentSchedule",
          "IntelligentPlaylist"
        ],
        "type": "string",
        "description": "\n\nPlaylist\n\nIntelligentSchedule\n\nIntelligentPlaylist",
        "x-enumNames": [
          "Playlist",
          "IntelligentSchedule",
          "IntelligentPlaylist"
        ]
      },
      "ScreenshotModel": {
        "type": "object",
        "properties": {
          "timeCode": {
            "type": "string",
            "description": "Gets or sets the timecode at which the screenshot should be captured.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to capture a screenshot from a media asset at a specified timecode."
      },
      "SearchConditionBinders": {
        "enum": [
          0,
          1
        ],
        "type": "integer",
        "description": "\n\n0 = And\n\n1 = Or",
        "format": "int32",
        "x-enumNames": [
          "And",
          "Or"
        ]
      },
      "SearchFieldModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "nullable": true
          },
          "displayName": {
            "type": "string",
            "nullable": true
          },
          "order": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "loadDetail": {
            "type": "boolean"
          },
          "preventFormatting": {
            "type": "boolean"
          },
          "searchResultFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchFieldModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SearchFilter": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "nullable": true
          },
          "operator": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchFilterOperators"
              }
            ],
            "description": "\n\n0 = Equals\n\n1 = NotEquals\n\n2 = Contains\n\n3 = NotContains\n\n4 = Like\n\n5 = NotLike\n\n6 = LessThan\n\n7 = GreaterThan\n\n8 = LessThanEquals\n\n9 = GreaterThanEquals\n\n10 = Prefix",
            "x-enumNames": [
              "Equals",
              "NotEquals",
              "Contains",
              "NotContains",
              "Like",
              "NotLike",
              "LessThan",
              "GreaterThan",
              "LessThanEquals",
              "GreaterThanEquals",
              "Prefix"
            ]
          },
          "includeNull": {
            "type": "boolean"
          },
          "values": {
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "SearchFilterOperators": {
        "enum": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "type": "integer",
        "description": "\n\n0 = Equals\n\n1 = NotEquals\n\n2 = Contains\n\n3 = NotContains\n\n4 = Like\n\n5 = NotLike\n\n6 = LessThan\n\n7 = GreaterThan\n\n8 = LessThanEquals\n\n9 = GreaterThanEquals\n\n10 = Prefix",
        "format": "int32",
        "x-enumNames": [
          "Equals",
          "NotEquals",
          "Contains",
          "NotContains",
          "Like",
          "NotLike",
          "LessThan",
          "GreaterThan",
          "LessThanEquals",
          "GreaterThanEquals",
          "Prefix"
        ]
      },
      "SearchModel": {
        "type": "object",
        "properties": {
          "pageSize": {
            "type": "integer",
            "description": "Gets or sets the size of the page (the number of items returned for this page)",
            "format": "int32"
          },
          "pageOffset": {
            "description": "Gets or sets the offset of the page (zero based).",
            "nullable": true
          },
          "searchQuery": {
            "type": "string",
            "description": "Gets or sets a text string to search within all of the text fields to match",
            "nullable": true
          },
          "filters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchFilter"
            },
            "description": "Gets or sets a list of the filters to apply for this search",
            "nullable": true
          },
          "searchTextFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchTextFields"
            },
            "description": "Gets or sets a list of the search text fields to apply for this search.",
            "nullable": true
          },
          "filterBinder": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchConditionBinders"
              }
            ],
            "description": "Gets or sets tells the query engine of the Filters should be applied as an And or an Or (the default is And)\n\n0 = And\n\n1 = Or",
            "x-enumNames": [
              "And",
              "Or"
            ]
          },
          "sortFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchSort"
            },
            "description": "Gets or sets the fields to sort by",
            "nullable": true
          },
          "returnedFieldNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "deprecated": true
          },
          "fullUrlFieldNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of fields that should have the FullURL calculated. The calculations are expensive and greatly slow down the query.\r\nUse this field to only return the ones that are actually needed.",
            "nullable": true
          },
          "distinctOnFieldName": {
            "type": "string",
            "description": "Gets or sets optional property that will be used to aggregate results records to distinct occurances of this field's values.",
            "nullable": true
          },
          "includeVideoClips": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether specify if the video search results are grouped by include clips of the videos also."
          },
          "searchResultFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchFieldModel"
            },
            "description": "Gets or sets the list of fields and optionally the sub fields and related records that should be returned as a result",
            "nullable": true
          },
          "similarAssetId": {
            "type": "string",
            "description": "Gets or sets when SimilarAssetId has a value, then the search results are a special type of results and bring back the items that are\r\nthe most similar to the item represented here. This search is only enabled when Vector searching has been enabled.\r\nWhen this has a value, the SearchQuery value and PageOffset values are ignored.",
            "format": "uuid",
            "nullable": true
          },
          "minScore": {
            "type": "number",
            "description": "Gets or sets specifies the minimum score to match when returning results. If omitted, the system default will be used - which is usually .65",
            "format": "double",
            "nullable": true
          },
          "excludeTotalRecordCount": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether normally, the total record count is returned but the query can be made faster if this value is excluded."
          },
          "useLlmSearch": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether gets or Sets a value representing if the search engine should try and use the LLM search instead of the standard search."
          }
        },
        "additionalProperties": false
      },
      "SearchResultModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "masterId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "score": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "contentDefinitionTitle": {
            "type": "string",
            "nullable": true
          },
          "keywordSearchField": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "assetDetailSearchField": {
            "type": "string",
            "nullable": true
          },
          "transcriptionSearchField": {
            "type": "string",
            "nullable": true
          },
          "customMetadataSearchField": {
            "type": "string",
            "nullable": true
          },
          "tagSearchField": {
            "type": "string",
            "nullable": true
          },
          "relatedContentSearchField": {
            "type": "string",
            "nullable": true
          },
          "collectionSearchField": {
            "type": "string",
            "nullable": true
          },
          "annotationSearchField": {
            "type": "string",
            "nullable": true
          },
          "aiLabelSearchField": {
            "type": "string",
            "nullable": true
          },
          "aiTextSearchField": {
            "type": "string",
            "nullable": true
          },
          "aiCaptionSearchField": {
            "type": "string",
            "nullable": true
          },
          "exifMetadataSearchField": {
            "type": "string",
            "nullable": true
          },
          "textContentSearchField": {
            "type": "string",
            "nullable": true
          },
          "contentSearchField": {
            "type": "string",
            "nullable": true
          },
          "timeCode": {
            "type": "string",
            "nullable": true
          },
          "previewImageUrl": {
            "type": "string",
            "nullable": true
          },
          "uuidSearchField": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "isRestricted": {
            "type": "boolean",
            "description": "Gets or sets this has the impact of not allowing downloading or clipping in the portal UI",
            "nullable": true
          },
          "isShared": {
            "type": "boolean",
            "description": "Gets or sets this isShared property for a index record, useful for downstream operations.",
            "nullable": true
          },
          "lastModifiedDate": {
            "type": "string",
            "format": "date-time"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time"
          },
          "identifiers": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          },
          "securitySearchField": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "nullable": true
          },
          "languageId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "inheritSecurity": {
            "type": "boolean"
          },
          "permission": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SecurityPermissions"
              }
            ],
            "description": "\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
            "nullable": true
          },
          "contentLanguageStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentLanguageStatuses"
              }
            ],
            "description": "\n\nOriginal\n\nOverride\n\nAuto",
            "x-enumNames": [
              "Original",
              "Override",
              "Auto"
            ]
          },
          "originalLanguageName": {
            "type": "string",
            "nullable": true
          },
          "assetStats": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetStatsModel"
              }
            ],
            "nullable": true
          },
          "collections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "securityUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "relatedContent": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "shares": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "nullable": true
          },
          "userContentAttributes": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserContentAttributeSummaryModel"
              }
            ],
            "nullable": true
          },
          "embeddings": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              },
              "nullable": true
            },
            "description": "Note that we convert all incoming keys to lower first char to help with serialization for JSON later",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SearchResultModelListResultModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultModel"
            },
            "nullable": true
          },
          "totalItemCount": {
            "type": "integer",
            "format": "int64"
          },
          "nextPageOffset": {
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          },
          "relatedItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultModel"
            },
            "nullable": true
          },
          "message": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Paginated result set containing Items of the specified type, TotalItemCount for the total number of matching records, NextPageOffset for cursor-based pagination, and optional RelatedItems and Message fields."
      },
      "SearchSort": {
        "type": "object",
        "properties": {
          "fieldName": {
            "type": "string",
            "nullable": true
          },
          "sortType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchSortTypes"
              }
            ],
            "description": "\n\n0 = Ascending\n\n1 = Descending",
            "x-enumNames": [
              "Ascending",
              "Descending"
            ]
          },
          "position": {
            "type": "integer",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "SearchSortTypes": {
        "enum": [
          0,
          1
        ],
        "type": "integer",
        "description": "\n\n0 = Ascending\n\n1 = Descending",
        "format": "int32",
        "x-enumNames": [
          "Ascending",
          "Descending"
        ]
      },
      "SearchTextFields": {
        "enum": [
          "AssetDetails",
          "ExactTitle",
          "TextContents",
          "Transcripts",
          "CustomMetadata",
          "ExifMetadata",
          "Tags",
          "Collections",
          "RelatedContent",
          "Annotations",
          "AI_Labels",
          "AI_Text",
          "AI_Captions"
        ],
        "type": "string",
        "description": "\n\nAssetDetails\n\nExactTitle\n\nTextContents\n\nTranscripts\n\nCustomMetadata\n\nExifMetadata\n\nTags\n\nCollections\n\nRelatedContent\n\nAnnotations\n\nAI_Labels\n\nAI_Text\n\nAI_Captions",
        "x-enumNames": [
          "AssetDetails",
          "ExactTitle",
          "TextContents",
          "Transcripts",
          "CustomMetadata",
          "ExifMetadata",
          "Tags",
          "Collections",
          "RelatedContent",
          "Annotations",
          "AI_Labels",
          "AI_Text",
          "AI_Captions"
        ]
      },
      "SecurityModel": {
        "type": "object",
        "properties": {
          "securityGroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of security groups that have access to the content item.",
            "nullable": true
          },
          "securityUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of individual users that have access to the content item.",
            "nullable": true
          },
          "inheritSecurity": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the content item inherits security settings from its parent."
          },
          "clearPublicExpirationDate": {
            "type": "boolean",
            "nullable": true,
            "deprecated": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the security configuration for a content item including group and user access."
      },
      "SecurityPermissions": {
        "enum": [
          "Read",
          "FileWrite",
          "FolderWrite",
          "Administrator",
          "Guest"
        ],
        "type": "string",
        "description": "\n\nRead\n\nFileWrite\n\nFolderWrite\n\nAdministrator\n\nGuest",
        "x-enumNames": [
          "Read",
          "FileWrite",
          "FolderWrite",
          "Administrator",
          "Guest"
        ]
      },
      "SegmentModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "duration": {
            "type": "integer",
            "format": "int64"
          },
          "timestamp": {
            "type": "integer",
            "format": "int64"
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "ShareModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the share; if null, a new share will be created.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the share.",
            "nullable": true
          },
          "sharedContents": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "description": "Gets or sets the list of content identifiers included in this share.",
            "nullable": true
          },
          "sharedDuration": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the duration setting that controls how long the share remains active.",
            "nullable": true
          },
          "sharedPermissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of permission levels granted to recipients of this share.",
            "nullable": true
          },
          "sharedType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the type of share (e.g., link-based, user-based).",
            "nullable": true
          },
          "sharedStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LookupModel"
              }
            ],
            "description": "Gets or sets the current status of the share.",
            "nullable": true
          },
          "sharedDurationInHours": {
            "type": "integer",
            "description": "Gets or sets the duration of the share in hours.",
            "format": "int32",
            "nullable": true
          },
          "sharedLink": {
            "type": "string",
            "description": "Gets or sets the URL link that provides access to the shared content.",
            "nullable": true
          },
          "ownerId": {
            "type": "string",
            "description": "Gets or sets the identifier of the user who owns this share.",
            "format": "uuid",
            "nullable": true
          },
          "expirationDate": {
            "type": "string",
            "description": "Gets or sets the date and time when this share expires and is no longer accessible.",
            "format": "date-time",
            "nullable": true
          },
          "assetId": {
            "type": "string",
            "description": "Gets or sets the asset identifier for internal user-to-user sharing.",
            "format": "uuid"
          },
          "nomadUsers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LookupModel"
            },
            "description": "Gets or sets the list of platform users who have been granted access to the shared content.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a share configuration that defines how assets are shared with other users, including permissions, duration, and access link."
      },
      "SiteInitializationStatuses": {
        "enum": [
          1,
          2,
          3,
          4,
          5
        ],
        "type": "integer",
        "description": "\n\n1 = New\n\n2 = Initializing\n\n3 = InitializingContent\n\n4 = Initialized\n\n5 = InitializationError",
        "format": "int32",
        "x-enumNames": [
          "New",
          "Initializing",
          "InitializingContent",
          "Initialized",
          "InitializationError"
        ]
      },
      "StatisiticsData": {
        "type": "object",
        "properties": {
          "dataSets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StatisiticsDataSet"
            },
            "description": "Gets or sets the list of datasets to render in the chart.",
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the axis labels for the chart. Not currently used.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the data portion of a chart, containing datasets and axis labels."
      },
      "StatisiticsDataGraph": {
        "type": "object",
        "properties": {
          "data": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsData"
              }
            ],
            "description": "Gets or sets the chart data containing datasets and labels.",
            "nullable": true
          },
          "options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptions"
              }
            ],
            "description": "Gets or sets the chart display options including axis configuration.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a single chart graph containing data and display options for a statistics measurement."
      },
      "StatisiticsDataGraphOptions": {
        "type": "object",
        "properties": {
          "indexAxis": {
            "type": "string",
            "description": "Gets or sets the index axis for the chart. Defaults to \"x\".",
            "nullable": true
          },
          "scales": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptionsScales"
              }
            ],
            "description": "Gets or sets the axis scale configuration for the chart.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents chart display options including axis configuration and scale settings."
      },
      "StatisiticsDataGraphOptionsScales": {
        "type": "object",
        "properties": {
          "xaxis": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptionsScalesAxis"
              }
            ],
            "description": "Gets or sets the X-axis scale configuration.",
            "nullable": true
          },
          "yaxis": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StatisiticsDataGraphOptionsScalesAxis"
              }
            ],
            "description": "Gets or sets the Y-axis scale configuration.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the X and Y axis scale configurations for a statistics chart."
      },
      "StatisiticsDataGraphOptionsScalesAxis": {
        "type": "object",
        "properties": {
          "suggestedMin": {
            "type": "string",
            "description": "Gets or sets the suggested minimum value for the axis.",
            "nullable": true
          },
          "suggestedMax": {
            "type": "string",
            "description": "Gets or sets the suggested maximum value for the axis.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the scale configuration for a single chart axis, including suggested minimum and maximum values."
      },
      "StatisiticsDataSet": {
        "type": "object",
        "properties": {
          "noData": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether this dataset has no data points."
          },
          "unitLabel": {
            "type": "string",
            "description": "Gets or sets the unit label for the dataset values (e.g., \"GB\", \"hours\").",
            "nullable": true
          },
          "unitScaleFactor": {
            "type": "number",
            "description": "Gets or sets the scale factor applied to the dataset unit values. Defaults to 1.0.",
            "format": "double"
          },
          "type": {
            "type": "string",
            "description": "Gets or sets the chart type for this dataset (e.g., \"line\", \"bar\"). Defaults to \"line\".",
            "nullable": true
          },
          "stackName": {
            "type": "string",
            "description": "Gets or sets the stack name for grouping this dataset in stacked chart visualizations.",
            "nullable": true
          },
          "label": {
            "type": "string",
            "description": "Gets or sets the display label for this dataset in the chart legend.",
            "nullable": true
          },
          "measurementName": {
            "type": "string",
            "description": "Gets or sets the name of the measurement this dataset represents.",
            "nullable": true
          },
          "measurementDomainName": {
            "type": "string",
            "description": "Gets or sets the domain name of the measurement this dataset represents.",
            "nullable": true
          },
          "group": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets or sets the grouping field values that define this dataset's group.",
            "nullable": true
          },
          "data": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of data values as strings for the chart.",
            "nullable": true
          },
          "minDataValue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BigDecimal"
              }
            ],
            "description": "Gets or sets the minimum data value in the dataset, used for axis scaling.",
            "nullable": true
          },
          "maxDataValue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BigDecimal"
              }
            ],
            "description": "Gets or sets the maximum data value in the dataset, used for axis scaling.",
            "nullable": true
          },
          "groupKey": {
            "type": "string",
            "description": "Gets or sets the computed group key used internally for dataset grouping. Not serialized.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a single dataset within a chart, containing the data series, labels, and rendering configuration."
      },
      "StatisticsConfigResultModel": {
        "type": "object",
        "properties": {
          "measurements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MeasurementInfo"
            },
            "description": "Gets or sets the list of available measurement definitions.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the result of a statistics configuration query, containing available measurement definitions."
      },
      "StatisticsListModel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the statistics metric.",
            "nullable": true
          },
          "group": {
            "type": "string",
            "description": "Gets or sets the grouping category for the statistics entry.",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "description": "Gets or sets the aggregated count for this statistics entry.",
            "format": "int64"
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the identifier of the content item associated with this statistics entry, if applicable.",
            "format": "uuid",
            "nullable": true
          },
          "applicationId": {
            "type": "string",
            "description": "Gets or sets the identifier of the application associated with this statistics entry, if applicable.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents an aggregated statistics entry with a count grouped by name, group, content, or application."
      },
      "StatisticsRequestModel": {
        "type": "object",
        "properties": {
          "startDate": {
            "type": "string",
            "description": "Gets or sets the start date of the statistics query period.",
            "format": "date-time",
            "nullable": true
          },
          "endDate": {
            "type": "string",
            "description": "Gets or sets the end date of the statistics query period.",
            "format": "date-time",
            "nullable": true
          },
          "measurements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MeasurementRequest"
            },
            "description": "Gets or sets the list of measurement requests specifying which metrics to retrieve.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request for statistics data over a date range with specified measurements and grouping options."
      },
      "StorageClasses": {
        "enum": [
          "Standard",
          "ReducedRedundancy",
          "Glacier",
          "StandardInfrequentAccess",
          "OneZoneInfrequentAccess",
          "IntelligentTiering",
          "DeepArchive",
          "GlacierInstantRetrieval",
          "Outposts"
        ],
        "type": "string",
        "description": "\n\nStandard\n\nReducedRedundancy\n\nGlacier\n\nStandardInfrequentAccess\n\nOneZoneInfrequentAccess\n\nIntelligentTiering\n\nDeepArchive\n\nGlacierInstantRetrieval\n\nOutposts",
        "x-enumNames": [
          "Standard",
          "ReducedRedundancy",
          "Glacier",
          "StandardInfrequentAccess",
          "OneZoneInfrequentAccess",
          "IntelligentTiering",
          "DeepArchive",
          "GlacierInstantRetrieval",
          "Outposts"
        ]
      },
      "StringStringKeyValuePair": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "nullable": true
          },
          "value": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SubmitJobModel": {
        "required": [
          "bucketName",
          "notificationCallbackUrl",
          "objectKey"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string",
            "description": "Gets or sets the external identifier for correlating the job with an external system.",
            "nullable": true
          },
          "bucketName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the name of the S3 bucket containing the source media file."
          },
          "objectKey": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the S3 object key of the source media file."
          },
          "notificationCallbackUrl": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the URL to call when the job completes."
          },
          "replaceExistingJob": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether to replace an existing job with the same identifier."
          },
          "assetUrl": {
            "type": "string",
            "description": "Gets or sets the URL of the source asset for processing.",
            "nullable": true
          },
          "requestedTasks": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of processing tasks to perform on the media file.",
            "nullable": true
          },
          "requestedTranscodeProfiles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Gets or sets the list of transcode profile names to apply to the media file.",
            "nullable": true
          },
          "accessToken": {
            "type": "string",
            "description": "Gets or sets the access token for authenticating with external services during processing.",
            "nullable": true
          },
          "getAssetDetailsUrl": {
            "type": "string",
            "description": "Gets or sets the URL for retrieving asset details during processing.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the input model for submitting a media processing job."
      },
      "TagContentModel": {
        "type": "object",
        "properties": {
          "contentDefinition": {
            "type": "string",
            "description": "Gets or sets the content definition string name of the content records that should be affected\r\nLike asset, video, etc",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the ID of the content record to apply the new or removed attributes",
            "format": "uuid"
          },
          "createNew": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether defaults to False. If true, then the attribute will be added if it doesn't already exist with a matching name"
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the name of the collection that should be added or removed. If the name and the collectionId are both specified, the name is ignored.",
            "nullable": true
          },
          "tagId": {
            "type": "string",
            "description": "Gets or sets the tag ID that should be added or removed",
            "format": "uuid",
            "nullable": true
          },
          "childId": {
            "type": "string",
            "description": "Gets the child identifier, which is the tag identifier.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          },
          "childPropertyName": {
            "type": "string",
            "description": "Gets the name of the child property used for serialization.",
            "nullable": true,
            "readOnly": true
          },
          "indexPropertyName": {
            "type": "string",
            "description": "Gets the name of the index property used in search indexing.",
            "nullable": true,
            "readOnly": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets the content definition identifier for tags.",
            "format": "uuid",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the association between a content item and a tag, used for adding or removing tags from content."
      },
      "TagContentModelListModel": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagContentModel"
            },
            "nullable": true
          },
          "hasItems": {
            "type": "boolean",
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "TagModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the tag, or null when creating a new tag.",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Gets or sets the display name of the tag.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a tag with its identifier and display name."
      },
      "TextCaptionModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "externalId": {
            "type": "string",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "textCaptionType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TextCaptionTypes"
              }
            ],
            "description": "\n\nVerbose\n\nConcise\n\nTranscript",
            "x-enumNames": [
              "Verbose",
              "Concise",
              "Transcript"
            ]
          }
        },
        "additionalProperties": false
      },
      "TextCaptionTypes": {
        "enum": [
          "Verbose",
          "Concise",
          "Transcript"
        ],
        "type": "string",
        "description": "\n\nVerbose\n\nConcise\n\nTranscript",
        "x-enumNames": [
          "Verbose",
          "Concise",
          "Transcript"
        ]
      },
      "TextItemGroupModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "sourceId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "contentTextType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentTextTypes"
              }
            ],
            "description": "\n\nLine\n\nWord\n\nPerson\n\nLocation\n\nOrganization\n\nCommercialItem\n\nEvent\n\nDate\n\nQuantity\n\nTitle\n\nEntity\n\nKeyPhrase\n\nMixedSentiment\n\nNegativeSentiment\n\nNeutralSentiment\n\nPositiveSentiment\n\nTranscript\n\nOther",
            "x-enumNames": [
              "Line",
              "Word",
              "Person",
              "Location",
              "Organization",
              "CommercialItem",
              "Event",
              "Date",
              "Quantity",
              "Title",
              "Entity",
              "KeyPhrase",
              "MixedSentiment",
              "NegativeSentiment",
              "NeutralSentiment",
              "PositiveSentiment",
              "Transcript",
              "Other"
            ]
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextItemModel"
            },
            "nullable": true
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "Note that this is a PARTIAL list of types that we need to know about\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "x-enumNames": [
              "DocumentContent",
              "ComprehendKeyPhrases",
              "ComprehendEntities",
              "RekognitionImageIndexFaces",
              "RekognitionImageSearchFaces",
              "RekognitionImageLabels",
              "RekognitionImageCelebrityRecognition",
              "RekognitionVideoLabels",
              "TextractAnalyzeDocument",
              "Transcribe",
              "TranscribeVtt",
              "TranscribeTranslation",
              "TranscribeVttTranslation",
              "RekognitionVideoCelebrityRecognition",
              "RekognitionVideoPersonTracking",
              "RekognitionVideoFaceDetection",
              "ImageInfo",
              "Transcode",
              "Clip",
              "MediaInfo",
              "RekognitionImageDetectText",
              "RekognitionImageUnsafeContent",
              "RekognitionVideoUnsafeContent",
              "Screenshot",
              "SageMakerGroundTruthLabelResults",
              "ThumbnailSheet",
              "ThumbnailImage",
              "SageMakerInvokeEndpointResults",
              "SageMakerModelLabels",
              "RekognitionImageCustomLabels",
              "SageMakerManifest",
              "PreviewImage",
              "RekognitionVideoTextDetection",
              "RekognitionVideoSegmentDetection",
              "NomadVideoSegmentDetection",
              "TranscribeMedical",
              "PreviewAudio",
              "Text",
              "AssetManifest",
              "IntervalSegments",
              "TranscribeMedicalText",
              "TranscribeMedicalTranslation",
              "AdobeMetadata",
              "AdobeMetadataText",
              "ImageExif",
              "TextractImageDetectText",
              "AdSegments",
              "Vmap",
              "Vast",
              "MediaTailorVideo",
              "TranscribeSrt",
              "TranscribeRaw",
              "Subtitles",
              "VizRtMetadata",
              "ProcessorJobs",
              "OfficeDocument",
              "TranscriptionContainer",
              "ComprehendSentiment",
              "ComprehendLanguage",
              "OriginalSourceVideo",
              "ImportManifest",
              "TranscribeScc",
              "TranscribeTtml",
              "TranscribeDfxp",
              "TranscribeSmptett",
              "TranscribeXml",
              "TranscribeQt",
              "TranscribeRt",
              "TranscribeSsa",
              "TranscribeAss",
              "TranscribeSbv",
              "TranscribeSmi",
              "TranscribeSami",
              "TranscribeStl",
              "TranscribeSub",
              "AssociatedAsset",
              "MobiusLabsImageLabels",
              "MobiusLabsVideoAnalysis",
              "ContactSheetVTT",
              "ContactSheetTimecodes",
              "ContactSheetImage",
              "RenderedImage",
              "RokuBif",
              "MobiusLabsVideoExtractFeatures",
              "AzureImageAnalysis",
              "AzureImageVectorize",
              "AzureTextVectorize",
              "ContentVectors",
              "SceneXDescribe",
              "MobiusLabsLabelsExtractFeatures",
              "SportLogiqVideoAnalysis",
              "OciImageCaption",
              "OciTextVectorizer",
              "AnimatedGif",
              "OciTextSummary",
              "NomadMediaTasks",
              "GooglePhotosMetadata",
              "SageMakerImageToText",
              "TwelveLabsVideoAnalysis",
              "AccurateRegister",
              "BedrockImageAnalysis",
              "BedrockTextVectorizer",
              "BedrockImageVectorize",
              "BedrockTextSummary",
              "GeneratedImage",
              "TranscodeIvsRecording",
              "DolbyRaspRegister",
              "MobiusLabsLlmVideoAnalysis",
              "MobiusLabsLlmImageAnalysis",
              "TranscriptSummary",
              "SearchCache",
              "WhisperTranscription",
              "BitmovinSceneDetection",
              "BedrockDataAutomation",
              "BedrockSceneDetection",
              "MobiusLabsLlmSegmentContent",
              "AudioWaveform",
              "CustomType"
            ]
          }
        },
        "additionalProperties": false
      },
      "TextItemModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "value": {
            "type": "string",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SegmentModel"
            },
            "nullable": true
          },
          "boundingBoxes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BoundingBoxModel"
            },
            "nullable": true
          },
          "contextTextType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContentTextTypes"
              }
            ],
            "description": "\n\nLine\n\nWord\n\nPerson\n\nLocation\n\nOrganization\n\nCommercialItem\n\nEvent\n\nDate\n\nQuantity\n\nTitle\n\nEntity\n\nKeyPhrase\n\nMixedSentiment\n\nNegativeSentiment\n\nNeutralSentiment\n\nPositiveSentiment\n\nTranscript\n\nOther",
            "x-enumNames": [
              "Line",
              "Word",
              "Person",
              "Location",
              "Organization",
              "CommercialItem",
              "Event",
              "Date",
              "Quantity",
              "Title",
              "Entity",
              "KeyPhrase",
              "MixedSentiment",
              "NegativeSentiment",
              "NeutralSentiment",
              "PositiveSentiment",
              "Transcript",
              "Other"
            ]
          },
          "metadataType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MetadataTypes"
              }
            ],
            "description": "Note that this is a PARTIAL list of types that we need to know about\n\nDocumentContent\n\nComprehendKeyPhrases\n\nComprehendEntities\n\nRekognitionImageIndexFaces\n\nRekognitionImageSearchFaces\n\nRekognitionImageLabels\n\nRekognitionImageCelebrityRecognition\n\nRekognitionVideoLabels\n\nTextractAnalyzeDocument\n\nTranscribe\n\nTranscribeVtt\n\nTranscribeTranslation\n\nTranscribeVttTranslation\n\nRekognitionVideoCelebrityRecognition\n\nRekognitionVideoPersonTracking\n\nRekognitionVideoFaceDetection\n\nImageInfo\n\nTranscode\n\nClip\n\nMediaInfo\n\nRekognitionImageDetectText\n\nRekognitionImageUnsafeContent\n\nRekognitionVideoUnsafeContent\n\nScreenshot\n\nSageMakerGroundTruthLabelResults\n\nThumbnailSheet\n\nThumbnailImage\n\nSageMakerInvokeEndpointResults\n\nSageMakerModelLabels\n\nRekognitionImageCustomLabels\n\nSageMakerManifest\n\nPreviewImage\n\nRekognitionVideoTextDetection\n\nRekognitionVideoSegmentDetection\n\nNomadVideoSegmentDetection\n\nTranscribeMedical\n\nPreviewAudio\n\nText\n\nAssetManifest\n\nIntervalSegments\n\nTranscribeMedicalText\n\nTranscribeMedicalTranslation\n\nAdobeMetadata\n\nAdobeMetadataText\n\nImageExif\n\nTextractImageDetectText\n\nAdSegments\n\nVmap\n\nVast\n\nMediaTailorVideo\n\nTranscribeSrt\n\nTranscribeRaw\n\nSubtitles\n\nVizRtMetadata\n\nProcessorJobs\n\nOfficeDocument\n\nTranscriptionContainer\n\nComprehendSentiment\n\nComprehendLanguage\n\nOriginalSourceVideo\n\nImportManifest\n\nTranscribeScc\n\nTranscribeTtml\n\nTranscribeDfxp\n\nTranscribeSmptett\n\nTranscribeXml\n\nTranscribeQt\n\nTranscribeRt\n\nTranscribeSsa\n\nTranscribeAss\n\nTranscribeSbv\n\nTranscribeSmi\n\nTranscribeSami\n\nTranscribeStl\n\nTranscribeSub\n\nAssociatedAsset\n\nMobiusLabsImageLabels\n\nMobiusLabsVideoAnalysis\n\nContactSheetVTT\n\nContactSheetTimecodes\n\nContactSheetImage\n\nRenderedImage\n\nRokuBif\n\nMobiusLabsVideoExtractFeatures\n\nAzureImageAnalysis\n\nAzureImageVectorize\n\nAzureTextVectorize\n\nContentVectors\n\nSceneXDescribe\n\nMobiusLabsLabelsExtractFeatures\n\nSportLogiqVideoAnalysis\n\nOciImageCaption\n\nOciTextVectorizer\n\nAnimatedGif\n\nOciTextSummary\n\nNomadMediaTasks\n\nGooglePhotosMetadata\n\nSageMakerImageToText\n\nTwelveLabsVideoAnalysis\n\nAccurateRegister\n\nBedrockImageAnalysis\n\nBedrockTextVectorizer\n\nBedrockImageVectorize\n\nBedrockTextSummary\n\nGeneratedImage\n\nTranscodeIvsRecording\n\nDolbyRaspRegister\n\nMobiusLabsLlmVideoAnalysis\n\nMobiusLabsLlmImageAnalysis\n\nTranscriptSummary\n\nSearchCache\n\nWhisperTranscription\n\nBitmovinSceneDetection\n\nBedrockDataAutomation\n\nBedrockSceneDetection\n\nMobiusLabsLlmSegmentContent\n\nAudioWaveform\n\nCustomType",
            "x-enumNames": [
              "DocumentContent",
              "ComprehendKeyPhrases",
              "ComprehendEntities",
              "RekognitionImageIndexFaces",
              "RekognitionImageSearchFaces",
              "RekognitionImageLabels",
              "RekognitionImageCelebrityRecognition",
              "RekognitionVideoLabels",
              "TextractAnalyzeDocument",
              "Transcribe",
              "TranscribeVtt",
              "TranscribeTranslation",
              "TranscribeVttTranslation",
              "RekognitionVideoCelebrityRecognition",
              "RekognitionVideoPersonTracking",
              "RekognitionVideoFaceDetection",
              "ImageInfo",
              "Transcode",
              "Clip",
              "MediaInfo",
              "RekognitionImageDetectText",
              "RekognitionImageUnsafeContent",
              "RekognitionVideoUnsafeContent",
              "Screenshot",
              "SageMakerGroundTruthLabelResults",
              "ThumbnailSheet",
              "ThumbnailImage",
              "SageMakerInvokeEndpointResults",
              "SageMakerModelLabels",
              "RekognitionImageCustomLabels",
              "SageMakerManifest",
              "PreviewImage",
              "RekognitionVideoTextDetection",
              "RekognitionVideoSegmentDetection",
              "NomadVideoSegmentDetection",
              "TranscribeMedical",
              "PreviewAudio",
              "Text",
              "AssetManifest",
              "IntervalSegments",
              "TranscribeMedicalText",
              "TranscribeMedicalTranslation",
              "AdobeMetadata",
              "AdobeMetadataText",
              "ImageExif",
              "TextractImageDetectText",
              "AdSegments",
              "Vmap",
              "Vast",
              "MediaTailorVideo",
              "TranscribeSrt",
              "TranscribeRaw",
              "Subtitles",
              "VizRtMetadata",
              "ProcessorJobs",
              "OfficeDocument",
              "TranscriptionContainer",
              "ComprehendSentiment",
              "ComprehendLanguage",
              "OriginalSourceVideo",
              "ImportManifest",
              "TranscribeScc",
              "TranscribeTtml",
              "TranscribeDfxp",
              "TranscribeSmptett",
              "TranscribeXml",
              "TranscribeQt",
              "TranscribeRt",
              "TranscribeSsa",
              "TranscribeAss",
              "TranscribeSbv",
              "TranscribeSmi",
              "TranscribeSami",
              "TranscribeStl",
              "TranscribeSub",
              "AssociatedAsset",
              "MobiusLabsImageLabels",
              "MobiusLabsVideoAnalysis",
              "ContactSheetVTT",
              "ContactSheetTimecodes",
              "ContactSheetImage",
              "RenderedImage",
              "RokuBif",
              "MobiusLabsVideoExtractFeatures",
              "AzureImageAnalysis",
              "AzureImageVectorize",
              "AzureTextVectorize",
              "ContentVectors",
              "SceneXDescribe",
              "MobiusLabsLabelsExtractFeatures",
              "SportLogiqVideoAnalysis",
              "OciImageCaption",
              "OciTextVectorizer",
              "AnimatedGif",
              "OciTextSummary",
              "NomadMediaTasks",
              "GooglePhotosMetadata",
              "SageMakerImageToText",
              "TwelveLabsVideoAnalysis",
              "AccurateRegister",
              "BedrockImageAnalysis",
              "BedrockTextVectorizer",
              "BedrockImageVectorize",
              "BedrockTextSummary",
              "GeneratedImage",
              "TranscodeIvsRecording",
              "DolbyRaspRegister",
              "MobiusLabsLlmVideoAnalysis",
              "MobiusLabsLlmImageAnalysis",
              "TranscriptSummary",
              "SearchCache",
              "WhisperTranscription",
              "BitmovinSceneDetection",
              "BedrockDataAutomation",
              "BedrockSceneDetection",
              "MobiusLabsLlmSegmentContent",
              "AudioWaveform",
              "CustomType"
            ]
          }
        },
        "additionalProperties": false
      },
      "TheoliveWebhookObjectModel": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "Gets or sets the type of the object (e.g., channel).",
            "nullable": true
          },
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the object.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents the object payload within a THEOlive webhook event."
      },
      "TheoliveWebhookRequestModel": {
        "type": "object",
        "properties": {
          "created": {
            "type": "integer",
            "description": "Gets or sets the Unix timestamp when the webhook event was created.",
            "format": "int64"
          },
          "type": {
            "type": "string",
            "description": "Gets or sets the type of webhook event (e.g., channel state change).",
            "nullable": true
          },
          "object": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TheoliveWebhookObjectModel"
              }
            ],
            "description": "Gets or sets the object associated with the webhook event.",
            "nullable": true
          },
          "livemode": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the event occurred in live mode."
          },
          "event": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "channelId": {
            "type": "string",
            "nullable": true,
            "readOnly": true
          },
          "timestamp": {
            "type": "integer",
            "format": "int64",
            "readOnly": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a webhook event request from the THEOlive platform."
      },
      "TranscriptionContainerOutputTypes": {
        "enum": [
          0,
          1,
          2,
          3
        ],
        "type": "integer",
        "description": "\n\n0 = DocX\n\n1 = Text\n\n2 = SRT\n\n3 = VTT",
        "format": "int32",
        "x-enumNames": [
          "DocX",
          "Text",
          "SRT",
          "VTT"
        ]
      },
      "TranscriptionV2Model": {
        "type": "object",
        "properties": {
          "language": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LanguageModel"
              }
            ],
            "description": "Gets or sets the language detected or specified for this transcription.",
            "nullable": true
          },
          "words": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TranscriptionWordV2Model"
            },
            "description": "Gets or sets the list of individual transcribed words with their timing and confidence data.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a transcription of a media asset, including the detected language and the individual transcribed words."
      },
      "TranscriptionWordV2Model": {
        "type": "object",
        "properties": {
          "startTime": {
            "type": "string",
            "format": "date-span"
          },
          "endTime": {
            "type": "string",
            "format": "date-span"
          },
          "value": {
            "type": "string",
            "nullable": true
          },
          "speakerLabel": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "speakerName": {
            "type": "string",
            "nullable": true
          },
          "confidence": {
            "type": "number",
            "format": "float",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdateDownloadQueueModel": {
        "type": "object",
        "properties": {
          "assetDownloadQueueId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the download queue item to update.",
            "format": "uuid"
          },
          "transferStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetTransferStatuses"
              }
            ],
            "description": "Gets or sets the current transfer status of the download.\n\nQueued\n\nDownloading\n\nUploading\n\nError\n\nComplete\n\nCancelled",
            "x-enumNames": [
              "Queued",
              "Downloading",
              "Uploading",
              "Error",
              "Complete",
              "Cancelled"
            ]
          },
          "errorMessage": {
            "type": "string",
            "description": "Gets or sets the error message if the download has failed.",
            "nullable": true
          },
          "completePercentage": {
            "type": "number",
            "description": "Gets or sets the completion percentage of the download, expressed as a value between 0 and 100.",
            "format": "float",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to update the status and progress of an item in the download queue."
      },
      "UpdateTranscriptModel": {
        "type": "object",
        "properties": {
          "startTimeCode": {
            "type": "string",
            "description": "Gets or sets the timecode identifying the transcription entry to update.",
            "nullable": true
          },
          "content": {
            "type": "string",
            "description": "Gets or sets the updated text content for the transcription entry.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a request to update the text content of a transcription entry at a specific timecode."
      },
      "UploadOverwriteOptions": {
        "enum": [
          "Cancel",
          "Continue",
          "Replace",
          "AssetReplace"
        ],
        "type": "string",
        "description": "\n\nCancel\n\nContinue\n\nReplace\n\nAssetReplace",
        "x-enumNames": [
          "Cancel",
          "Continue",
          "Replace",
          "AssetReplace"
        ]
      },
      "UploadReplaceOptions": {
        "enum": [
          "ReplaceDisplayName",
          "ReplaceDisplayDate",
          "ReplaceLanguage",
          "RecreateThumbnail",
          "RecreatePreview",
          "RecreateSubtitles",
          "RecreateTranscodes"
        ],
        "type": "string",
        "description": "\n\nReplaceDisplayName\n\nReplaceDisplayDate\n\nReplaceLanguage\n\nRecreateThumbnail\n\nRecreatePreview\n\nRecreateSubtitles\n\nRecreateTranscodes",
        "x-enumNames": [
          "ReplaceDisplayName",
          "ReplaceDisplayDate",
          "ReplaceLanguage",
          "RecreateThumbnail",
          "RecreatePreview",
          "RecreateSubtitles",
          "RecreateTranscodes"
        ]
      },
      "UserContentAttributeSummaryModel": {
        "type": "object",
        "properties": {
          "likedCount": {
            "type": "integer",
            "format": "int64"
          },
          "dislikedCount": {
            "type": "integer",
            "format": "int64"
          },
          "liked": {
            "type": "boolean",
            "nullable": true
          },
          "disliked": {
            "type": "boolean",
            "nullable": true
          },
          "favorite": {
            "type": "boolean",
            "nullable": true
          },
          "lastSecond": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UserContentSecurityModel": {
        "type": "object",
        "properties": {
          "contentId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the content item.",
            "format": "uuid",
            "nullable": true
          },
          "contentDefinitionId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the content definition.",
            "format": "uuid",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user.",
            "format": "uuid",
            "nullable": true
          },
          "email": {
            "type": "string",
            "description": "Gets or sets the email address of the user.",
            "nullable": true
          },
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the security record.",
            "format": "uuid",
            "nullable": true
          },
          "keyName": {
            "type": "string",
            "nullable": true
          },
          "expirationDate": {
            "type": "string",
            "description": "Gets or sets the date and time when the user's access to this content expires.",
            "format": "date-time",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Model for managing per-user content security access records."
      },
      "UserModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user.",
            "format": "uuid"
          },
          "email": {
            "type": "string",
            "description": "Gets or sets the email address of the user.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user.",
            "nullable": true
          },
          "isAdmin": {
            "type": "boolean",
            "description": "Gets or sets whether the user has system administrator privileges.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties of the user. Any unrecognized JSON properties are captured here.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "UserRegistrationRequestModel": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "Gets or sets the email address for the new account. Must be unique.",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user.",
            "nullable": true
          },
          "password": {
            "type": "string",
            "description": "Gets or sets the password for the new account.",
            "nullable": true
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "nullable": true
            },
            "description": "Gets the additional custom properties for the registration. Any unrecognized JSON properties in the request body are captured here.",
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "UserResponseModel": {
        "type": "object",
        "properties": {
          "loginStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LoginResponseStatuses"
              }
            ],
            "description": "Gets or sets the login status indicating the result of the operation.\r\nA null value indicates success. Non-null values indicate a specific account state\r\n(e.g., IsDisabled, IsPendingEmailConfirmation) that the client should handle.\n\nTwoFactorSetupRequired\n\nTwoFactorCodeRequired\n\nIsDisabled\n\nIsPendingEmailConfirmation\n\nIsPendingNewAccountSignup\n\nIsPendingAccountMigrationSignup\n\nIsPendingNewPassword\n\nIsExpired\n\nIsPendingInvitation",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UserSessionModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the session.",
            "format": "uuid"
          },
          "userId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user who owns this session.",
            "format": "uuid",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "description": "Gets or sets the first name of the user.",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "description": "Gets or sets the last name of the user.",
            "nullable": true
          },
          "email": {
            "type": "string",
            "description": "Gets or sets the email address of the user.",
            "nullable": true
          },
          "browserType": {
            "type": "string",
            "description": "Gets or sets the browser type used for this session (e.g., Chrome, Firefox).",
            "nullable": true
          },
          "userAgent": {
            "type": "string",
            "description": "Gets or sets the full user agent string from the client's browser.",
            "nullable": true
          },
          "ipAddress": {
            "type": "string",
            "description": "Gets or sets the IP address of the client.",
            "nullable": true
          },
          "origin": {
            "type": "string",
            "description": "Gets or sets the origin URL of the request that created this session.",
            "nullable": true
          },
          "environmentName": {
            "type": "string",
            "description": "Gets or sets the environment name where this session is active.",
            "nullable": true
          },
          "startDate": {
            "type": "string",
            "description": "Gets or sets the date and time (UTC) when the session was started.",
            "format": "date-time"
          },
          "lastActivityDate": {
            "type": "string",
            "description": "Gets or sets the date and time (UTC) of the user's last activity in this session.",
            "format": "date-time"
          },
          "userSessionStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserSessionStatuses"
              }
            ],
            "description": "Gets or sets the current status of the session (e.g., Normal, Kicked, ChatRestricted, Expired).\n\nNormal\n\nChatDisabled\n\nSessionReplaced\n\nDeactivated\n\nSharedAccess\n\nPendingInvite\n\nExpired\n\nDeletedInvite",
            "x-enumNames": [
              "Normal",
              "ChatDisabled",
              "SessionReplaced",
              "Deactivated",
              "SharedAccess",
              "PendingInvite",
              "Expired",
              "DeletedInvite"
            ]
          },
          "userSessionStatusName": {
            "type": "string",
            "description": "Gets or sets the display name of the session status.",
            "nullable": true
          },
          "externalId": {
            "type": "string",
            "description": "Gets or sets an external identifier associated with this session.",
            "nullable": true
          },
          "chatName": {
            "type": "string",
            "description": "Gets or sets the user's display name for chat functionality.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents a user session with metadata about the user's connection, activity, and current status."
      },
      "UserSessionStatuses": {
        "enum": [
          "Normal",
          "ChatDisabled",
          "SessionReplaced",
          "Deactivated",
          "SharedAccess",
          "PendingInvite",
          "Expired",
          "DeletedInvite"
        ],
        "type": "string",
        "description": "Indicates the current status of a user session.\n\nNormal\n\nChatDisabled\n\nSessionReplaced\n\nDeactivated\n\nSharedAccess\n\nPendingInvite\n\nExpired\n\nDeletedInvite",
        "x-enumNames": [
          "Normal",
          "ChatDisabled",
          "SessionReplaced",
          "Deactivated",
          "SharedAccess",
          "PendingInvite",
          "Expired",
          "DeletedInvite"
        ]
      },
      "UserVideoTrackingModel": {
        "type": "object",
        "properties": {
          "assetId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the video asset being tracked.",
            "format": "uuid",
            "nullable": true
          },
          "contentId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the content item containing the video.",
            "format": "uuid",
            "nullable": true
          },
          "videoTrackingAttribute": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VideoTrackingAttributes"
              }
            ],
            "description": "Gets or sets the type of video tracking attribute (e.g., VoD, LiveStream).\n\nUndefined\n\nWatchlist\n\nLiveStream",
            "x-enumNames": [
              "Undefined",
              "Watchlist",
              "LiveStream"
            ]
          },
          "userId": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the user.",
            "format": "uuid"
          },
          "id": {
            "type": "string",
            "description": "Gets or sets the unique identifier of the tracking record.",
            "format": "uuid",
            "nullable": true
          },
          "isFirstQuartile": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the user has reached the first quartile (25%) of the video.",
            "nullable": true
          },
          "isMidPoint": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the user has reached the midpoint (50%) of the video.",
            "nullable": true
          },
          "isThirdQuartile": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the user has reached the third quartile (75%) of the video.",
            "nullable": true
          },
          "isComplete": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the user has completed watching the video."
          },
          "isHidden": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the video has been hidden from the user's continue watching list."
          },
          "isLiveStream": {
            "type": "boolean",
            "description": "Gets or sets a value indicating whether the tracked video is a live stream."
          },
          "maxSecond": {
            "type": "number",
            "description": "Gets or sets the furthest point in seconds the user has reached in the video.",
            "format": "double"
          },
          "lastSecond": {
            "type": "number",
            "description": "Gets or sets the last playback position in seconds when the user stopped watching.",
            "format": "double"
          },
          "totalSeconds": {
            "type": "number",
            "description": "Gets or sets the total duration of the video in seconds.",
            "format": "double"
          },
          "lastBeaconDate": {
            "type": "string",
            "description": "Gets or sets the date and time of the last tracking beacon received.",
            "format": "date-time"
          },
          "keyName": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Represents video playback tracking data for a user's viewing progress."
      },
      "VerifyEmailRequestModel": {
        "required": [
          "userName"
        ],
        "type": "object",
        "properties": {
          "userName": {
            "minLength": 1,
            "type": "string",
            "description": "Gets or sets the email address of the account to verify. Required."
          },
          "token": {
            "type": "string",
            "description": "Gets or sets the verification code received via the registration confirmation email.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Request model for verifying a user's email address using a confirmation code."
      },
      "VideoHighlightModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "duration": {
            "type": "integer",
            "format": "int64"
          },
          "timestamp": {
            "type": "integer",
            "format": "int64"
          },
          "confidence": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "format": "int32"
          },
          "screenshotUrl": {
            "type": "string",
            "nullable": true
          },
          "animatedGifUrl": {
            "type": "string",
            "nullable": true
          },
          "originalTimeCode": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "segment": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "relatedAssetId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "summary": {
            "type": "string",
            "nullable": true
          },
          "number": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "captions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TextCaptionModel"
            },
            "nullable": true
          },
          "labels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LabelModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "VideoPlayerProfile": {
        "type": "object",
        "properties": {
          "format": {
            "type": "string",
            "description": "Gets or sets format of the video",
            "nullable": true
          },
          "player": {
            "type": "string",
            "description": "Gets or sets video Player name",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "VideoTrackingAttributes": {
        "enum": [
          "Undefined",
          "Watchlist",
          "LiveStream"
        ],
        "type": "string",
        "description": "\n\nUndefined\n\nWatchlist\n\nLiveStream",
        "x-enumNames": [
          "Undefined",
          "Watchlist",
          "LiveStream"
        ]
      },
      "VideoTrackingEvents": {
        "enum": [
          "Progress",
          "FirstQuartile",
          "Midpoint",
          "ThirdQuartile",
          "Complete",
          "Hide",
          "LiveStream"
        ],
        "type": "string",
        "description": "\n\nProgress\n\nFirstQuartile\n\nMidpoint\n\nThirdQuartile\n\nComplete\n\nHide\n\nLiveStream",
        "x-enumNames": [
          "Progress",
          "FirstQuartile",
          "Midpoint",
          "ThirdQuartile",
          "Complete",
          "Hide",
          "LiveStream"
        ]
      }
    },
    "securitySchemes": {
      "Bearer": {
        "type": "http",
        "description": "JWT Authorization header using the Bearer scheme. Example: 'Bearer {token}'",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    }
  }
}